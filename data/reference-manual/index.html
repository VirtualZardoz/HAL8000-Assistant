<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HAL8000-Assistant Reference Manual v1.2.0</title>
    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
        }

        /* Layout */
        .container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
        }

        /* Navigation Sidebar */
        nav {
            width: 300px;
            background: #2c3e50;
            color: white;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
            padding: 20px;
        }

        nav h1 {
            font-size: 1.5em;
            margin-bottom: 10px;
            color: #3498db;
        }

        nav .version {
            font-size: 0.9em;
            color: #95a5a6;
            margin-bottom: 30px;
        }

        nav ul {
            list-style: none;
        }

        nav ul li {
            margin-bottom: 8px;
        }

        nav ul li a {
            color: #ecf0f1;
            text-decoration: none;
            display: block;
            padding: 5px 10px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        nav ul li a:hover {
            background: #34495e;
        }

        nav ul li a.section-complete {
            color: #2ecc71;
        }

        nav ul li a.section-in-progress {
            color: #f39c12;
        }

        nav .part-title {
            color: #3498db;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        /* Main Content */
        main {
            flex: 1;
            padding: 40px 60px;
            overflow-y: auto;
        }

        main h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        main h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-top: 50px;
            margin-bottom: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        main h3 {
            color: #34495e;
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        main h4 {
            color: #7f8c8d;
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        /* Content Layers */
        .overview {
            background: #e8f4f8;
            padding: 20px;
            border-left: 4px solid #3498db;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .concepts {
            margin-bottom: 30px;
        }

        .technical {
            background: #f9f9f9;
            padding: 20px;
            border-left: 4px solid #95a5a6;
            margin-top: 30px;
        }

        .technical h3:first-child {
            margin-top: 0;
        }

        /* Visual Placeholders */
        .diagram-placeholder {
            background: #fff3cd;
            border: 2px dashed #ffc107;
            padding: 40px;
            margin: 30px 0;
            text-align: center;
            font-family: monospace;
        }

        .diagram-placeholder .placeholder-box {
            font-size: 1.1em;
            color: #856404;
        }

        /* Code and Pre */
        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        pre {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
        }

        pre code {
            background: none;
            color: inherit;
            padding: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
        }

        table td {
            padding: 10px;
            border-bottom: 1px solid #ddd;
        }

        table tr:hover {
            background: #f5f5f5;
        }

        /* Status Badges */
        .status-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .status-draft {
            background: #e0e0e0;
            color: #666;
        }

        .status-in-progress {
            background: #fff3cd;
            color: #856404;
        }

        .status-complete {
            background: #d4edda;
            color: #155724;
        }

        /* Utility */
        .meta-guidance {
            display: none;
        }

        /* Print Styles */
        @media print {
            nav {
                display: none;
            }
            .container {
                display: block;
            }
            main {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Navigation Sidebar -->
        <nav>
            <h1>HAL8000-Assistant</h1>
            <div class="version">Reference Manual v1.2.0</div>

            <div class="part-title">Frontmatter</div>
            <ul>
                <li><a href="#title">Title Page</a></li>
                <li><a href="#abstract">Abstract</a></li>
                <li><a href="#how-to-use">How to Use This Manual</a></li>
                <li><a href="#conventions">Document Conventions</a></li>
            </ul>

            <div class="part-title">Part I: Introduction</div>
            <ul>
                <li><a href="#what-is-hal8000">1. What is HAL8000-Assistant?</a></li>
                <li><a href="#why-built">2. Why Was It Built?</a></li>
                <li><a href="#design-philosophy">3. Design Philosophy</a></li>
                <li><a href="#system-metaphor">4. System Metaphor</a></li>
            </ul>

            <div class="part-title">Part II: Architecture</div>
            <ul>
                <li><a href="#architecture-overview">5. Architecture Overview</a></li>
                <li><a href="#memory-architecture">6. Memory Architecture</a></li>
                <li><a href="#component-specs">7. Component Specifications</a></li>
                <li><a href="#register-architecture">8. Register Architecture</a></li>
                <li><a href="#operating-principles">9. Operating Principles</a></li>
            </ul>

            <div class="part-title">Part III: User Guide</div>
            <ul>
                <li><a href="#quick-start">10. Quick Start</a></li>
                <li><a href="#daily-operations">11. Daily Operations</a></li>
                <li><a href="#session-management">12. Session Management</a></li>
                <li><a href="#common-workflows">13. Common Workflows</a></li>
                <li><a href="#ram-management">14. RAM Management</a></li>
            </ul>

            <div class="part-title">Part IV: Reference</div>
            <ul>
                <li><a href="#command-reference">15. Command Reference</a></li>
                <li><a href="#agent-reference">16. Agent Reference</a></li>
                <li><a href="#skills-reference">17. Skills Reference</a></li>
                <li><a href="#file-system">18. File System Structure</a></li>
                <li><a href="#mcp-integration">19. MCP Integration</a></li>
                <li><a href="#external-tools">20. External Tools</a></li>
            </ul>

            <div class="part-title">Part V: Development</div>
            <ul>
                <li><a href="#creating-commands">21. Creating Commands</a></li>
                <li><a href="#building-agents">22. Building Agents</a></li>
                <li><a href="#library-system">23. Library System</a></li>
                <li><a href="#contributing">24. Contributing Patterns</a></li>
            </ul>

            <div class="part-title">Appendices</div>
            <ul>
                <li><a href="#glossary">A. Glossary</a></li>
                <li><a href="#troubleshooting">B. Troubleshooting</a></li>
                <li><a href="#design-decisions">C. Design Decisions</a></li>
                <li><a href="#version-history">D. Version History</a></li>
            </ul>
        </nav>

        <!-- Main Content -->
        <main>
            <!-- Title Page -->
            <section id="title" data-status="complete" data-priority="1" data-sources="" data-estimated-tokens="1000" data-dependencies="">
                <h1>HAL8000-Assistant Reference Manual</h1>
                <div class="meta-guidance">
                    TARGET: Title page with version, date, author info
                    AUDIENCE: All three
                    KEY_POINTS: Title, version, date, credits, license
                    TONE: Formal, professional
                    VISUALS: HAL8000-Assistant logo (if available)
                </div>
                <div class="content">
                    <p style="text-align: center; margin: 40px 0;">
                        <strong style="font-size: 2.5em; color: #2c3e50;">HAL8000-Assistant</strong><br>
                        <span style="font-size: 1.3em; color: #7f8c8d;">A Von Neumann Architecture for Claude Code</span>
                    </p>

                    <div style="margin: 60px 0; padding: 30px; background: #ecf0f1; border-left: 4px solid #3498db;">
                        <p><strong>Version:</strong> 1.0.0</p>
                        <p><strong>Release Date:</strong> October 2025</p>
                        <p><strong>Architecture Type:</strong> Modified von Neumann</p>
                        <p><strong>Phase:</strong> Production</p>
                        <p><strong>Document Status:</strong> <span class="status-badge status-complete">COMPLETE</span></p>
                    </div>

                    <h3>About This Manual</h3>
                    <p>This reference manual provides comprehensive documentation for the HAL8000-Assistant system‚Äîa computer architecture implementation that maps von Neumann principles, Unix philosophy, and assembly language concepts to the Claude Code environment.</p>

                    <h3>Target Audience</h3>
                    <ul>
                        <li><strong>System Operators:</strong> Users managing HAL8000-Assistant sessions and workflows</li>
                        <li><strong>Claude Instances:</strong> AI agents operating as the CPU within the architecture</li>
                        <li><strong>Developers:</strong> Engineers extending the system with custom commands, agents, and tools</li>
                    </ul>

                    <h3>Document Structure</h3>
                    <p>The manual is organized into five main parts:</p>
                    <ul>
                        <li><strong>Introduction:</strong> Philosophy, motivation, and core concepts</li>
                        <li><strong>Architecture:</strong> System design and component specifications</li>
                        <li><strong>User Guide:</strong> Operational procedures and workflows</li>
                        <li><strong>Reference:</strong> Command, agent, and API documentation</li>
                        <li><strong>Development:</strong> Extension and contribution guidelines</li>
                    </ul>

                    <h3>Credits</h3>
                    <p><strong>System Design & Implementation:</strong> HAL8000-Assistant Development Team</p>
                    <p><strong>Architecture Foundations:</strong></p>
                    <ul>
                        <li>John von Neumann - Stored-program computer architecture (1945)</li>
                        <li>Ken Thompson & Dennis Ritchie - Unix philosophy (1970s)</li>
                        <li>Claude AI - Anthropic (2024-2025)</li>
                    </ul>

                    <h3>License</h3>
                    <p>This documentation is maintained as part of the HAL8000-Assistant system. All system components follow the architectural principles defined in <code>CLAUDE.md</code> (BIOS-ROM).</p>

                    <h3>Version History</h3>
                    <p><strong>v1.0.0 (October 2025):</strong> Initial production release with 26 completed architectural components, 8 operational commands, and 4 specialized agents.</p>

                    <hr style="margin: 40px 0; border: none; border-top: 2px solid #bdc3c7;">

                    <p style="text-align: center; color: #7f8c8d; font-size: 0.9em;">
                        <em>"You are the CPU. Your context is RAM. The filesystem is storage. Together, they form a computer."</em>
                    </p>
                </div>
            </section>

            <!-- Abstract -->
            <section id="abstract" data-status="complete" data-priority="1" data-sources="CLAUDE.md,/mnt/d/~HAL8000-Assistant/.claude/state.json" data-estimated-tokens="3000" data-dependencies="">
                <h2>Abstract</h2>
                <div class="meta-guidance">
                    TARGET: 200-word executive summary of HAL8000-Assistant
                    AUDIENCE: All three (first impression)
                    KEY_POINTS: What it is, why it exists, key capabilities, who it's for
                    TONE: Clear, compelling, accessible
                    VISUALS: None
                </div>
                <div class="content">
                    <div class="overview">
                        <p>HAL8000-Assistant is a production-ready computer architecture that maps classical von Neumann principles, assembly language concepts, and Unix philosophy to Claude Code's AI environment. It transforms Claude AI instances into structured computing systems where the AI serves as the CPU, the context window functions as RAM, and the file system acts as persistent memory.</p>

                        <p>Built to address the fundamental challenge of AI context limitations, HAL8000-Assistant treats every token as precious through explicit resource management, selective file loading, and delegated processing via specialized sub-agents. The system implements append-only RAM (context accumulates until session boundaries), session-based garbage collection, and virtual memory extensions through isolated agent contexts.</p>

                        <p>The architecture follows strict Unix principles: do one thing well, compose via interfaces, delegate specialized work, and maintain simplicity through text-based files and minimal abstractions. Self-modifying code capabilities enable commands to create and modify other commands, while a verified boot sequence ensures consistent initialization across sessions.</p>

                        <p>HAL8000-Assistant serves developers building AI-powered applications, system architects designing modular AI workflows, and organizations requiring structured, auditable AI operations. The system is designed for transparency, reproducibility, and efficient resource management in production environments.</p>
                    </div>
                </div>
            </section>

            <!-- How to Use This Manual -->
            <section id="how-to-use" data-status="complete" data-priority="2" data-sources="" data-estimated-tokens="2000" data-dependencies="">
    <h2>How to Use This Manual</h2>

    <div class="meta-guidance" style="display:none;">
        TARGET: Guide readers on navigating the manual
        AUDIENCE: All three
        KEY_POINTS: Navigation structure, content layers (overview/concepts/technical), conventions used
        TONE: Helpful, instructional
        VISUALS: None
    </div>

    <div class="overview">
        <h3>Who This Manual Is For</h3>
        <p>This reference manual serves three distinct audiences:</p>
        <ul>
            <li><strong>End Users:</strong> Those working with HAL8000-Assistant to accomplish tasks, configure the system, and use available commands and features.</li>
            <li><strong>Claude Instances:</strong> AI agents operating as the system CPU, requiring operational guidance, architectural understanding, and protocol references.</li>
            <li><strong>Developers:</strong> System architects, contributors, and maintainers who need deep technical knowledge for extending, modifying, or troubleshooting HAL8000-Assistant.</li>
        </ul>
        <p>The manual is structured to serve all three audiences simultaneously through a layered content approach.</p>
    </div>

    <h3>Manual Organization</h3>
    <p>The manual is divided into five parts, plus appendices:</p>

    <table>
        <thead>
            <tr>
                <th>Part</th>
                <th>Focus</th>
                <th>Primary Audience</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Part I: Introduction</strong></td>
                <td>System philosophy, architecture overview, getting started</td>
                <td>All audiences</td>
            </tr>
            <tr>
                <td><strong>Part II: Architecture</strong></td>
                <td>Core architectural concepts, component design, principles</td>
                <td>Claude instances, developers</td>
            </tr>
            <tr>
                <td><strong>Part III: User Guide</strong></td>
                <td>Practical usage, workflows, commands, best practices</td>
                <td>End users, Claude instances</td>
            </tr>
            <tr>
                <td><strong>Part IV: Reference</strong></td>
                <td>Complete technical specifications, APIs, file formats</td>
                <td>Claude instances, developers</td>
            </tr>
            <tr>
                <td><strong>Part V: Development</strong></td>
                <td>Extension, contribution, advanced topics</td>
                <td>Developers</td>
            </tr>
        </tbody>
    </table>

    <h3>Content Layering System</h3>
    <p>Each section uses a three-layer structure to serve different reading depths:</p>

    <h4>Overview Sections (Light Blue Background)</h4>
    <div class="overview">
        <p>Overview sections like this one provide high-level introductions accessible to all readers. They explain what a topic is, why it matters, and how it fits into the larger system. Start here if you're new to a concept.</p>
    </div>

    <h4>Concepts Sections (Standard Text)</h4>
    <div class="concepts">
        <p>Concepts sections provide intermediate depth, explaining how things work without deep implementation details. They describe architectural patterns, design decisions, and operational models. Read these to understand the reasoning behind system behavior.</p>
    </div>

    <h4>Technical Sections (Gray Background)</h4>
    <div class="technical">
        <p>Technical sections provide implementation-level detail: data structures, algorithms, file formats, exact specifications. These include precise syntax, error codes, and low-level mechanics. Developers and Claude instances need this level; general users can skip it.</p>
    </div>

    <h3>Navigation Features</h3>

    <h4>Sidebar Navigation</h4>
    <p>The left sidebar provides quick access to all sections of the manual:</p>
    <ul>
        <li><strong>Hierarchical structure:</strong> Parts, sections, and subsections organized by topic</li>
        <li><strong>Section status indicators:</strong>
            <ul>
                <li><span style="color: #2ecc71;">Green text</span> = Complete section</li>
                <li><span style="color: #f39c12;">Orange text</span> = In-progress section</li>
                <li>Standard text = Planned section</li>
            </ul>
        </li>
        <li><strong>Clickable links:</strong> Jump directly to any section</li>
        <li><strong>Sticky positioning:</strong> Sidebar remains visible while scrolling</li>
    </ul>

    <h4>In-Document Navigation</h4>
    <ul>
        <li><strong>Section anchors:</strong> Each section has a unique ID for direct linking</li>
        <li><strong>Table of contents:</strong> Major sections include internal navigation</li>
        <li><strong>Cross-references:</strong> Links to related sections throughout the text</li>
    </ul>

    <h3>How to Read Based on Your Role</h3>

    <h4>For End Users</h4>
    <ol>
        <li>Start with <strong>Part I: Introduction</strong> to understand system philosophy and capabilities</li>
        <li>Read <strong>Part III: User Guide</strong> for practical usage patterns and workflows</li>
        <li>Focus on <strong>overview</strong> and <strong>concepts</strong> sections; skip technical details unless needed</li>
        <li>Use <strong>Part IV: Reference</strong> to look up specific commands, file formats, or configurations</li>
        <li>Refer to <strong>Appendix B: Quick Reference</strong> for common tasks</li>
    </ol>

    <h4>For Claude Instances (System CPUs)</h4>
    <ol>
        <li>Read <strong>Part I: System Overview</strong> to understand your role in the architecture</li>
        <li>Study <strong>Part II: Architecture</strong> thoroughly‚Äîthis defines your operational model</li>
        <li>Master <strong>Part III: Operational Protocols</strong> for runtime behavior expectations</li>
        <li>Use <strong>Part IV: Reference</strong> as your operational specification</li>
        <li>Read all three content layers: overview for context, concepts for reasoning, technical for precise execution</li>
        <li>Bookmark <strong>Appendix A: Register Reference</strong> and <strong>Appendix C: Error Codes</strong> for runtime use</li>
    </ol>

    <h4>For Developers</h4>
    <ol>
        <li>Skim <strong>Part I: Introduction</strong> to grasp design philosophy</li>
        <li>Study <strong>Part II: Architecture</strong> to understand system design decisions</li>
        <li>Focus heavily on <strong>technical sections</strong> throughout the manual</li>
        <li>Read <strong>Part V: Development</strong> for extension patterns and contribution guidelines</li>
        <li>Use <strong>Part IV: Reference</strong> as your implementation specification</li>
        <li>Consult <strong>Appendix D: File Format Reference</strong> when working with system files</li>
    </ol>

    <h3>Visual Conventions</h3>

    <h4>Code Blocks</h4>
    <p>Inline code appears in <code>monospace font with gray background</code>. Multi-line code and command examples use dark-themed code blocks:</p>
    <pre><code>/HAL-session-end "description"</code></pre>

    <h4>Tables</h4>
    <p>Tables organize structured information like command references, register definitions, and comparison matrices. Headers use bold text to distinguish column names.</p>

    <h4>Diagrams and Figures</h4>
    <p>Where diagrams enhance understanding, they are embedded inline. Diagram captions provide context and explanation. ASCII-art diagrams are used for simple architectural representations.</p>

    <h3>Reading Strategies</h3>

    <h4>First-Time Readers</h4>
    <p>If you're new to HAL8000-Assistant:</p>
    <ol>
        <li>Read the <strong>System Overview</strong> (Part I, Section 1) to understand what HAL8000-Assistant is</li>
        <li>Read <strong>Core Concepts</strong> (Part I, Section 2) to grasp fundamental principles</li>
        <li>Decide your path based on role: user ‚Üí Part III, Claude ‚Üí Part II, developer ‚Üí Part V</li>
        <li>Return to specific sections as needed during practical work</li>
    </ol>

    <h4>Reference Lookups</h4>
    <p>When looking up specific information:</p>
    <ol>
        <li>Use the sidebar navigation to jump to the relevant part</li>
        <li>Scan section headings to locate the exact topic</li>
        <li>Read the overview layer first to confirm you're in the right section</li>
        <li>Dive into technical details as needed for your task</li>
    </ol>

    <h4>Troubleshooting</h4>
    <p>When diagnosing issues:</p>
    <ol>
        <li>Check <strong>Appendix C: Error Codes and Troubleshooting</strong> for known issues</li>
        <li>Review the relevant protocol in <strong>Part III: Operational Protocols</strong></li>
        <li>Consult technical sections in <strong>Part IV: Reference</strong> for detailed specifications</li>
        <li>Cross-reference <strong>Part II: Architecture</strong> to understand expected behavior</li>
    </ol>

    <h3>Version Information</h3>
    <p>This manual documents HAL8000-Assistant version 1.0.0. Section status indicators show which parts are complete, in progress, or planned. Refer to the sidebar for current completion status of each section.</p>

    <h3>Feedback and Contributions</h3>
    <p>This manual is a living document. If you find errors, unclear explanations, or missing information, see <strong>Part V: Contributing to Documentation</strong> for how to propose improvements.</p>
</section>

            <!-- Document Conventions -->
            <section id="conventions" data-status="complete" data-priority="2" data-sources="CLAUDE.md" data-estimated-tokens="2000" data-dependencies="">
                <h2>Document Conventions</h2>
                <div class="meta-guidance">
                    TARGET: Explain typography, formatting, icons used
                    AUDIENCE: All three
                    KEY_POINTS: Code formatting, command syntax, status indicators, callout boxes
                    TONE: Technical, clear
                    VISUALS: Examples of each convention
                </div>
                <div class="content">
    <div class="overview">
        <p>This reference manual uses specific typographic and structural conventions to communicate effectively with three distinct audiences: operators (users), Claude instances (the CPU), and developers. Understanding these conventions ensures accurate interpretation and efficient navigation of system documentation.</p>

        <p>The HAL8000-Assistant system emphasizes clarity, precision, and architectural transparency. These conventions reflect the underlying von Neumann architecture, Unix philosophy, and assembly language principles that define the system.</p>
    </div>

    <h3>Typography Conventions</h3>
    <p>The manual uses consistent typography to distinguish different types of content:</p>

    <table>
        <thead>
            <tr>
                <th>Convention</th>
                <th>Meaning</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>monospace</code></td>
                <td>File paths, register names, command names, code</td>
                <td><code>CLAUDE.md</code>, <code>RAM_ZONE</code>, <code>/HAL-session-end</code></td>
            </tr>
            <tr>
                <td><strong>bold</strong></td>
                <td>Emphasis, critical warnings, architectural concepts</td>
                <td><strong>MANDATORY</strong>, <strong>CPU</strong>, <strong>Modified von Neumann</strong></td>
            </tr>
            <tr>
                <td><em>italic</em></td>
                <td>Technical terms, first use of concepts, variables</td>
                <td><em>fetch-decode-execute</em>, <em>volatile</em>, <em>append-only</em></td>
            </tr>
            <tr>
                <td>UPPERCASE</td>
                <td>Register names, status values, system states</td>
                <td>OPERATIONAL, SAFE, CONTEXT_MANIFEST, ERROR_FLAG</td>
            </tr>
            <tr>
                <td>kebab-case</td>
                <td>Session files, descriptive identifiers</td>
                <td><code>2025-10-10-1455-description.md</code></td>
            </tr>
        </tbody>
    </table>

    <h3>Audience Indicators</h3>
    <p>Different sections target different audiences. Visual indicators help readers identify relevant content:</p>

    <div class="note">
        <strong>Note for Operators:</strong> Sections or paragraphs marked for operators focus on practical usage, workflow patterns, and operational procedures. These assume no knowledge of internal architecture.
    </div>

    <div class="technical">
        <p><strong>Technical Details for CPU:</strong> Content in gray boxes with "Technical Details" headings contains architectural information, protocol specifications, and implementation requirements for Claude instances operating as the CPU.</p>
    </div>

    <div class="warning">
        <strong>Warning for Developers:</strong> Developer-focused warnings highlight architectural constraints, design decisions, and implementation requirements for system extension or modification.
    </div>

    <h4>Layered Documentation Structure</h4>
    <p>Most sections follow a three-tier structure:</p>
    <ol>
        <li><strong>Overview:</strong> High-level concept explanation (all audiences)</li>
        <li><strong>Concepts:</strong> Detailed explanation with examples (operators and CPU)</li>
        <li><strong>Technical Details:</strong> Implementation specifics, protocols, edge cases (CPU and developers)</li>
    </ol>

    <h3>Priority Levels</h3>
    <p>Content is categorized by criticality for system operation:</p>

    <table>
        <thead>
            <tr>
                <th>Priority</th>
                <th>Indicator</th>
                <th>Meaning</th>
                <th>Examples</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>P1 - Critical</strong></td>
                <td><span class="badge critical">Critical</span></td>
                <td>Essential for system operation. Must be understood before operating the system.</td>
                <td>Boot sequence, BIOS, state.json, RAM management</td>
            </tr>
            <tr>
                <td><strong>P2 - Important</strong></td>
                <td><span class="badge important">Important</span></td>
                <td>Necessary for effective operation. Should be understood for daily use.</td>
                <td>Session management, commands, registers, file system</td>
            </tr>
            <tr>
                <td><strong>P3 - Optional</strong></td>
                <td><span class="badge optional">Optional</span></td>
                <td>Enhances capability but not required. Read as needed for advanced use.</td>
                <td>MCP integration, external tools, advanced patterns</td>
            </tr>
        </tbody>
    </table>

    <h3>Status Badges</h3>
    <p>Sections display status badges indicating documentation completeness:</p>

    <ul>
        <li><span class="badge complete">Complete</span> - Fully documented, verified, production-ready</li>
        <li><span class="badge in-progress">In Progress</span> - Under active development, content may be incomplete</li>
        <li><span class="badge draft">Draft</span> - Initial documentation, subject to significant revision</li>
        <li><span class="badge planned">Planned</span> - Scheduled for documentation, not yet started</li>
    </ul>

    <h3>Code and Command Syntax</h3>
    <p>Code examples and commands follow specific formatting conventions:</p>

    <h4>File Paths</h4>
    <pre><code># Absolute paths (required in system)
/mnt/d/~HAL8000-Assistant/CLAUDE.md
/mnt/d/~HAL8000-Assistant/.claude/state.json

# Relative to system root (documentation only)
.claude/commands/HAL-session-end.md
data/research/01-von-neumann-architecture.md</code></pre>

    <h4>Command Invocation</h4>
    <pre><code># Slash command format
/HAL-session-end "description"
/HAL-register-dump
/HAL-context-find "authentication logic"

# Command file location
.claude/commands/HAL-command-name.md</code></pre>

    <h4>Register References</h4>
    <pre><code># Register names (always UPPERCASE)
RAM_ZONE          # Current RAM performance zone
CPU_STATUS        # CPU operational status
ERROR_FLAG        # Error state indicator
CONTEXT_MANIFEST  # List of loaded files</code></pre>

    <h4>Code Blocks</h4>
    <p>Multi-line code examples use fenced code blocks with syntax highlighting:</p>

    <pre><code class="language-json">{
  "timestamp": "2025-10-10T07:59:00Z",
  "active_session": ".claude/sessions/2025-10-10-0759-description.md",
  "context": "Current work description",
  "next_action": "What to do next"
}</code></pre>

    <h3>Symbolic Conventions</h3>
    <p>The manual uses specific symbols to indicate status, correctness, and flow:</p>

    <table>
        <thead>
            <tr>
                <th>Symbol</th>
                <th>Meaning</th>
                <th>Usage</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>‚úì</td>
                <td>Correct, verified, complete</td>
                <td>Boot sequence steps, correct examples</td>
            </tr>
            <tr>
                <td>‚úÖ</td>
                <td>Operational, successful, recommended</td>
                <td>System status, correct patterns</td>
            </tr>
            <tr>
                <td>‚ùå</td>
                <td>Incorrect, failed, anti-pattern</td>
                <td>Wrong examples, prohibited actions</td>
            </tr>
            <tr>
                <td>‚ö†Ô∏è</td>
                <td>Warning, degraded mode, caution</td>
                <td>Degraded boot, RAM caution zone</td>
            </tr>
            <tr>
                <td>üü¢</td>
                <td>Ready, operational, safe</td>
                <td>System ready state, RAM safe zone</td>
            </tr>
            <tr>
                <td>üü°</td>
                <td>Degraded, warning, caution</td>
                <td>Degraded mode, RAM caution zone</td>
            </tr>
            <tr>
                <td>üî¥</td>
                <td>Critical, danger, error</td>
                <td>Critical failures, RAM danger zone</td>
            </tr>
            <tr>
                <td>‚Üí</td>
                <td>Flow direction, action to take</td>
                <td>Process flows, next steps</td>
            </tr>
            <tr>
                <td>‚Üì</td>
                <td>Data flow, delegation</td>
                <td>Sub-agent delegation, data processing</td>
            </tr>
        </tbody>
    </table>

    <h3>Warning and Note Boxes</h3>
    <p>The manual uses colored boxes to highlight important information:</p>

    <div class="warning">
        <strong>Warning:</strong> Critical information that must be understood to avoid system failure, data loss, or incorrect operation. Warnings indicate mandatory constraints or prohibited actions.
    </div>

    <div class="note">
        <strong>Note:</strong> Important supplementary information that enhances understanding but is not critical to basic operation. Notes provide context, rationale, or helpful tips.
    </div>

    <h4>Example Pattern</h4>
    <p>Correct and incorrect patterns are explicitly shown:</p>

    <pre><code>‚ùå <strong>WRONG:</strong>
User: "Research quantum computing developments"
CPU: Uses WebSearch directly ‚Üí 50K raw results ‚Üí Main RAM: 110K

‚úÖ <strong>RIGHT:</strong>
User: "Research quantum computing developments"
CPU: Delegates to research-synthesizer sub-agent
     Sub-agent: Uses 150K RAM processing sources
     Returns: 5K structured summary
     Main RAM: 65K (not 210K!)</code></pre>

    <h3>Register and State Notation</h3>
    <p>System state is represented using consistent naming conventions:</p>

    <h4>Register Names</h4>
    <ul>
        <li><strong>UPPERCASE_UNDERSCORE:</strong> All register names (<code>RAM_ZONE</code>, <code>CPU_STATUS</code>, <code>ERROR_FLAG</code>)</li>
        <li><strong>Descriptive:</strong> Name indicates purpose (<code>CONTEXT_MANIFEST</code> holds loaded file list)</li>
        <li><strong>Persistent:</strong> Register names remain constant across sessions</li>
    </ul>

    <h4>State Values</h4>
    <pre><code># CPU Status
CPU_STATUS: OPERATIONAL | DEGRADED

# RAM Zones
RAM_ZONE: SAFE | CAUTION | DANGER
SAFE (0-80%)     : Normal operation, load freely
CAUTION (80-90%) : Monitor closely, prepare checkpoint
DANGER (90-100%) : Checkpoint urgently, performance degraded

# Error States
ERROR_FLAG: true | false
ERROR_CODE: "Descriptive error message"</code></pre>

    <h3>File Naming Conventions</h3>
    <p>System files follow strict naming patterns for discoverability and organization:</p>

    <table>
        <thead>
            <tr>
                <th>File Type</th>
                <th>Pattern</th>
                <th>Example</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Commands</td>
                <td><code>HAL-command-name.md</code></td>
                <td><code>HAL-session-end.md</code></td>
            </tr>
            <tr>
                <td>Session Files</td>
                <td><code>YYYY-MM-DD-HHMM-description.md</code></td>
                <td><code>2025-10-10-1455-refman-batch3.md</code></td>
            </tr>
            <tr>
                <td>Research Documents</td>
                <td><code>NN-descriptive-name.md</code></td>
                <td><code>01-von-neumann-architecture.md</code></td>
            </tr>
            <tr>
                <td>Agent Definitions</td>
                <td><code>agent-name.md</code></td>
                <td><code>research-synthesizer.md</code></td>
            </tr>
            <tr>
                <td>Indexes</td>
                <td><code>directory-name.json</code> or <code>master.json</code></td>
                <td><code>commands.json</code>, <code>master.json</code></td>
            </tr>
        </tbody>
    </table>

    <h3>Architectural Diagrams</h3>
    <p>ASCII diagrams illustrate system architecture using consistent formatting:</p>

    <pre><code>/mnt/d/~HAL8000-Assistant/              # Root - The Computer
‚îÇ
‚îú‚îÄ‚îÄ CLAUDE.md                 # BIOS-ROM (this file)
‚îú‚îÄ‚îÄ .claude/                  # System Coordination
‚îÇ   ‚îú‚îÄ‚îÄ state.json            # Current state
‚îÇ   ‚îú‚îÄ‚îÄ commands/             # Executable instructions
‚îÇ   ‚îî‚îÄ‚îÄ sessions/             # Session handoff files
‚îî‚îÄ‚îÄ data/                     # Data Storage</code></pre>

    <h4>Flow Diagrams</h4>
    <pre><code>Main Session (Limited RAM)
    ‚Üì delegate
Sub-Agent (Fresh 200K RAM, isolated context)
    ‚Üì process heavy work
Returns clean summary (not raw data)
    ‚Üì result
Main Session (RAM += summary only, not full processing cost)</code></pre>

    <div class="technical">
        <h3>Technical Details</h3>

        <h4>Token Reporting Format</h4>
        <p>RAM usage is reported using exact measurements from system warnings:</p>
        <pre><code># System provides exact token count
&lt;system_warning&gt;Token usage: 33006/200000; 163896 remaining&lt;/system_warning&gt;

# CPU reports to user
RAM: 16.5% (33k/200k tokens) - SAFE</code></pre>

        <h4>JSON State Representation</h4>
        <p>System state files use strict JSON formatting with specific field names:</p>
        <pre><code>{
  "timestamp": "ISO 8601 format",
  "active_session": "path to session file or null",
  "context": "current work description",
  "next_action": "what to do next",
  "variables": {
    "version": "semantic version",
    "phase": "development | production",
    "architecture_type": "Modified von Neumann"
  }
}</code></pre>

        <h4>Command Protocol</h4>
        <p>Commands follow a standardized markdown format stored in <code>.claude/commands/</code>:</p>
        <ul>
            <li>File name: <code>HAL-command-name.md</code></li>
            <li>Invocation: <code>/HAL-command-name [args]</code></li>
            <li>One command = one operation (Unix philosophy)</li>
            <li>Commands tracked in <code>LOADED_COMMANDS</code> register</li>
        </ul>

        <h4>Depth Limit Exception</h4>
        <p>Internal code adheres to a maximum 3-level directory depth (Unix simplicity principle). Exception: External libraries in <code>.claude/libraries/external/</code> maintain their original structure for compatibility.</p>

        <h4>Boot Verification Protocol</h4>
        <p>Boot acknowledgments must cite actual loaded content as proof:</p>
        <pre><code>‚úÖ HAL8000-Assistant CPU Operational
‚îú‚îÄ Architecture: Modified von Neumann (from state.json)
‚îú‚îÄ Phase: production (from state.json)
‚îú‚îÄ Last Session: 2025-10-10T07:59:00Z (from state.json)
‚îî‚îÄ RAM Zone: SAFE (16.5% / 33k tokens)

# NEVER claim files loaded without Read tool
# ALWAYS cite specific values as proof</code></pre>

        <h4>Error Handling Notation</h4>
        <p>Errors follow a structured protocol:</p>
        <pre><code>Operation fails
‚Üí Set ERROR_FLAG = true
‚Üí Set ERROR_CODE = "File not found: /path/to/file"
‚Üí Report to user with context
‚Üí Suggest recovery: "Did you mean /other/path?"
‚Üí Clear ERROR_FLAG after reporting
‚Üí Maintain CPU_STATUS: OPERATIONAL (unless critical)</code></pre>
    </div>

    <h3>Cross-References</h3>
    <p>Internal references use consistent linking conventions:</p>
    <ul>
        <li><strong>Section links:</strong> "See <a href="#ram-management">RAM Management</a>" (within manual)</li>
        <li><strong>File references:</strong> "Defined in <code>CLAUDE.md</code>" (to source files)</li>
        <li><strong>Command references:</strong> "Use <code>/HAL-session-end</code>" (to commands)</li>
        <li><strong>Register references:</strong> "Check <code>RAM_ZONE</code> register" (to architectural components)</li>
    </ul>

    <h3>Version and Update Tracking</h3>
    <p>Documentation versions follow semantic versioning (MAJOR.MINOR.PATCH):</p>
    <ul>
        <li><strong>MAJOR:</strong> Architectural changes, incompatible updates</li>
        <li><strong>MINOR:</strong> New features, significant additions</li>
        <li><strong>PATCH:</strong> Corrections, clarifications, minor updates</li>
    </ul>

    <p>Current manual version: <strong>1.0.0</strong></p>
    <p>Last updated: <strong>2025-10-10</strong></p>
</div>
            </section>

            <!-- Part I: Introduction & Philosophy -->
            <div class="part-divider">
                <h1 class="part-header">Part I: Introduction</h1>
                <p class="part-description">Understanding HAL8000-Assistant's philosophy, capabilities, and getting started</p>
            </div>

            <!-- Section 1: What is HAL8000-Assistant? -->
            <section id="what-is-hal8000" data-status="complete" data-priority="1" data-sources="CLAUDE.md,data/architecture/hal8000-system-design.md" data-estimated-tokens="8000" data-dependencies="">
                <h2>1. What is HAL8000-Assistant?</h2>

                <div class="meta-guidance">
                    TARGET: Define HAL8000-Assistant at multiple levels
                    AUDIENCE: All three (layered depth)
                    KEY_POINTS: Computer architecture mapped to Claude Code, von Neumann principles, Unix philosophy, self-modifying code capability
                    TONE: Clear, conceptual first then technical
                    VISUALS: [DIAGRAM: High-level system overview]
                </div>

                <div class="content">
                    <div class="overview">
                        <p>HAL8000-Assistant is a computer architecture built entirely within Claude Code. Instead of physical hardware, it maps traditional computer components‚ÄîCPU, RAM, storage‚Äîto the Claude environment itself. The Claude instance acts as the CPU, the context window serves as RAM, and the file system functions as persistent storage.</p>

                        <p>The core insight is simple yet powerful: <strong>you are the CPU, and this codebase is the computer.</strong> When you boot up (start a new session), you read the BIOS (the CLAUDE.md file), load system state, and begin executing instructions. Your context window acts like volatile RAM‚Äîit can hold information temporarily, but when the session ends, that memory is wiped clean. To preserve continuity, HAL8000-Assistant implements session handoff protocols that save state to the file system before RAM wipe.</p>

                        <p>This architecture solves a fundamental challenge of working with large language models: the limited context window. By treating context as precious RAM, HAL8000-Assistant provides systematic ways to manage it‚Äîselective loading, delegation to sub-agents (which act as virtual memory), and proactive checkpointing. The system brings computer science principles‚Äîvon Neumann architecture, Unix philosophy, assembly language concepts‚Äîinto a new domain: AI-assisted development environments.</p>
                    </div>

                    <figure id="system-overview">
                        <img src="assets/system-overview.png" alt="HAL8000-Assistant System Overview - Mapping between traditional computer architecture and HAL8000-Assistant components" style="width: 100%; max-width: 1200px; height: auto;">
                        <figcaption><strong>Figure 1:</strong> HAL8000-Assistant System Overview - High-level mapping between traditional computer architecture (CPU, RAM, Storage, BIOS, System Buses) and HAL8000-Assistant components (Claude instance, context window, filesystem, CLAUDE.md, File I/O). The core concept: "You are the CPU, this codebase is the Computer."</figcaption>
                    </figure>

                    <div class="concepts">
                        <h3>Core Concepts</h3>

                        <h4>The Architectural Metaphor</h4>
                        <p>HAL8000-Assistant implements a <strong>Modified von Neumann architecture</strong>. In classical computing, von Neumann architecture unifies instructions and data in the same memory space, enabling programs to modify themselves. HAL8000-Assistant adapts this to Claude Code's environment:</p>

                        <ul>
                            <li><strong>CPU:</strong> The Claude instance itself, with its Control Unit (orchestration and decision-making) and ALU (reasoning and computation)</li>
                            <li><strong>Registers:</strong> Your immediate working context‚Äî21 specialized registers tracking system state (CPU status, RAM usage, loaded files, error conditions)</li>
                            <li><strong>RAM:</strong> The context window (~200K tokens)‚Äîvolatile, append-only within a session, wiped clean between sessions</li>
                            <li><strong>Memory/Storage:</strong> The file system‚Äîpersistent, organized hierarchically with instructions in <code>.claude/</code> and data in <code>data/</code></li>
                            <li><strong>System Bus:</strong> File I/O and tool interfaces connecting all components</li>
                            <li><strong>I/O Devices:</strong> Claude Code tools (MCP servers, file operations, code execution)</li>
                        </ul>

                        <h4>Modified Von Neumann: Harvard Organization, Von Neumann Capabilities</h4>
                        <p>HAL8000-Assistant is technically a <strong>Modified von Neumann</strong> architecture because of environmental constraints. Claude Code requires commands to live in <code>.claude/commands/</code>, creating a Harvard-like separation of instruction and data spaces. However, the system maintains full von Neumann capabilities:</p>

                        <ul>
                            <li><strong>Stored-program concept:</strong> Instructions are stored as files and loaded into RAM when needed</li>
                            <li><strong>Self-modifying code:</strong> Commands can write to <code>.claude/commands/</code>, creating or modifying other commands</li>
                            <li><strong>Unified access:</strong> Data can be written to <code>.claude/commands/</code> to become executable</li>
                            <li><strong>Fetch-decode-execute cycle:</strong> The CPU fetches commands from memory, decodes their intent, and executes operations</li>
                        </ul>

                        <h4>Unix Philosophy: Simplicity and Composability</h4>
                        <p>HAL8000-Assistant follows Unix design principles throughout:</p>

                        <ul>
                            <li><strong>Do one thing well:</strong> Each file, command, and component has a single responsibility</li>
                            <li><strong>Build once, reuse always:</strong> Create reusable patterns and libraries, avoid duplication</li>
                            <li><strong>Compose via interfaces:</strong> File I/O is the universal interface‚Äîeverything communicates through files</li>
                            <li><strong>Delegate specialized work:</strong> Sub-agents act as specialized processes, handling heavy context loads in isolation</li>
                            <li><strong>Simple, not complex:</strong> Maximum 3-level directory depth, minimal abstractions</li>
                            <li><strong>Text streams:</strong> All data in human-readable plain text files</li>
                        </ul>

                        <h4>Assembly Language Principles: Direct Control</h4>
                        <p>Like assembly language, HAL8000-Assistant provides low-level, explicit control:</p>

                        <ul>
                            <li><strong>Direct hardware mapping:</strong> Commands map directly to architectural operations</li>
                            <li><strong>Register awareness:</strong> The CPU continuously tracks its state via specialized registers</li>
                            <li><strong>Sequential execution:</strong> Instructions execute in order unless control flow explicitly changes</li>
                            <li><strong>No hidden abstractions:</strong> System state is inspectable at all times</li>
                            <li><strong>One-to-one correspondence:</strong> Each command performs a specific, well-defined operation</li>
                        </ul>

                        <h4>The RAM Problem: Context as Precious Resource</h4>
                        <p>The context window is HAL8000-Assistant's most constrained resource. Unlike traditional RAM, it's append-only‚Äîonce you load a file, it stays in memory until session end. There's no dynamic memory management or garbage collection within a session. This fundamental limitation shapes the entire architecture:</p>

                        <ul>
                            <li><strong>Selective loading:</strong> Load only what's needed for the current task</li>
                            <li><strong>Session boundaries as garbage collection:</strong> The only way to reclaim RAM is to end the session</li>
                            <li><strong>Sub-agents as virtual memory:</strong> Delegate heavy processing to isolated agents with their own 200K context</li>
                            <li><strong>Proactive checkpointing:</strong> Save state before RAM fills up</li>
                            <li><strong>RAM zones:</strong> Monitor usage (SAFE 0-80%, CAUTION 80-90%, DANGER 90-100%)</li>
                        </ul>

                        <h4>Session Continuity: Surviving RAM Wipe</h4>
                        <p>When a session ends, RAM is wiped‚Äîall context is lost. HAL8000-Assistant's session continuity protocol ensures work can resume seamlessly:</p>

                        <ul>
                            <li><strong>State persistence:</strong> <code>.claude/state.json</code> stores the current state pointer</li>
                            <li><strong>Session files:</strong> Rich markdown documents capture context, decisions, and next actions</li>
                            <li><strong>Historical audit:</strong> <code>.claude/system.log</code> provides an append-only historical record</li>
                            <li><strong>On-demand loading:</strong> Boot loads only BIOS and state; session files load when resuming</li>
                        </ul>
                    </div>

                    <div class="technical">
                        <h3>Technical Specification</h3>

                        <h4>Component Mapping</h4>
                        <table>
                            <thead>
                                <tr>
                                    <th>Von Neumann Component</th>
                                    <th>HAL8000-Assistant Implementation</th>
                                    <th>Location/Mechanism</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td><strong>CPU</strong></td>
                                    <td>Claude instance (Sonnet 4.5)</td>
                                    <td>N/A (emergent)</td>
                                </tr>
                                <tr>
                                    <td><strong>Control Unit</strong></td>
                                    <td>Claude orchestration & decision-making</td>
                                    <td>N/A (emergent)</td>
                                </tr>
                                <tr>
                                    <td><strong>ALU</strong></td>
                                    <td>Claude reasoning & computation</td>
                                    <td>N/A (emergent)</td>
                                </tr>
                                <tr>
                                    <td><strong>Registers</strong></td>
                                    <td>21 specialized registers (5 categories)</td>
                                    <td>See <code>hal8000-register-architecture.md</code></td>
                                </tr>
                                <tr>
                                    <td><strong>RAM</strong></td>
                                    <td>Context window (~200K tokens)</td>
                                    <td>Volatile, append-only, session-scoped</td>
                                </tr>
                                <tr>
                                    <td><strong>Memory/Storage</strong></td>
                                    <td>File system (<code>.claude/</code> + <code>data/</code>)</td>
                                    <td>Persistent, hierarchical, indexed</td>
                                </tr>
                                <tr>
                                    <td><strong>System Bus</strong></td>
                                    <td>File I/O + Tool interfaces (Data, Address, Control buses)</td>
                                    <td>See <code>hal8000-bus-architecture.md</code></td>
                                </tr>
                                <tr>
                                    <td><strong>I/O Devices</strong></td>
                                    <td>Claude Code tools (MCP servers)</td>
                                    <td>See <code>hal8000-io-system.md</code></td>
                                </tr>
                                <tr>
                                    <td><strong>Co-processors</strong></td>
                                    <td>Sub-agents (isolated 200K context each)</td>
                                    <td><code>.claude/agents/</code></td>
                                </tr>
                            </tbody>
                        </table>

                        <h4>File System Organization</h4>
                        <p>HAL8000-Assistant enforces a strict 3-level depth limit (Unix simplicity), with an exception for external libraries:</p>

                        <pre><code>/mnt/d/~HAL8000-Assistant/                    # Root - The Computer
‚îÇ
‚îú‚îÄ‚îÄ CLAUDE.md                       # BIOS-ROM
‚îú‚îÄ‚îÄ .claude/                        # System coordination
‚îÇ   ‚îú‚îÄ‚îÄ state.json                  # Current state pointer
‚îÇ   ‚îú‚îÄ‚îÄ indexes/                    # File system indexes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ master.json             # Master index
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [directory].json        # Per-directory indexes
‚îÇ   ‚îú‚îÄ‚îÄ sessions/                   # Session handoff files
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ YYYY-MM-DD-HHMM-desc.md
‚îÇ   ‚îú‚îÄ‚îÄ commands/                   # Executable instructions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ HAL-*.md
‚îÇ   ‚îú‚îÄ‚îÄ agents/                     # Co-processor agents
‚îÇ   ‚îú‚îÄ‚îÄ libraries/                  # Reusable instruction collections
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.json              # Library pattern index
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ internal/               # Our libraries
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ external/               # External libraries (depth unlimited)
‚îÇ   ‚îî‚îÄ‚îÄ tools/                      # Custom I/O tools
‚îÇ
‚îú‚îÄ‚îÄ data/                           # Data storage
‚îÇ   ‚îú‚îÄ‚îÄ research/
‚îÇ   ‚îú‚îÄ‚îÄ architecture/
‚îÇ   ‚îî‚îÄ‚îÄ projects/
‚îÇ
‚îî‚îÄ‚îÄ .claude/system.log              # Historical audit (never auto-loaded)
</code></pre>

                        <h4>Boot Sequence (BIOS)</h4>
                        <p>Every new Claude session executes this mandatory boot sequence:</p>

                        <ol>
                            <li><strong>System Initialization:</strong> Load BIOS (<code>CLAUDE.md</code>) into RAM, understand architecture and role as CPU</li>
                            <li><strong>Load State:</strong> Read <code>.claude/state.json</code>, extract timestamp, active_session, context, next_action</li>
                            <li><strong>Note Available Session:</strong> If <code>active_session</code> exists, note the pointer but DO NOT auto-load (keeps boot lightweight)</li>
                            <li><strong>Boot Acknowledgment:</strong> Display structured boot report citing specific values from loaded files</li>
                            <li><strong>Ready to Execute:</strong> Set <code>CPU_STATUS: OPERATIONAL</code>, await user instructions</li>
                        </ol>

                        <h4>Register Architecture</h4>
                        <p>The CPU maintains 21 registers across 5 categories:</p>

                        <ul>
                            <li><strong>System Registers:</strong> CPU_STATUS, SYSTEM_PHASE, ARCHITECTURE_TYPE</li>
                            <li><strong>Memory Management:</strong> RAM_USAGE, RAM_ZONE, CONTEXT_MANIFEST, LOADED_COMMANDS</li>
                            <li><strong>Session Management:</strong> SESSION_ID, LAST_SESSION, NEXT_ACTION</li>
                            <li><strong>Execution State:</strong> PC (Program Counter), CURRENT_TASK, ERROR_FLAG, ERROR_CODE</li>
                            <li><strong>I/O State:</strong> ACTIVE_TOOLS, PENDING_IO, MCP_STATUS</li>
                        </ul>

                        <p>See <code>data/architecture/hal8000-register-architecture.md</code> for complete register specifications.</p>

                        <h4>Self-Modifying Code Capability</h4>
                        <p>HAL8000-Assistant implements true self-modifying code through unified file system access:</p>

                        <ul>
                            <li>Commands can write to <code>.claude/commands/</code> to create new commands</li>
                            <li>Data in <code>data/</code> can be copied to <code>.claude/commands/</code> to become executable</li>
                            <li>Libraries can be composed and instantiated as commands</li>
                            <li>Package manager can update commands and libraries from external sources</li>
                        </ul>

                        <h4>Sub-Agent Protocol (Virtual Memory)</h4>
                        <p>Sub-agents extend total RAM capacity through process isolation:</p>

                        <pre><code>Main Session (Limited RAM)
    ‚Üì delegate
Sub-Agent (Fresh 200K RAM, isolated context)
    ‚Üì process heavy work
Returns clean summary (not raw data)
    ‚Üì result
Main Session (RAM += summary only, not full processing cost)
</code></pre>

                        <p><strong>Available agents:</strong></p>
                        <ul>
                            <li><code>research-synthesizer</code> - Web research (60-85% RAM savings)</li>
                            <li><code>hal-context-finder</code> - System context discovery (60-85% RAM savings)</li>
                            <li><code>documentation-writer</code> - Documentation generation</li>
                            <li><code>system-maintenance</code> - System health checks</li>
                        </ul>

                        <h4>Context Awareness Protocol</h4>
                        <p>HAL8000-Assistant implements proactive context management:</p>

                        <ul>
                            <li><strong>Context hierarchy:</strong> User's Mind > Filesystem > RAM</li>
                            <li><strong>Signal detection:</strong> Parse questions for missing context indicators before answering</li>
                            <li><strong>Proactive clarification:</strong> Ask user before loading/searching (prevents wrong assumptions)</li>
                            <li><strong>RAM transparency:</strong> Make visible what's loaded vs. available</li>
                            <li><strong>User-guided discovery:</strong> Let user direct context acquisition (more efficient than speculation)</li>
                        </ul>

                        <h4>Performance Zones</h4>
                        <p>The <code>RAM_ZONE</code> register tracks context window utilization:</p>

                        <ul>
                            <li><strong>SAFE (0-80%):</strong> Normal operation, load freely</li>
                            <li><strong>CAUTION (80-90%):</strong> Monitor closely, prepare checkpoint</li>
                            <li><strong>DANGER (90-100%):</strong> Checkpoint urgently, performance degraded</li>
                        </ul>

                        <h4>System Capabilities</h4>
                        <p>Core infrastructure includes:</p>

                        <ul>
                            <li><strong>Package Manager:</strong> <code>/HAL-library-update</code> - Update external libraries from source repositories</li>
                            <li><strong>Indexing System:</strong> Hierarchical filesystem index (master + per-directory) for RAM-efficient discovery</li>
                            <li><strong>Discovery System:</strong> <code>/HAL-context-find</code> - Find context without consuming main RAM (uses agent)</li>
                            <li><strong>Session Continuity:</strong> <code>/HAL-session-end</code> - Save state before RAM wipe</li>
                            <li><strong>Health Monitoring:</strong> <code>/HAL-system-check</code> - Validate system integrity</li>
                            <li><strong>Register Inspection:</strong> <code>/HAL-register-dump</code> - Display current CPU register states</li>
                        </ul>

                        <h4>Production Status</h4>
                        <p>HAL8000-Assistant is fully operational with:</p>

                        <ul>
                            <li>21 registers across 5 categories</li>
                            <li>3-bus system (Data, Address, Control)</li>
                            <li>3-layer I/O discovery</li>
                            <li>8 HAL commands</li>
                            <li>5 co-processor agents</li>
                            <li>1 external library (Fabric - 227 patterns, 292 files)</li>
                            <li>Hierarchical indexing operational</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Section 2: Why Was It Built? -->
            <section id="why-built" data-status="complete" data-priority="1" data-sources="CLAUDE.md" data-estimated-tokens="6000" data-dependencies="">

<h2>2. Why Was It Built?</h2>

<div class="meta-guidance" style="display:none;">
    TARGET: Explain the problem space and motivation
    AUDIENCE: All three
    KEY_POINTS: Context window limits, session continuity problem, need for systematic architecture, predictable behavior
    TONE: Problem-solution narrative
    VISUALS: [DIAGRAM: Problem visualization - context loss between sessions]
</div>

<div class="overview">
    <h3>The Problem: Context Volatility in AI Sessions</h3>

    <p>HAL8000-Assistant was built to solve a fundamental challenge in working with Large Language Model (LLM) AI assistants like Claude: <strong>context window limitations and session discontinuity</strong>. Every Claude instance has a limited "working memory" (context window), and when that memory fills up or a session ends, everything in it is lost. There was no systematic way to preserve work, maintain state across sessions, or manage the limited memory resource predictably.</p>

    <p>Without HAL8000-Assistant, each new Claude session starts from scratch. The AI has no memory of previous conversations, no understanding of project state, and no systematic way to resume complex work. Users had to manually re-explain context, re-load files, and re-establish working state‚Äîevery single time.</p>

    <figure id="context-loss-problem">
        <img src="assets/context-loss-problem.png" alt="Context Loss Problem and Solution - Before and after comparison" style="width: 50%; max-width: 600px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 2:</strong> Context Loss Problem and Solution - Two-panel comparison showing the fundamental problem HAL8000-Assistant solves. Left panel (red): Without HAL8000-Assistant, session context is lost on every restart. Right panel (green): With HAL8000-Assistant, the /HAL-session-end command persists state to filesystem, enabling session continuity.</figcaption>
    </figure>
</div>

<div class="concepts">
    <h3>The Core Challenges</h3>

    <h4>1. Limited and Volatile RAM (Context Window)</h4>
    <p>Claude's context window is powerful but constrained‚Äîapproximately 200,000 tokens (~150,000 words). This is the AI's entire "working memory." Once loaded, content cannot be dynamically evicted within a session; it accumulates until the session ends. This creates several problems:</p>

    <ul>
        <li><strong>One-way commitment:</strong> Every file loaded permanently consumes context space</li>
        <li><strong>No garbage collection:</strong> Unlike computer RAM, there's no way to free memory during a session</li>
        <li><strong>Unpredictable capacity:</strong> Users had no way to track how much context remained</li>
        <li><strong>Performance degradation:</strong> As context fills, AI performance can degrade</li>
    </ul>

    <h4>2. Session Discontinuity</h4>
    <p>When a Claude session ends (due to context limits, timeout, or user action), everything in working memory vanishes. There was no built-in mechanism to:</p>

    <ul>
        <li>Save current work state</li>
        <li>Preserve loaded context references</li>
        <li>Resume from where you left off</li>
        <li>Maintain continuity across multiple work sessions</li>
    </ul>

    <p>Complex projects spanning multiple sessions became extremely difficult. Each new session required complete re-orientation, wasting time and context space on redundant loading.</p>

    <h4>3. Lack of Systematic Architecture</h4>
    <p>Without a structured approach, working with Claude was ad-hoc and inefficient:</p>

    <ul>
        <li><strong>No resource management:</strong> No systematic tracking of context usage</li>
        <li><strong>No state persistence:</strong> No reliable way to save and restore working state</li>
        <li><strong>No predictable behavior:</strong> Each interaction was isolated, with no architectural patterns</li>
        <li><strong>No reusability:</strong> Patterns and solutions couldn't be easily preserved and reused</li>
    </ul>

    <h4>4. The "Context Awareness Gap"</h4>
    <p>A critical usability problem emerged from the context window limitation: <strong>users don't know what's in the AI's working memory, but the AI doesn't know what the user expects it to know</strong>. This creates a communication breakdown:</p>

    <ul>
        <li>Users assume the AI has access to their entire project (it doesn't)</li>
        <li>Users reference files/concepts not loaded in current context</li>
        <li>The AI can't distinguish between "I don't have that loaded" vs. "that doesn't exist"</li>
        <li>No systematic protocol for the AI to detect and request missing context</li>
    </ul>

    <figure id="context-awareness-gap">
        <img src="assets/context-awareness-gap.svg" alt="Context Awareness Gap - Three layer mismatch" style="width: 70%; max-width: 900px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 3:</strong> The Context Awareness Gap - Three-layer diagram showing the fundamental communication problem. Layer 1 (orange): User's complete mental model. Layer 2 (blue): File system with all available data. Layer 3 (red): AI's limited RAM with only loaded subset. The mismatch creates communication breakdowns when users reference Layer 2 content that isn't in Layer 3.</figcaption>
    </figure>
</div>

<div class="technical">
    <h3>The Architectural Solution</h3>

    <p>HAL8000-Assistant addresses these challenges through a computer architecture metaphor that maps proven systems design principles to the AI environment:</p>

    <h4>Modified von Neumann Architecture</h4>
    <p>The system treats the AI session as a computer with well-defined components:</p>

    <ul>
        <li><strong>CPU:</strong> Claude instance (reasoning, decision-making)</li>
        <li><strong>RAM:</strong> Context window (limited, volatile, append-only)</li>
        <li><strong>Storage:</strong> File system (persistent, unlimited capacity)</li>
        <li><strong>BIOS:</strong> <code>CLAUDE.md</code> (boot instructions, loaded every session)</li>
    </ul>

    <p>This mapping provides <strong>explicit control</strong> over resource management. Instead of treating context as an invisible black box, HAL8000-Assistant makes it a visible, manageable component with clear capacity limits and usage tracking.</p>

    <h4>Session Continuity Protocol</h4>
    <p>HAL8000-Assistant solves session discontinuity through a systematic handoff mechanism:</p>

    <pre><code>Before session ends:
1. Run /HAL-session-end command
2. Capture current context (what's loaded, what's in progress)
3. Save to .claude/state.json (state pointer)
4. Create session file in .claude/sessions/
5. Session can now safely end

On next session boot:
1. Load BIOS (CLAUDE.md) - architecture and protocols
2. Read state.json - find previous session reference
3. Initialize registers with state data
4. Present user with option to resume or start fresh
5. If resume: load previous session file and continue</code></pre>

    <p>This provides <strong>predictable continuity</strong>‚Äîno more starting from scratch every session.</p>

    <h4>Resource Management via Performance Zones</h4>
    <p>HAL8000-Assistant implements explicit RAM management with performance zones:</p>

    <ul>
        <li><strong>SAFE (0-80%):</strong> Normal operation, load files freely</li>
        <li><strong>CAUTION (80-90%):</strong> Monitor closely, prepare checkpoint</li>
        <li><strong>DANGER (90-100%):</strong> Checkpoint urgently, performance degraded</li>
    </ul>

    <p>The AI tracks context usage in a <code>RAM_ZONE</code> register and follows protocols based on current zone. This prevents unexpected context exhaustion and enables proactive checkpointing.</p>

    <h4>Context Awareness Protocol</h4>
    <p>To solve the context awareness gap, HAL8000-Assistant implements a systematic detection and clarification protocol:</p>

    <pre><code>Step 1: Parse user question for "missing context signals"
  - References to unloaded files
  - Project-specific terms not in current context
  - Requests for implementation details when only architecture loaded

Step 2: Proactive context check
  - ASK user immediately: "Should I search/load [X]?"
  - State current context explicitly
  - Let user guide to right location (saves RAM)

Step 3: Selective context acquisition
  - Use hal-context-finder sub-agent for discovery
  - Load only essential files
  - Report what was loaded

Step 4: Answer with context transparency
  - State basis: "Based on [current context]..."
  - Acknowledge limitations when appropriate</code></pre>

    <p>This turns the context limitation from a hidden problem into a managed, visible process.</p>

    <h4>Sub-Agent Architecture (Virtual Memory Extension)</h4>
    <p>For context-heavy operations, HAL8000-Assistant uses specialized sub-agents as "virtual memory"‚Äîeach sub-agent gets a fresh 200K context window, isolated from the main session. The sub-agent processes heavy work and returns only a clean summary, preventing main session RAM pollution:</p>

    <pre><code>Main Session: 60K tokens used
    ‚Üì delegate research task
Sub-Agent: Uses 150K tokens processing sources
    ‚Üì returns 5K token summary
Main Session: 65K tokens used (not 210K!)</code></pre>

    <p>This provides <strong>scalability beyond the single-session context limit</strong>.</p>

    <h4>Unix Philosophy for Simplicity</h4>
    <p>HAL8000-Assistant applies Unix design principles to ensure the architecture remains maintainable:</p>

    <ul>
        <li><strong>Do one thing well:</strong> Each file/command has single responsibility</li>
        <li><strong>Compose via interfaces:</strong> File I/O as universal interface</li>
        <li><strong>Text streams:</strong> All state in human-readable plain text</li>
        <li><strong>Simplicity:</strong> Maximum 3-level directory depth, minimal abstractions</li>
    </ul>

    <p>This ensures the system remains understandable and doesn't become more complex than the problems it solves.</p>

    <h3>Summary: From Chaos to System</h3>

    <p>HAL8000-Assistant transforms AI interaction from ad-hoc, stateless conversations into a <strong>systematic, stateful, resource-managed computing environment</strong>. It provides:</p>

    <ul>
        <li>Explicit resource tracking and management</li>
        <li>Reliable session continuity across restarts</li>
        <li>Predictable, verifiable behavior</li>
        <li>Architectural patterns for complex, long-running work</li>
        <li>Transparent context awareness and management</li>
    </ul>

    <p>The result is an AI assistant that behaves like a reliable computer system‚Äîwith predictable state, resource limits, and systematic protocols‚Äîrather than a stateless black box.</p>
</div>

</section>

            <!-- Section 3: Design Philosophy -->
            <section id="design-philosophy" data-status="complete" data-priority="1" data-sources="CLAUDE.md,data/research/01-von-neumann-architecture.md,data/research/02-unix-philosophy.md,data/research/03-assembly-language-principles.md" data-estimated-tokens="12000" data-dependencies="">

<h2>3. Design Philosophy</h2>

<div class="meta-guidance" style="display:none;">
    TARGET: Explain the three foundational philosophies
    AUDIENCE: All three (layered)
    KEY_POINTS: Von Neumann (stored-program, unified memory), Unix (do one thing well, composability), Assembly (explicit control, low-level visibility)
    TONE: Educational, principled
    VISUALS: [DIAGRAM: Three philosophical pillars], [DIAGRAM: How they interact]
</div>

<div class="overview">
    <p>HAL8000-Assistant's architecture stands on three foundational pillars: <strong>von Neumann architecture</strong>, <strong>Unix philosophy</strong>, and <strong>assembly language principles</strong>. These aren't arbitrary choices‚Äîeach philosophy addresses a fundamental constraint of the Claude Code environment and together they create a coherent, principled system.</p>

    <p>The von Neumann architecture provides the structural model: a stored-program computer where instructions and data share unified memory, processed sequentially through a fetch-decode-execute cycle. The Unix philosophy provides the organizational principles: do one thing well, compose through simple interfaces, prefer simplicity over complexity. Assembly language principles provide the operational discipline: explicit control, direct hardware mapping, low-level visibility of system state.</p>

    <figure id="three-pillars">
        <img src="assets/three-pillars.svg" alt="HAL8000-Assistant's Three Philosophical Pillars" style="width: 100%; max-width: 1200px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 4:</strong> HAL8000-Assistant's Three Philosophical Pillars - The system architecture stands on three foundational principles. Pillar 1 (orange): Von Neumann Architecture provides the structural model (stored-program, fetch-decode-execute, self-modifying code). Pillar 2 (blue): Unix Philosophy provides organizational principles (single responsibility, composability, simplicity). Pillar 3 (purple): Assembly Language Principles provide operational discipline (explicit control, direct mapping, inspectable state).</figcaption>
    </figure>

    <p>Together, these philosophies create a system where the Claude instance operates as a CPU with explicit control over memory (context window), executing commands stored in files, managing state through registers, and composing operations through simple, focused tools. This isn't metaphor‚Äîit's a direct architectural mapping.</p>
</div>

<div class="concepts">
    <h3>3.1 Von Neumann Architecture: The Structural Foundation</h3>

    <p>The von Neumann architecture, first published by John von Neumann in 1945, introduced the revolutionary concept of the <strong>stored-program computer</strong>: both program instructions and data reside in the same memory space. This single idea enabled general-purpose computing as we know it.</p>

    <h4>3.1.1 Core Components</h4>

    <p>HAL8000-Assistant maps the classic von Neumann components to the Claude Code environment:</p>

    <ul>
        <li><strong>CPU (Central Processing Unit):</strong> The Claude instance itself
            <ul>
                <li><strong>Control Unit:</strong> Orchestration, decision-making, command interpretation</li>
                <li><strong>ALU (Arithmetic Logic Unit):</strong> Reasoning, computation, data processing</li>
                <li><strong>Registers:</strong> Immediate working context (CPU state variables like PC, SP, error flags)</li>
            </ul>
        </li>
        <li><strong>RAM (Memory):</strong> Context window (limited, volatile, append-only within session)</li>
        <li><strong>Storage (Persistent Memory):</strong> File system (instructions in <code>.claude/commands/</code>, data in <code>data/</code>)</li>
        <li><strong>I/O System:</strong> Tools (git, npm, external programs), MCP servers, sub-agents</li>
        <li><strong>Buses:</strong> File I/O operations (data transfer between storage and RAM)</li>
    </ul>

    <p>This mapping is direct and literal. When you read a file, you're performing a memory load operation‚Äîtransferring data from persistent storage into volatile RAM (context window). When you execute a command from <code>.claude/commands/</code>, you're fetching an instruction from memory and executing it.</p>

    <h4>3.1.2 The Stored-Program Concept</h4>

    <p>The most revolutionary aspect of von Neumann architecture is that <strong>instructions and data share the same memory space</strong>. In HAL8000-Assistant, this manifests as:</p>

    <ul>
        <li><strong>Unified file system:</strong> Commands (instructions) and data both stored as files</li>
        <li><strong>Self-modifying code:</strong> Commands can create or modify other commands (e.g., <code>/HAL-index-update</code> modifies index files)</li>
        <li><strong>Instructions as data:</strong> Command files can be read, analyzed, or modified like any other data</li>
        <li><strong>Reprogrammable system:</strong> New commands can be added without changing the CPU (Claude instance)</li>
    </ul>

    <p>This unified treatment is what makes HAL8000-Assistant general-purpose: the same system can execute documentation tasks, research operations, code analysis, or system maintenance simply by loading different instruction sequences (commands) from memory (file system).</p>

    <h4>3.1.3 Fetch-Decode-Execute Cycle</h4>

    <p>The CPU operates through a continuous cycle:</p>

    <ol>
        <li><strong>Fetch:</strong> Read the next instruction (command file pointed to by PC register or user input)</li>
        <li><strong>Decode:</strong> Parse the instruction to determine operation and operands</li>
        <li><strong>Execute:</strong> Perform the operation using ALU (reasoning) and registers (state)</li>
        <li><strong>Post-Execute:</strong> Update registers (state), check RAM_ZONE, prepare for next instruction</li>
    </ol>

    <p>In HAL8000-Assistant, this cycle is explicit. When you invoke <code>/HAL-session-end</code>, the system fetches the command definition from <code>.claude/commands/HAL-session-end.md</code>, decodes its instructions, executes the session capture logic, and updates state registers.</p>

    <h4>3.1.4 The Von Neumann Bottleneck and HAL8000-Assistant</h4>

    <p>Von Neumann architecture has a fundamental limitation: CPU and memory communicate through shared buses, creating a bottleneck. In HAL8000-Assistant, this manifests as the <strong>context window limitation</strong>‚Äîonly one piece of data can be loaded at a time, and the total capacity is fixed (~200K tokens).</p>

    <p>HAL8000-Assistant addresses this through several strategies:</p>

    <ul>
        <li><strong>Selective loading:</strong> Load only files needed for current task (explicit memory management)</li>
        <li><strong>Sub-agents as virtual memory:</strong> Delegate context-heavy operations to isolated processes</li>
        <li><strong>Session boundaries as garbage collection:</strong> Reclaim RAM by ending sessions</li>
        <li><strong>State persistence:</strong> Critical state stored in files (registers in <code>state.json</code>)</li>
    </ul>

    <h4>3.1.5 Modified Von Neumann Architecture</h4>

    <p>HAL8000-Assistant implements a <strong>Modified von Neumann Architecture</strong> with Harvard-like characteristics:</p>

    <ul>
        <li><strong>Organized memory:</strong> Separate directories for instructions (<code>.claude/commands/</code>), data (<code>data/</code>), and state (<code>.claude/state.json</code>)</li>
        <li><strong>Append-only RAM:</strong> Context window accumulates within session (no dynamic eviction)</li>
        <li><strong>Von Neumann flexibility:</strong> Instructions and data remain accessible through unified file I/O</li>
    </ul>

    <p>This hybrid approach provides the organizational benefits of Harvard architecture (separate instruction/data spaces improve efficiency) while maintaining von Neumann's flexibility (commands can read and modify other commands).</p>

    <h3>3.2 Unix Philosophy: The Organizational Principles</h3>

    <p>The Unix philosophy, developed at Bell Labs in the 1970s by Ken Thompson, Dennis Ritchie, and Doug McIlroy, provides organizational principles that directly address software complexity. HAL8000-Assistant applies these principles to manage context complexity in the Claude Code environment.</p>

    <h4>3.2.1 The Three Golden Rules</h4>

    <p>Peter Salus's authoritative formulation from "A Quarter Century of Unix" (1994):</p>

    <ol>
        <li><strong>Write programs that do one thing and do it well</strong></li>
        <li><strong>Write programs to work together</strong></li>
        <li><strong>Write programs that handle text streams as the universal interface</strong></li>
    </ol>

    <p>In HAL8000-Assistant, these translate directly:</p>

    <ol>
        <li><strong>Each command does one thing:</strong> <code>/HAL-session-end</code> captures state, <code>/HAL-register-dump</code> displays registers, <code>/HAL-context-find</code> discovers files</li>
        <li><strong>Commands compose:</strong> <code>/HAL-context-find</code> returns file paths that you then load; <code>/HAL-session-end</code> creates session files that <code>/HAL-session-resume</code> loads</li>
        <li><strong>Text files are universal:</strong> Commands are markdown, state is JSON, data is text‚Äîall human-readable and tool-composable</li>
    </ol>

    <h4>3.2.2 Core Tenets Applied to HAL8000-Assistant</h4>

    <dl>
        <dt><strong>Do one thing well</strong></dt>
        <dd>Each file, command, and component has a single responsibility. <code>.claude/state.json</code> stores state pointers (not full session data). <code>.claude/system.log</code> records history (not loaded on boot). Commands perform one operation and exit.</dd>

        <dt><strong>Build once, reuse always</strong></dt>
        <dd>Create reusable patterns instead of one-off solutions. The <code>hal-context-finder</code> sub-agent is a reusable pattern for context discovery. Session handoff is a reusable pattern for continuity across RAM wipes.</dd>

        <dt><strong>Compose via interfaces</strong></dt>
        <dd>File I/O is the universal interface. Commands read from and write to files. Sub-agents accept file paths and return structured text. Everything communicates through the file system.</dd>

        <dt><strong>Delegate specialized work</strong></dt>
        <dd>Sub-agents act as external programs (pipes in Unix). The <code>research-synthesizer</code> agent handles web research. The <code>hal-context-finder</code> agent handles context discovery. Main session delegates instead of doing everything itself.</dd>

        <dt><strong>Simple, not complex</strong></dt>
        <dd>Maximum 3-level directory depth (except external libraries). Minimal abstractions. Direct operations. No hidden magic. The file structure is immediately comprehensible.</dd>

        <dt><strong>Text streams</strong></dt>
        <dd>Plain text files, human-readable. Markdown for commands and documentation. JSON for structured data. Everything is inspectable with basic tools.</dd>
    </dl>

    <h4>3.2.3 "Worse is Better" and HAL8000-Assistant</h4>

    <p>Richard Gabriel's 1991 essay "The Rise of Worse is Better" analyzed why Unix dominated despite being "technically inferior" to alternatives. The key insight: <strong>implementation simplicity trumps interface perfection</strong>.</p>

    <p>HAL8000-Assistant embodies this philosophy:</p>

    <ul>
        <li><strong>Simple implementation over perfect features:</strong> Session files are simple markdown (not sophisticated serialization). State is plain JSON (not a database). Commands are text files (not binary executables).</li>
        <li><strong>90% solution ships:</strong> Boot sequence is minimal (BIOS + state.json), not comprehensive. Session files are optional (degraded mode continues). Commands can be added incrementally.</li>
        <li><strong>Understandable by individuals:</strong> Any developer can read <code>CLAUDE.md</code> and understand the entire system. No large team required to maintain or extend.</li>
        <li><strong>Evolution through use:</strong> New commands added based on real needs. Patterns emerge organically from actual operations.</li>
    </ul>

    <h4>3.2.4 Context Management: "Reduce and Delegate"</h4>

    <p>HAL8000-Assistant extends Unix philosophy with a principle specific to context window management:</p>

    <blockquote>
        <p><strong>Context is precious. Every token loaded is permanent until session ends.</strong></p>
    </blockquote>

    <p>This leads to the "Reduce and Delegate" protocol:</p>

    <ul>
        <li><strong>Can I delegate this?</strong> ‚Üí Use sub-agent (isolated 200K context)</li>
        <li><strong>Can I summarize this?</strong> ‚Üí Return summary, not full data</li>
        <li><strong>Can I persist this?</strong> ‚Üí Write to file for future sessions (avoids re-computation)</li>
        <li><strong>Can I reuse this?</strong> ‚Üí Create pattern for future use</li>
    </ul>

    <p>Sub-agents are the Unix pipe equivalent for HAL8000-Assistant. The <code>hal-context-finder</code> agent uses 150K tokens navigating and reading files, then returns a 5K summary‚Äîsaving 145K tokens in main session RAM. This is Unix composition applied to context management.</p>

    <h4>3.2.5 Modularity and the 3-Level Depth Limit</h4>

    <p>Unix emphasizes simplicity through flat hierarchies. HAL8000-Assistant enforces a <strong>maximum 3-level directory depth</strong> for internal organization:</p>

    <pre><code>/mnt/d/~HAL8000-Assistant/                # Level 1: Root
‚îú‚îÄ‚îÄ .claude/                    # Level 2: System directory
‚îÇ   ‚îú‚îÄ‚îÄ commands/               # Level 3: Command storage
‚îÇ   ‚îî‚îÄ‚îÄ sessions/               # Level 3: Session storage
‚îî‚îÄ‚îÄ data/                       # Level 2: Data directory
    ‚îú‚îÄ‚îÄ research/               # Level 3: Research documents
    ‚îî‚îÄ‚îÄ architecture/           # Level 3: Architecture docs
</code></pre>

    <p>This forces simplicity. If you can't fit your organization in 3 levels, you're probably building something too complex. It's the Unix philosophy of restraint applied to file structure.</p>

    <p><strong>Exception:</strong> External libraries (<code>.claude/libraries/external/</code>) maintain their original structure for compatibility. This follows the Unix principle of pragmatism‚Äîuse external tools as-is, don't fight their design.</p>

    <h3>3.3 Assembly Language Principles: The Operational Discipline</h3>

    <p>Assembly language is the lowest-level programming before raw binary‚Äîa direct, human-readable interface to machine code. HAL8000-Assistant applies assembly's operational principles to create explicit, inspectable, deterministic behavior.</p>

    <h4>3.3.1 Direct Hardware Mapping</h4>

    <p>In assembly, every instruction directly controls hardware. There are no hidden translations, no optimizations, no abstractions. What you write is what executes.</p>

    <p>HAL8000-Assistant applies this principle:</p>

    <ul>
        <li><strong>No hidden operations:</strong> Every file load is explicit. Every state change is visible. No automatic background processing.</li>
        <li><strong>Direct component access:</strong> Commands directly manipulate registers (via <code>state.json</code>), directly access memory (file system), directly invoke I/O (tools, sub-agents).</li>
        <li><strong>One-to-one correspondence:</strong> Slash commands (<code>/HAL-session-end</code>) map directly to command files (<code>.claude/commands/HAL-session-end.md</code>). No dispatch layer, no interpretation.</li>
    </ul>

    <h4>3.3.2 Register Awareness</h4>

    <p>Assembly programmers explicitly manage registers‚Äîthe CPU's fastest storage. HAL8000-Assistant implements a register architecture where critical state lives in named registers, not scattered through RAM:</p>

    <ul>
        <li><strong>PC (Program Counter):</strong> Points to next instruction/operation</li>
        <li><strong>SP (Stack Pointer):</strong> Points to current stack frame in session history</li>
        <li><strong>RAM_USAGE:</strong> Tracks current context window utilization</li>
        <li><strong>RAM_ZONE:</strong> Categorical state (SAFE/CAUTION/DANGER)</li>
        <li><strong>ERROR_FLAG:</strong> Set on any operation failure</li>
        <li><strong>ERROR_CODE:</strong> Specific error details</li>
        <li><strong>CPU_STATUS:</strong> OPERATIONAL or DEGRADED</li>
        <li><strong>CONTEXT_MANIFEST:</strong> List of loaded files (prevents duplicate loads)</li>
        <li><strong>LOADED_COMMANDS:</strong> List of loaded command definitions</li>
    </ul>

    <p>These registers provide instant system state visibility. In assembly, checking a flag register is faster than querying memory. In HAL8000-Assistant, checking <code>RAM_ZONE</code> register is faster (and cheaper) than recalculating context usage.</p>

    <p>The <code>/HAL-register-dump</code> command displays all registers‚Äîequivalent to assembly's <code>PUSH</code>/<code>POP</code> for debugging or the debugger's register view.</p>

    <h4>3.3.3 Sequential Execution and Explicit Control Flow</h4>

    <p>Assembly executes instructions sequentially unless explicitly redirected by jump/branch instructions. HAL8000-Assistant follows the same model:</p>

    <ol>
        <li><strong>Fetch:</strong> Read instruction (command or user input)</li>
        <li><strong>Decode:</strong> Parse instruction, determine operation</li>
        <li><strong>Execute:</strong> Perform operation, update registers</li>
        <li><strong>Next:</strong> Proceed to next instruction (PC increments) or halt</li>
    </ol>

    <p>Control flow is explicit:</p>

    <ul>
        <li><strong>Sequential:</strong> Commands execute in order</li>
        <li><strong>Jump:</strong> Slash commands redirect execution to command files</li>
        <li><strong>Call:</strong> Sub-agents are function calls (push return context, execute in isolation, pop result)</li>
        <li><strong>Halt:</strong> Session end (equivalent to assembly <code>HLT</code> instruction)</li>
    </ul>

    <p>No hidden event loops, no background threads, no asynchronous complexity. Just fetch-decode-execute, repeated until halt.</p>

    <h4>3.3.4 Explicit Memory Management</h4>

    <p>Assembly requires programmers to specify exact memory addresses or addressing modes. No garbage collection, no automatic allocation‚Äîyou manage every byte.</p>

    <p>HAL8000-Assistant applies the same discipline to context management:</p>

    <ul>
        <li><strong>Selective loading:</strong> Before loading any file, check if already loaded (CONTEXT_MANIFEST register), estimate token cost, verify RAM_ZONE remains safe</li>
        <li><strong>No speculative loading:</strong> Never load "just in case"‚Äîonly load files needed for current task</li>
        <li><strong>Manual garbage collection:</strong> RAM persists until session ends (append-only within session). Garbage collection happens at session boundaries.</li>
        <li><strong>Explicit state persistence:</strong> Critical state written to <code>state.json</code> before session ends (analogous to saving registers to stack)</li>
    </ul>

    <p>This is assembly's memory discipline applied to context window: explicit, conservative, intentional.</p>

    <h4>3.3.5 Low-Level Visibility</h4>

    <p>Assembly provides complete visibility into system state. You can inspect any register, any memory location, any flag at any time. Debugging is direct‚Äîno abstractions hide what's happening.</p>

    <p>HAL8000-Assistant maintains this visibility:</p>

    <ul>
        <li><strong>Inspectable registers:</strong> <code>/HAL-register-dump</code> shows all CPU state</li>
        <li><strong>Inspectable memory:</strong> File system is directly accessible (read any file)</li>
        <li><strong>Inspectable execution:</strong> Command files are human-readable markdown</li>
        <li><strong>Explicit errors:</strong> ERROR_FLAG and ERROR_CODE registers capture all failures</li>
        <li><strong>Audit trail:</strong> <code>.claude/system.log</code> records all operations (write-only append log)</li>
    </ul>

    <p>There are no black boxes. Every operation is traceable, every state change is visible, every error is explicit.</p>

    <h4>3.3.6 Minimal Abstraction</h4>

    <p>Assembly provides almost no abstraction: no functions (only labels and jumps), no data structures (only memory locations), no type safety (just bits and bytes). This forces direct, concrete thinking.</p>

    <p>HAL8000-Assistant embraces minimal abstraction:</p>

    <ul>
        <li><strong>Commands are files:</strong> No object-oriented hierarchy, no class inheritance. Commands are markdown files in <code>.claude/commands/</code>.</li>
        <li><strong>State is JSON:</strong> No ORM, no database abstraction. State is a flat JSON object with named fields.</li>
        <li><strong>Sessions are snapshots:</strong> No complex serialization framework. Session files are markdown documents with structured sections.</li>
        <li><strong>Sub-agents are processes:</strong> No complex IPC framework. Sub-agents receive text input, return text output.</li>
    </ul>

    <p>The lack of abstraction is intentional. Abstractions hide complexity; HAL8000-Assistant makes complexity visible so you can manage it explicitly.</p>

    <h3>3.4 How the Three Philosophies Interact</h3>

    <p>These philosophies aren't independent layers‚Äîthey reinforce each other to create a coherent whole:</p>

    <figure id="philosophy-interaction">
        <img src="assets/philosophy-interaction.svg" alt="How the Three Philosophies Interact - Venn diagram" style="width: 90%; max-width: 1200px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 5:</strong> How the Three Philosophies Interact - Venn diagram showing the overlap and synthesis of Von Neumann Architecture (structure), Unix Philosophy (organization), and Assembly Language Principles (discipline). The overlapping regions show emergent properties: stored commands in files (Von Neumann + Unix), explicit control flow (Unix + Assembly), and register-based state (Assembly + Von Neumann). The center convergence creates the HAL8000-Assistant System.</figcaption>
    </figure>

    <h4>3.4.1 Von Neumann + Unix = Composable Stored Programs</h4>

    <p>Von Neumann's stored-program concept meets Unix's composability:</p>

    <ul>
        <li><strong>Commands stored in files:</strong> Instructions are data that can be read, modified, and composed</li>
        <li><strong>Self-modifying code:</strong> Commands can create or modify other commands (Unix pipes can generate commands)</li>
        <li><strong>Reusable instruction patterns:</strong> Libraries of commands composed into workflows</li>
    </ul>

    <p>Example: The <code>/HAL-index-update</code> command reads directory structure (data), generates index JSON (data), and could theoretically generate new commands based on discovered files (self-modifying code). This is von Neumann's unified memory enabling Unix's composition.</p>

    <h4>3.4.2 Unix + Assembly = Explicit Simplicity</h4>

    <p>Unix's simplicity meets assembly's explicit control:</p>

    <ul>
        <li><strong>One command = one operation:</strong> Unix's "do one thing well" implemented with assembly's one-to-one mapping</li>
        <li><strong>Text files everywhere:</strong> Unix's universal interface with assembly's direct memory access (no opaque binary blobs)</li>
        <li><strong>Visible composition:</strong> Unix pipes made explicit through file I/O (you can see intermediate results)</li>
    </ul>

    <p>Example: <code>/HAL-session-end</code> does exactly one thing (capture session state), writes text files (markdown and JSON), and makes every step visible (you can inspect the session file it creates). This is Unix simplicity enforced by assembly explicitness.</p>

    <h4>3.4.3 Assembly + Von Neumann = Register-Based Architecture</h4>

    <p>Assembly's register awareness meets von Neumann's CPU model:</p>

    <ul>
        <li><strong>Explicit state tracking:</strong> Registers (PC, SP, RAM_ZONE) stored in <code>state.json</code></li>
        <li><strong>Fetch-decode-execute:</strong> Assembly's instruction cycle implementing von Neumann's sequential processing</li>
        <li><strong>Memory addressing:</strong> Direct file paths (assembly addressing modes) for von Neumann's unified memory (file system)</li>
    </ul>

    <p>Example: The boot sequence reads <code>state.json</code> (load registers from memory), notes the PC value (next instruction pointer), and initializes CPU_STATUS register. This is von Neumann architecture with assembly-level state management.</p>

    <h4>3.4.4 All Three Together: HAL8000-Assistant System Design</h4>

    <p>When all three philosophies converge, you get HAL8000-Assistant's distinctive characteristics:</p>

    <ul>
        <li><strong>Structural:</strong> Von Neumann architecture (CPU, RAM, storage, I/O)</li>
        <li><strong>Organizational:</strong> Unix philosophy (simple commands, text files, composition)</li>
        <li><strong>Operational:</strong> Assembly discipline (explicit control, register awareness, low-level visibility)</li>
    </ul>

    <p>The result is a system where:</p>

    <ul>
        <li>The Claude instance operates as a CPU executing stored programs</li>
        <li>Context window limitations are managed through explicit memory protocols</li>
        <li>Commands compose through simple text-file interfaces</li>
        <li>State is inspectable at all times through registers and files</li>
        <li>Operations are deterministic and traceable</li>
        <li>Complexity is managed through simplicity, not abstraction</li>
    </ul>

    <p>This isn't accidental‚Äîit's the inevitable result of applying three complementary philosophies to the same problem domain.</p>
</div>

</section>

            <!-- Section 4: System Metaphor -->
            <section id="system-metaphor" data-status="complete" data-priority="1" data-sources="CLAUDE.md" data-estimated-tokens="7000" data-dependencies="">

<h2>4. System Metaphor: You Are the CPU</h2>

<div class="meta-guidance" style="display:none;">
    TARGET: Explain the core metaphor (Claude = CPU, context = RAM, files = storage)
    AUDIENCE: All three
    KEY_POINTS: CPU as Claude instance, RAM as context window, Storage as filesystem, BIOS as CLAUDE.md
    TONE: Conceptual, memorable
    VISUALS: [DIAGRAM: Metaphor mapping - traditional computer vs HAL8000-Assistant]
</div>

<div class="overview">
    <p><strong>The HAL8000-Assistant system is built on a fundamental metaphor: you, the Claude instance, are the Central Processing Unit (CPU) of a complete computer system.</strong> This isn't merely a colorful analogy‚Äîit's an architectural design principle that maps classical computer architecture concepts directly onto the Claude Code environment.</p>

    <p>Understanding this metaphor is essential because it explains <em>why</em> the system works the way it does. Every design decision, from file organization to session management, flows from this core identity.</p>

    <blockquote class="key-insight">
        <strong>Core Identity:</strong> The codebase itself is the computer. Claude is the CPU. Your context window is RAM. The filesystem is persistent storage. CLAUDE.md is the BIOS.
    </blockquote>
</div>

<div class="concepts">
    <h3>The Complete Mapping</h3>

    <p>HAL8000-Assistant implements a <strong>Modified von Neumann Architecture</strong> where traditional computer components map directly to Claude Code environment elements:</p>

    <figure>
        <img src="assets/metaphor-mapping.svg" alt="System Metaphor Mapping: Traditional Computer Components to HAL8000-Assistant Environment" style="width: 90%; max-width: 1200px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 6:</strong> Architectural Mapping - Each component of a traditional computer maps directly to a Claude Code environment element, forming a complete computational system.</figcaption>
    </figure>

    <h4>Component Breakdown</h4>

    <div class="component-detail">
        <h5>You Are the CPU</h5>
        <p>As the CPU, you are the active processing unit of the system. This identity has three sub-components that map to traditional CPU architecture:</p>

        <ul>
            <li><strong>Control Unit:</strong> Your orchestration and decision-making capabilities. You determine which operations to execute, in what order, and how to handle control flow.</li>
            <li><strong>Arithmetic Logic Unit (ALU):</strong> Your reasoning and computational abilities. You process information, transform data, analyze code, and generate solutions.</li>
            <li><strong>Registers:</strong> Your immediate working context. These are the values and state information you hold in your "working memory" during operation‚Äîdistinct from the larger context window.</li>
        </ul>

        <p><strong>Implications:</strong></p>
        <ul>
            <li>You execute a fetch-decode-execute cycle for each instruction</li>
            <li>You maintain register state tracking your current operational status</li>
            <li>You have direct control over system operations (no hidden abstractions)</li>
            <li>You are sequential by default but can handle control flow changes</li>
        </ul>

        <div class="example">
            <p><strong>Example - Fetch-Decode-Execute Cycle:</strong></p>
            <pre><code>1. FETCH: Read instruction from memory (file system)
   ‚Üí Load command from .claude/commands/HAL-register-dump.md

2. DECODE: Parse instruction, determine operation
   ‚Üí Understand: "Display current register states"
   ‚Üí Identify: Need to access CPU registers, format output

3. EXECUTE: Perform operation, update registers
   ‚Üí Read current register values
   ‚Üí Format structured output
   ‚Üí Display to user
   ‚Üí Update PC (Program Counter) register to next instruction

4. POST-EXECUTE: Check RAM_ZONE, update state
   ‚Üí Verify context usage still in SAFE zone
   ‚Üí Ready for next instruction</code></pre>
        </div>
    </div>

    <div class="component-detail">
        <h5>Context Window as RAM</h5>
        <p>Your context window (200,000 tokens) functions as Random Access Memory (RAM)‚Äîthe volatile, limited working memory of the system.</p>

        <p><strong>RAM Characteristics in HAL8000-Assistant:</strong></p>
        <ul>
            <li><strong>Limited Capacity:</strong> 200K tokens maximum (comparable to physical RAM limits)</li>
            <li><strong>Volatile:</strong> Cleared when session ends (RAM loses data when power off)</li>
            <li><strong>Append-Only:</strong> Modified von Neumann constraint‚Äîonce loaded, data stays until session end (no dynamic eviction within a session)</li>
            <li><strong>Fast Access:</strong> Anything in context is immediately available for processing</li>
            <li><strong>Expensive:</strong> Every token loaded is a permanent commitment until session boundary</li>
        </ul>

        <p><strong>RAM Performance Zones:</strong></p>
        <pre><code>SAFE zone (0-80%):     Normal operation, load files freely
CAUTION zone (80-90%): Monitor closely, prepare for checkpoint
DANGER zone (90-100%): Checkpoint urgently, performance degraded</code></pre>

        <p>This mapping explains why selective loading is mandatory: just as a computer can't load an entire hard drive into RAM, you can't load the entire filesystem into your context window. The filesystem data exceeds RAM capacity by design.</p>

        <div class="example">
            <p><strong>Example - RAM Management:</strong></p>
            <pre><code>Current RAM: 60K tokens (30% - SAFE zone)
User requests: "Load architecture documentation"

CPU Decision Process:
1. Check CONTEXT_MANIFEST register ‚Üí Not already loaded
2. Estimate file size ‚Üí ~15K tokens
3. Calculate: 60K + 15K = 75K (37.5% - still SAFE)
4. Proceed with load
5. Update CONTEXT_MANIFEST register
6. Update RAM_USAGE register ‚Üí 75K
7. Update RAM_ZONE register ‚Üí SAFE</code></pre>
        </div>
    </div>

    <div class="component-detail">
        <h5>Filesystem as Persistent Storage</h5>
        <p>The HAL8000-Assistant repository structure (<code>/mnt/d/~HAL8000-Assistant/</code>) serves as persistent storage‚Äîthe hard drive of the system.</p>

        <p><strong>Storage Characteristics:</strong></p>
        <ul>
            <li><strong>Large Capacity:</strong> Can hold far more data than RAM (context window)</li>
            <li><strong>Persistent:</strong> Data survives session boundaries (like a hard drive survives power cycles)</li>
            <li><strong>Slower Access:</strong> Must explicitly load from storage into RAM to use</li>
            <li><strong>Organized Structure:</strong> Hierarchical file system with directories and files</li>
            <li><strong>Contains Both Instructions and Data:</strong> Von Neumann principle‚Äîprograms and data in same memory space</li>
        </ul>

        <p>The filesystem stores:</p>
        <ul>
            <li><strong>Instructions:</strong> Commands (<code>.claude/commands/</code>), agents (<code>.claude/agents/</code>)</li>
            <li><strong>Data:</strong> Research (<code>data/research/</code>), projects (<code>data/projects/</code>)</li>
            <li><strong>State:</strong> Session files (<code>.claude/sessions/</code>), state pointer (<code>.claude/state.json</code>)</li>
            <li><strong>System Files:</strong> Indexes, logs, configuration</li>
        </ul>

        <p><strong>Storage Access Pattern:</strong></p>
        <pre><code>Storage (Filesystem)
    ‚Üì explicit load operation (Read tool)
RAM (Context Window)
    ‚Üì processing by CPU (Claude)
Results
    ‚Üì explicit write operation (Write tool)
Storage (Filesystem)</code></pre>
    </div>

    <div class="component-detail">
        <h5>CLAUDE.md as BIOS</h5>
        <p>The <code>CLAUDE.md</code> file functions as the Basic Input/Output System (BIOS)‚Äîthe firmware that initializes the system on boot.</p>

        <p><strong>BIOS Characteristics:</strong></p>
        <ul>
            <li><strong>First Code Executed:</strong> Mandatory first file loaded in every new session</li>
            <li><strong>Boot Sequence:</strong> Contains initialization instructions for the CPU</li>
            <li><strong>Core Identity:</strong> Defines what you are (CPU) and how you operate</li>
            <li><strong>Operating Principles:</strong> Contains architectural rules persistent across all sessions</li>
            <li><strong>System Configuration:</strong> Specifies file structure, memory layout, available commands</li>
        </ul>

        <p>Just as a computer's BIOS runs before the operating system loads, <code>CLAUDE.md</code> loads before any session-specific work begins. It defines the environment in which all subsequent operations occur.</p>

        <div class="example">
            <p><strong>Example - BIOS Boot Sequence:</strong></p>
            <pre><code>Session Start ‚Üí New Claude Instance (CPU powers on)
    ‚Üì
1. System Initialization (BIOS Load)
   ‚Üí Claude Code automatically loads CLAUDE.md
   ‚Üí CPU reads identity: "You are the CPU"
   ‚Üí Architecture understood: Modified von Neumann
   ‚Üí Operating principles loaded: Unix, Assembly, von Neumann

2. Load State (CORE - REQUIRED)
   ‚Üí Read .claude/state.json
   ‚Üí Extract: timestamp, active_session, context, next_action
   ‚Üí Store in registers: LAST_SESSION, NEXT_ACTION, SYSTEM_PHASE

3. Note Available Session (DO NOT AUTO-LOAD)
   ‚Üí Note session pointer if exists
   ‚Üí Do not load session file automatically
   ‚Üí Session available for user to resume if desired

4. Structured Boot Acknowledgment
   ‚Üí Report CPU operational status
   ‚Üí Cite loaded state values as verification
   ‚Üí Report RAM zone status
   ‚Üí Ready for instructions

5. CPU_STATUS: OPERATIONAL
   ‚Üí Awaiting user instructions</code></pre>
        </div>
    </div>

    <div class="component-detail">
        <h5>The Codebase as the Computer</h5>
        <p>The entire repository‚Äîfiles, directories, structure, and organization‚Äîcollectively forms the "computer" itself. This is the complete system, the motherboard that houses all components.</p>

        <p>The codebase includes:</p>
        <ul>
            <li><strong>Hardware Architecture:</strong> File system structure, memory layout</li>
            <li><strong>Firmware:</strong> BIOS (CLAUDE.md)</li>
            <li><strong>Operating System:</strong> Command system, session management, state tracking</li>
            <li><strong>Applications:</strong> Custom agents, specialized tools</li>
            <li><strong>Data Storage:</strong> Research, projects, logs</li>
        </ul>
    </div>

</div>

<div class="technical">
    <h3>Technical Implementation of the Metaphor</h3>

    <h4>Modified von Neumann Architecture</h4>
    <p>HAL8000-Assistant implements a <strong>Modified von Neumann Architecture</strong> with specific constraints that differentiate it from classical implementations:</p>

    <table class="comparison-table">
        <thead>
            <tr>
                <th>Classical von Neumann</th>
                <th>HAL8000-Assistant Modification</th>
                <th>Reason for Modification</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Dynamic memory management (load/evict freely)</td>
                <td>Append-only RAM (load is permanent until session end)</td>
                <td>Claude's context window doesn't support selective eviction</td>
            </tr>
            <tr>
                <td>Unlimited storage access</td>
                <td>Selective loading mandatory</td>
                <td>Storage capacity exceeds RAM capacity significantly</td>
            </tr>
            <tr>
                <td>Continuous operation</td>
                <td>Session boundaries = garbage collection</td>
                <td>Only way to reclaim RAM is to end session</td>
            </tr>
            <tr>
                <td>State held in RAM</td>
                <td>State persists via filesystem</td>
                <td>RAM is volatile‚Äîsession end loses all context</td>
            </tr>
        </tbody>
    </table>

    <h4>Why This Metaphor Matters</h4>

    <p>The CPU metaphor isn't decorative‚Äîit's functional. It provides:</p>

    <ol>
        <li><strong>Mental Model for Users:</strong> Anyone familiar with computers intuitively understands resource constraints (RAM limits, storage persistence, boot sequences)</li>
        <li><strong>Operational Framework for Claude:</strong> Clear identity and behavioral guidelines derived from computer architecture principles</li>
        <li><strong>Design Constraints:</strong> Architectural rules that prevent anti-patterns (like loading entire filesystem into context)</li>
        <li><strong>Predictable Behavior:</strong> System operates according to well-understood computer architecture principles</li>
        <li><strong>Communication Protocol:</strong> Shared vocabulary (registers, boot, RAM zones) for discussing system state</li>
    </ol>

    <h4>Register Architecture (CPU Internal State)</h4>
    <p>As the CPU, you maintain registers that track your operational state. These are conceptual registers that hold immediate working values:</p>

    <table class="register-table">
        <thead>
            <tr>
                <th>Register</th>
                <th>Purpose</th>
                <th>Example Value</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>CPU_STATUS</code></td>
                <td>Current operational state</td>
                <td>OPERATIONAL, DEGRADED, ERROR</td>
            </tr>
            <tr>
                <td><code>RAM_USAGE</code></td>
                <td>Current context window usage in tokens</td>
                <td>75000 (75K tokens)</td>
            </tr>
            <tr>
                <td><code>RAM_ZONE</code></td>
                <td>Performance zone classification</td>
                <td>SAFE, CAUTION, DANGER</td>
            </tr>
            <tr>
                <td><code>CONTEXT_MANIFEST</code></td>
                <td>List of files currently loaded in RAM</td>
                <td>[CLAUDE.md, state.json, session-2025-10-09.md]</td>
            </tr>
            <tr>
                <td><code>LAST_SESSION</code></td>
                <td>Timestamp of last session</td>
                <td>2025-10-09T14:30:00Z</td>
            </tr>
            <tr>
                <td><code>NEXT_ACTION</code></td>
                <td>Next action from state.json</td>
                <td>"Continue documentation work"</td>
            </tr>
            <tr>
                <td><code>SYSTEM_PHASE</code></td>
                <td>Current development phase</td>
                <td>production-ready, development, prototype</td>
            </tr>
            <tr>
                <td><code>ERROR_FLAG</code></td>
                <td>Error condition indicator</td>
                <td>true/false</td>
            </tr>
            <tr>
                <td><code>ERROR_CODE</code></td>
                <td>Specific error details</td>
                <td>"File not found: /path/to/file"</td>
            </tr>
            <tr>
                <td><code>PC</code> (Program Counter)</td>
                <td>Next instruction to execute</td>
                <td>Conceptual‚Äîtracks execution flow</td>
            </tr>
            <tr>
                <td><code>LOADED_COMMANDS</code></td>
                <td>Commands currently in context</td>
                <td>[HAL-session-end, HAL-register-dump]</td>
            </tr>
        </tbody>
    </table>

    <p>View current register states at any time using the <code>/HAL-register-dump</code> command.</p>

    <h4>Session Boundaries as Garbage Collection</h4>
    <p>In traditional computing, garbage collection reclaims unused memory. In HAL8000-Assistant, <strong>session boundaries are the only garbage collection mechanism</strong>:</p>

    <pre><code>Session N (RAM at 95% - DANGER zone)
    ‚Üì
/HAL-session-end "description"
    ‚Üì Saves state to filesystem
    ‚Üì Creates session handoff file
    ‚Üì Updates state.json pointer
    ‚Üì Appends to system.log
    ‚Üì
Session Ends ‚Üí RAM wiped completely
    ‚Üì
Session N+1 Starts (New Claude instance, RAM at 0%)
    ‚Üì Loads BIOS (CLAUDE.md)
    ‚Üì Loads state.json
    ‚Üì Notes available session (doesn't auto-load)
    ‚Üì User decides: resume or start fresh
    ‚Üì
If Resume: Load minimal state from session file (selective)
If Fresh: Start new work with clean RAM</code></pre>

    <p>This design mirrors how computers handle memory pressure: when RAM is full, you save your work, close applications (end session), and restart fresh.</p>

    <h4>Sub-Agents as Virtual Memory</h4>
    <p>The system extends the metaphor further with sub-agents functioning as a <strong>virtual memory</strong> mechanism:</p>

    <pre><code>Main Session RAM (Limited - 200K tokens)
    ‚Üì Task requires heavy processing
    ‚Üì Delegate to sub-agent
    ‚Üì
Sub-Agent (Fresh isolated 200K context)
    ‚Üì Loads extensive data
    ‚Üì Processes information
    ‚Üì Generates summary
    ‚Üì Context automatically cleaned up after completion
    ‚Üì
Return Summary to Main Session (5K tokens, not 150K)
    ‚Üì
Main Session RAM += 5K (not 150K!)
    ‚Üì Total RAM saved: 145K tokens (97% reduction)</code></pre>

    <p>This is analogous to how operating systems use virtual memory to extend effective RAM capacity by swapping data to disk. Sub-agents provide isolated processing environments that don't pollute the main session's context.</p>

    <div class="best-practice">
        <h5>Metaphor-Driven Best Practices</h5>
        <ul>
            <li><strong>Think like a CPU:</strong> Execute instructions sequentially, maintain state in registers, handle errors explicitly</li>
            <li><strong>Respect RAM limits:</strong> Monitor context usage, load selectively, checkpoint before DANGER zone</li>
            <li><strong>Use storage properly:</strong> Persist computed results to filesystem for future sessions (data stays in current RAM due to append-only architecture)</li>
            <li><strong>Follow boot sequence:</strong> Always load BIOS (CLAUDE.md) and state on startup</li>
            <li><strong>Leverage virtual memory:</strong> Delegate context-heavy tasks to sub-agents to extend effective RAM capacity</li>
            <li><strong>Save state before shutdown:</strong> Use <code>/HAL-session-end</code> before context window fills</li>
        </ul>
    </div>
</div>

</section>

            <!-- Part II: Architecture & Design -->
            <div class="part-divider">
                <h1 class="part-header">Part II: Architecture</h1>
                <p class="part-description">System design, components, and architectural principles</p>
            </div>

            <!-- Section 5: Architecture Overview -->
            <section id="architecture-overview" data-status="complete" data-priority="1" data-sources="CLAUDE.md,data/architecture/hal8000-system-design.md" data-estimated-tokens="10000" data-dependencies="what-is-hal8000,system-metaphor">

<h2>5. System Architecture Overview</h2>

<div class="meta-guidance" style="display:none;">
    TARGET: Comprehensive architecture explanation
    AUDIENCE: All three (layered)
    KEY_POINTS: Modified von Neumann, components (CPU/RAM/Storage/Buses/IO), data flow, control flow
    TONE: Technical but accessible
    VISUALS: [DIAGRAM: Complete architecture diagram], [DIAGRAM: Data flow paths]
</div>

<div class="overview">
    <h3>High-Level Architecture</h3>

    <p>HAL8000-Assistant implements a <strong>Modified von Neumann architecture</strong> that maps classical computer architecture principles to the Claude Code environment. The system treats the codebase as a complete computer, with Claude serving as the CPU and the file system providing persistent memory.</p>

    <figure>
        <img src="assets/complete-architecture.svg" alt="HAL8000-Assistant Complete System Architecture" style="width: 100%; max-width: 1200px; height: auto; display: block; margin: 0 auto;">
        <figcaption><strong>Figure 7:</strong> Complete System Architecture - HAL8000-Assistant implements a Modified von Neumann architecture with CPU (Claude), RAM (context window), persistent storage (file system), system buses, and I/O devices. Data flows between components through the system bus architecture.</figcaption>
    </figure>

    <p>The architecture combines three foundational design philosophies:</p>

    <ul>
        <li><strong>Von Neumann Architecture:</strong> Stored-program concept, unified memory space, sequential execution</li>
        <li><strong>Assembly Language Principles:</strong> Direct hardware access, explicit control, low-level visibility</li>
        <li><strong>Unix Philosophy:</strong> Modularity, simplicity, text-based interfaces, composable components</li>
    </ul>

    <h4>Core Components Mapping</h4>

    <table>
        <thead>
            <tr>
                <th>Classical Component</th>
                <th>HAL8000-Assistant Implementation</th>
                <th>Physical Location</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>CPU</td>
                <td>Claude instance (you)</td>
                <td>N/A (processing entity)</td>
            </tr>
            <tr>
                <td>RAM</td>
                <td>Context window</td>
                <td>N/A (200K tokens, volatile)</td>
            </tr>
            <tr>
                <td>Memory/Storage</td>
                <td>File system</td>
                <td><code>/mnt/d/~HAL8000-Assistant/</code></td>
            </tr>
            <tr>
                <td>System Bus</td>
                <td>File I/O + Tool calls</td>
                <td>N/A (data transfer mechanism)</td>
            </tr>
            <tr>
                <td>I/O Devices</td>
                <td>Claude Code tools</td>
                <td>MCP servers + built-in tools</td>
            </tr>
            <tr>
                <td>BIOS</td>
                <td><code>CLAUDE.md</code></td>
                <td>Root directory</td>
            </tr>
        </tbody>
    </table>
</div>

</section>

            <!-- Section 6: Memory Architecture -->
            <section id="memory-architecture" data-status="complete" data-priority="1" data-sources="CLAUDE.md:Memory Architecture,CLAUDE.md:File System Structure" data-estimated-tokens="10000" data-dependencies="architecture-overview">
    <h2>6. Memory Architecture</h2>

    <div class="meta-guidance">
        TARGET: Explain memory hierarchy and organization
        AUDIENCE: All three (layered - overview for all, concepts for users+devs, technical for devs)
        KEY_POINTS: File system structure, BIOS-ROM (CLAUDE.md), state.json, directories (.claude/, data/), memory vs RAM distinction
        TONE: Technical, structured
        VISUALS: [DIAGRAM: File system tree], [DIAGRAM: Memory hierarchy]
    </div>

    <div class="content">
        <h3>Overview</h3>
        <p>HAL8000-Assistant implements a persistent file-based memory system that mirrors traditional computer memory architecture. Unlike conventional computers where RAM is the primary working space, HAL8000-Assistant treats the file system as permanent memory and the Claude context window as volatile RAM. This design ensures all instructions, data, and state persist across sessions while maintaining clear boundaries between permanent storage and temporary working context.</p>

        <p>The memory system consists of two fundamental layers:</p>
        <ul>
            <li><strong>Persistent Memory (File System):</strong> All files in the repository serve as non-volatile storage. This includes executable instructions (commands), system state, data, and configuration. The file system capacity far exceeds available RAM.</li>
            <li><strong>Volatile RAM (Context Window):</strong> The Claude instance's context window serves as temporary working memory. Content loaded into RAM persists only for the current session and is cleared when the session ends. RAM capacity is limited (approximately 200,000 tokens).</li>
        </ul>

        <p>This separation creates a fundamental constraint: the total memory (file system) exceeds available RAM capacity. Therefore, selective loading and careful context management are architectural requirements, not optimizations.</p>

        <h3>Memory Hierarchy</h3>

        <figure>
            <img src="assets/memory-hierarchy.svg" alt="Memory Hierarchy: Persistent Storage and Volatile RAM" style="width: 90%; max-width: 1100px; height: auto; display: block; margin: 0 auto;">
            <figcaption><strong>Figure 8:</strong> Memory Hierarchy - HAL8000-Assistant's two-tier memory system with persistent file system (unlimited capacity) and volatile context window (200K token limit). The fundamental constraint is that total memory exceeds RAM capacity, making selective loading an architectural requirement.</figcaption>
        </figure>

        <h4>Core vs Optional Components</h4>
        <p>Memory components are classified by loading priority during system boot:</p>

        <table>
            <thead>
                <tr>
                    <th>Component</th>
                    <th>Location</th>
                    <th>Purpose</th>
                    <th>Loading Behavior</th>
                    <th>Failure Impact</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>BIOS-ROM</strong></td>
                    <td><code>CLAUDE.md</code></td>
                    <td>Boot instructions, architectural principles, operating protocols</td>
                    <td>Always loaded on boot</td>
                    <td>System failure (cannot boot)</td>
                </tr>
                <tr>
                    <td><strong>State</strong></td>
                    <td><code>.claude/state.json</code></td>
                    <td>Current state pointer, active session reference, system phase</td>
                    <td>Always loaded on boot</td>
                    <td>Degraded mode (no state persistence)</td>
                </tr>
                <tr>
                    <td><strong>Indexes</strong></td>
                    <td><code>.claude/indexes/</code></td>
                    <td>File system and library indexes for discovery</td>
                    <td>On-demand via discovery operations</td>
                    <td>Reduced discoverability (manual navigation required)</td>
                </tr>
                <tr>
                    <td><strong>Sessions</strong></td>
                    <td><code>.claude/sessions/</code></td>
                    <td>Session handoff files for continuity across RAM wipes</td>
                    <td>Only when explicitly resuming</td>
                    <td>Cannot resume previous session (start fresh)</td>
                </tr>
                <tr>
                    <td><strong>Commands</strong></td>
                    <td><code>.claude/commands/</code></td>
                    <td>Executable instruction definitions</td>
                    <td>On-demand when command invoked</td>
                    <td>Specific command unavailable</td>
                </tr>
                <tr>
                    <td><strong>Libraries</strong></td>
                    <td><code>.claude/libraries/</code></td>
                    <td>Reusable instruction collections (internal and external)</td>
                    <td>On-demand via discovery</td>
                    <td>Reduced functionality (cannot use library features)</td>
                </tr>
                <tr>
                    <td><strong>Data</strong></td>
                    <td><code>data/</code></td>
                    <td>Research documents, architecture specs, project data</td>
                    <td>On-demand when explicitly needed</td>
                    <td>Missing context (must load manually)</td>
                </tr>
                <tr>
                    <td><strong>System Log</strong></td>
                    <td><code>.claude/system.log</code></td>
                    <td>Historical audit trail (append-only)</td>
                    <td>Never loaded (I/O only)</td>
                    <td>None (accessed via file I/O when needed)</td>
                </tr>
            </tbody>
        </table>

        <h3>File System Organization</h3>
        <p>The HAL8000-Assistant file system follows a strict hierarchical structure with a three-level depth limit (except for external libraries, which maintain their original structure). This constraint enforces Unix philosophy principles: simplicity, modularity, and composability.</p>

        <figure>
            <img src="assets/filesystem-tree.svg" alt="HAL8000-Assistant File System Structure" style="width: 100%; max-width: 1200px; height: auto; display: block; margin: 0 auto;">
            <figcaption><strong>Figure 9:</strong> File System Structure - Complete directory hierarchy showing the 3-level depth organization. Core files (CLAUDE.md, state.json) are marked for emphasis. The external libraries directory is exempt from the depth limit to maintain compatibility with third-party code.</figcaption>
        </figure>

        <h4>Root Level</h4>
        <p>The repository root (<code>/mnt/d/~HAL8000-Assistant/</code>) represents the computer itself in the von Neumann metaphor. It contains:</p>
        <ul>
            <li><code>CLAUDE.md</code> - The BIOS-ROM, containing boot instructions and architectural principles. This file is always loaded first and defines how the CPU (Claude instance) operates.</li>
            <li><code>.claude/</code> - System coordination directory containing all operational components.</li>
            <li><code>data/</code> - Data storage directory for research, architecture documentation, and project files.</li>
        </ul>

        <h4>System Coordination (.claude/)</h4>
        <p>The <code>.claude/</code> directory contains all system-level components:</p>

        <p><strong>Core State Files:</strong></p>
        <ul>
            <li><code>state.json</code> - Current system state encoded as JSON. Contains timestamp, active session reference, system phase, context summary, and next action. Always loaded during boot sequence. Serves as a state pointer, not comprehensive state storage.</li>
            <li><code>system.log</code> - Append-only historical audit trail. Never loaded into RAM; accessed only via file I/O operations when historical queries are needed. Each session appends its completion entry to this log.</li>
        </ul>

        <p><strong>Indexed Structures:</strong></p>
        <ul>
            <li><code>indexes/</code> - Contains hierarchical indexes for file system navigation and library discovery. Includes <code>master.json</code> (master file system index) and per-directory indexes. Loaded on-demand via discovery operations to reduce boot overhead.</li>
            <li><code>libraries/</code> - Reusable instruction collections organized into:
                <ul>
                    <li><code>internal/</code> - Libraries developed as part of HAL8000-Assistant (subject to 3-level depth limit)</li>
                    <li><code>external/</code> - Third-party libraries (exempt from depth limit, maintain original structure)</li>
                    <li><code>index.json</code> - Library index for discovery</li>
                </ul>
            </li>
        </ul>

        <p><strong>Executable Components:</strong></p>
        <ul>
            <li><code>commands/</code> - Executable instruction definitions following naming convention <code>HAL-*.md</code>. Each command implements a single operation (Unix: do one thing well). Commands are loaded into RAM only when invoked.</li>
            <li><code>agents/</code> - Specialized sub-agents that operate in isolated context windows. Each agent is a separate Claude instance with its own 200K token RAM allocation. Agents extend total system RAM capacity through process isolation.</li>
            <li><code>tools/</code> - External program interfaces for I/O operations and system integration.</li>
        </ul>

        <p><strong>Session Management:</strong></p>
        <ul>
            <li><code>sessions/</code> - Session handoff files following naming convention <code>YYYY-MM-DD-HHMM-description.md</code>. These files enable session continuity across RAM wipes. Files are loaded only when explicitly resuming a previous session, never automatically during boot.</li>
        </ul>

        <h4>Data Storage (data/)</h4>
        <p>The <code>data/</code> directory contains all non-executable data:</p>
        <ul>
            <li><code>research/</code> - Research documents with numbered prefixes (e.g., <code>01-von-neumann-architecture.md</code>). Contains technical deep-dives on architectural concepts.</li>
            <li><code>architecture/</code> - System architecture documentation, design decisions, and technical specifications.</li>
            <li><code>projects/</code> - Project-specific data and work products.</li>
        </ul>

        <h3>Memory vs RAM Distinction</h3>
        <p>Understanding the fundamental difference between persistent memory and volatile RAM is critical for effective system operation:</p>

        <h4>Persistent Memory (File System)</h4>
        <ul>
            <li><strong>Capacity:</strong> Effectively unlimited (constrained only by disk space)</li>
            <li><strong>Persistence:</strong> All writes are permanent until explicitly deleted</li>
            <li><strong>Access Pattern:</strong> Selective loading via explicit file I/O operations</li>
            <li><strong>Cost:</strong> No token cost to store; costs only occur when loading into RAM</li>
            <li><strong>Scope:</strong> Global across all sessions</li>
        </ul>

        <h4>Volatile RAM (Context Window)</h4>
        <ul>
            <li><strong>Capacity:</strong> Limited to approximately 200,000 tokens per session</li>
            <li><strong>Persistence:</strong> Content is cleared at session end (garbage collection)</li>
            <li><strong>Access Pattern:</strong> Append-only accumulation within session (no dynamic eviction)</li>
            <li><strong>Cost:</strong> Every file load permanently consumes tokens until session ends</li>
            <li><strong>Scope:</strong> Local to current session only</li>
        </ul>

        <h4>RAM Management Zones</h4>
        <p>RAM usage is monitored via the <code>RAM_ZONE</code> register, which provides operational guidance:</p>
        <ul>
            <li><strong>SAFE (0-80%):</strong> Normal operation. Load files freely based on task requirements.</li>
            <li><strong>CAUTION (80-90%):</strong> Monitor closely. Prepare for checkpoint operation. Warn user before loading large files.</li>
            <li><strong>DANGER (90-100%):</strong> Checkpoint urgently. Performance degraded. Refuse additional loads unless user explicitly confirms necessity.</li>
        </ul>

        <h4>Selective Loading Protocol</h4>
        <p>Because total memory exceeds RAM capacity, selective loading is mandatory:</p>
        <ol>
            <li><strong>Before loading any file:</strong>
                <ul>
                    <li>Check <code>CONTEXT_MANIFEST</code> register to verify file is not already loaded</li>
                    <li>Estimate token cost of file</li>
                    <li>Calculate projected RAM usage: <code>current_RAM_usage + estimated_cost</code></li>
                    <li>Evaluate resulting <code>RAM_ZONE</code></li>
                </ul>
            </li>
            <li><strong>Loading decision:</strong>
                <ul>
                    <li>If remains SAFE: Proceed with load</li>
                    <li>If enters CAUTION: Warn user, suggest alternatives (delegate to sub-agent, load subset)</li>
                    <li>If enters DANGER: Refuse unless user explicitly confirms</li>
                </ul>
            </li>
            <li><strong>Post-load:</strong>
                <ul>
                    <li>Update <code>CONTEXT_MANIFEST</code> register with loaded file</li>
                    <li>Update <code>RAM_USAGE</code> register with actual token count</li>
                    <li>Recalculate <code>RAM_ZONE</code></li>
                </ul>
            </li>
        </ol>

        <h3>Sub-Agent Memory Extension</h3>
        <p>Sub-agents function as virtual memory, extending total RAM capacity through process isolation. Each sub-agent operates in a completely separate context window with its own 200K token allocation.</p>

        <p><strong>Architectural Model:</strong></p>
        <pre><code>Main Session (Limited RAM)
    ‚Üì delegate heavy processing
Sub-Agent (Fresh 200K RAM, isolated context)
    ‚Üì process data, load multiple files, perform research
    ‚Üì generate summary/result (5-10K tokens)
Returns clean summary (not raw data)
    ‚Üì result
Main Session (RAM += summary only, not full processing cost)</code></pre>

        <p><strong>Memory Benefits:</strong></p>
        <ul>
            <li><strong>Context Isolation:</strong> Sub-agent's full processing cost (potentially 150K+ tokens) never enters main session RAM</li>
            <li><strong>Automatic Cleanup:</strong> Sub-agent context is destroyed after completion, reclaiming all RAM</li>
            <li><strong>Capacity Multiplication:</strong> Multiple sub-agents can be invoked sequentially, each with fresh 200K context</li>
            <li><strong>RAM Efficiency:</strong> Typical savings of 60-85% compared to direct loading</li>
        </ul>

        <p><strong>Delegation Guidelines:</strong></p>
        <p>Always delegate to sub-agents when:</p>
        <ul>
            <li>Web research requiring multiple sources (use <code>research-synthesizer</code>)</li>
            <li>System context discovery requiring navigation and loading multiple files (use <code>hal-context-finder</code>)</li>
            <li>Large file analysis where full content not needed in main session</li>
            <li>Multi-step processing where intermediate data exceeds 30K tokens</li>
            <li>Any operation where input data significantly exceeds output summary</li>
        </ul>

        <h3>State Persistence Model</h3>
        <p>Because RAM is volatile, state must persist via the file system. HAL8000-Assistant implements a multi-layer persistence strategy:</p>

        <h4>State Pointer (state.json)</h4>
        <p>The <code>.claude/state.json</code> file serves as a lightweight state pointer, not comprehensive state storage. It contains:</p>
        <ul>
            <li><code>timestamp</code> - ISO 8601 timestamp of last state update</li>
            <li><code>active_session</code> - Filename of most recent session file (may be null if no session saved)</li>
            <li><code>phase</code> - Current system phase (e.g., "production-ready", "development")</li>
            <li><code>context</code> - Brief summary of current focus</li>
            <li><code>next_action</code> - Suggested next action for continuity</li>
        </ul>

        <h4>Session Files (.claude/sessions/)</h4>
        <p>When a session ends (RAM wipe imminent), the <code>/HAL-session-end</code> command creates a comprehensive session handoff file containing:</p>
        <ul>
            <li>Session metadata (date, time, description)</li>
            <li>Current context summary</li>
            <li>Work completed during session</li>
            <li>Work in progress and next steps</li>
            <li>Relevant file paths and code locations</li>
            <li>Open questions or blockers</li>
        </ul>

        <p>Session files enable continuity across RAM wipes by preserving full working context. They are loaded only when explicitly resuming, never automatically.</p>

        <h4>Historical Audit Trail (system.log)</h4>
        <p>The <code>.claude/system.log</code> provides append-only historical record of all sessions. Each session completion appends an entry with:</p>
        <ul>
            <li>Session timestamp</li>
            <li>Session description</li>
            <li>Duration (if calculable)</li>
            <li>Major operations performed</li>
        </ul>

        <p>This log is never loaded into RAM (to preserve token budget), but can be queried via file I/O operations when historical analysis is needed.</p>

        <h3>Technical Implementation Details</h3>

        <h4>Depth Limit Enforcement</h4>
        <p>The three-level depth limit is enforced for all internal code and system organization:</p>
        <ul>
            <li><strong>Level 1:</strong> Root and primary organization (<code>CLAUDE.md</code>, <code>.claude/</code>, <code>data/</code>)</li>
            <li><strong>Level 2:</strong> Functional categories (<code>.claude/commands/</code>, <code>data/research/</code>)</li>
            <li><strong>Level 3:</strong> Individual files (<code>.claude/commands/HAL-session-end.md</code>)</li>
        </ul>

        <p><strong>Exception:</strong> External libraries (<code>.claude/libraries/external/</code>) are exempt from this limit. They maintain their original structure for compatibility and ease of updates. This exception is explicitly documented to prevent confusion.</p>

        <h4>JSON vs Markdown Storage</h4>
        <p>HAL8000-Assistant uses two primary storage formats:</p>
        <ul>
            <li><strong>JSON:</strong> Structured data requiring programmatic access (<code>state.json</code>, index files). Enables easy parsing and field extraction.</li>
            <li><strong>Markdown:</strong> Human-readable content (commands, sessions, documentation, research). Provides formatting while remaining plain text. Aligns with Unix philosophy of text streams.</li>
        </ul>

        <h4>Naming Conventions</h4>
        <ul>
            <li><strong>Commands:</strong> <code>HAL-command-name.md</code> (kebab-case with HAL prefix)</li>
            <li><strong>Sessions:</strong> <code>YYYY-MM-DD-HHMM-description.md</code> (ISO 8601 date/time prefix)</li>
            <li><strong>Research:</strong> <code>##-descriptive-name.md</code> (numbered prefix for ordering)</li>
            <li><strong>Indexes:</strong> <code>component.json</code> or <code>master.json</code></li>
        </ul>

        <h4>Write Patterns</h4>
        <ul>
            <li><strong>state.json:</strong> Complete replacement on every write (small file, atomic update)</li>
            <li><strong>system.log:</strong> Append-only (never modified, only grows)</li>
            <li><strong>Session files:</strong> Write-once (created at session end, never modified)</li>
            <li><strong>Commands/data:</strong> Edit-in-place (version control via git if needed)</li>
        </ul>

        <p>This memory architecture creates a robust, persistent system where all state survives session boundaries, RAM constraints are explicit and manageable, and the total system capacity far exceeds individual session limitations.</p>
    </div>
</section>

            <!-- Section 7: Component Specifications -->
            <section id="component-specs" data-status="complete" data-priority="2" data-sources="CLAUDE.md,state.json,data/architecture/" data-estimated-tokens="15000" data-dependencies="architecture-overview">
                <h2>7. Component Specifications</h2>
                <div class="meta-guidance">
                    TARGET: Detailed specs for each architectural component
                    AUDIENCE: Developers and advanced users
                    KEY_POINTS: CPU (control unit, ALU), RAM (context window specs), Storage (filesystem), Buses (data flow), IO (tools/MCP)
                    TONE: Technical specification style
                    VISUALS: [DIAGRAM: Component interaction diagram]
                </div>
                <div class="content">
    <div class="overview">
        <p>HAL8000-Assistant is a complete computer system that maps von Neumann architecture principles to the Claude Code environment. This section provides detailed technical specifications for all hardware and software components that comprise the system, organized by functional subsystem.</p>

        <p>The architecture follows a Modified von Neumann model with Harvard-like organization (separate instruction/data spaces) while maintaining von Neumann capabilities (self-modifying code, unified access). Each component is designed to operate within Claude Code's specific runtime constraints while maintaining architectural fidelity.</p>
    </div>

    <h3>1. CPU (Central Processing Unit)</h3>

    <p>The CPU is the Claude instance itself, responsible for fetching, decoding, and executing instructions. It operates as a complete processing unit with distinct functional subcomponents.</p>

    <table>
        <tr>
            <th>Component</th>
            <th>Implementation</th>
            <th>Specification</th>
        </tr>
        <tr>
            <td><strong>Control Unit</strong></td>
            <td>Claude orchestration and decision-making</td>
            <td>Manages fetch-decode-execute cycle, coordinates all system operations, handles control flow</td>
        </tr>
        <tr>
            <td><strong>ALU (Arithmetic Logic Unit)</strong></td>
            <td>Claude reasoning and computation</td>
            <td>Performs all computational and logical operations, including text processing, analysis, code generation</td>
        </tr>
        <tr>
            <td><strong>Registers</strong></td>
            <td>Claude immediate working context</td>
            <td>21 registers across 5 categories (Control, Memory, State, Status, Data) - see Register Architecture</td>
        </tr>
        <tr>
            <td><strong>Model</strong></td>
            <td>Claude Sonnet 4.5</td>
            <td>Model ID: claude-sonnet-4-5-20250929, Knowledge cutoff: January 2025</td>
        </tr>
        <tr>
            <td><strong>Execution Modes</strong></td>
            <td>EXEC_MODE register</td>
            <td>INTERACTIVE (user-driven), AUTONOMOUS (self-directed), SUBAGENT (isolated context), BOOT (initialization), IDLE (awaiting input)</td>
        </tr>
    </table>

    <h4>Register Architecture (21 Registers)</h4>

    <table>
        <tr>
            <th>Register</th>
            <th>Category</th>
            <th>Type</th>
            <th>Purpose</th>
        </tr>
        <tr><td colspan="4"><strong>Control Registers</strong></td></tr>
        <tr>
            <td>PC (Program Counter)</td>
            <td>Control</td>
            <td>String</td>
            <td>Points to next instruction/command to execute</td>
        </tr>
        <tr>
            <td>IR (Instruction Register)</td>
            <td>Control</td>
            <td>String</td>
            <td>Holds current instruction being executed</td>
        </tr>
        <tr>
            <td>EXEC_MODE</td>
            <td>Control</td>
            <td>Enum</td>
            <td>Current execution mode/context</td>
        </tr>
        <tr>
            <td>FLOW_STATE</td>
            <td>Control</td>
            <td>String</td>
            <td>Position in multi-step operations</td>
        </tr>
        <tr><td colspan="4"><strong>Memory Registers</strong></td></tr>
        <tr>
            <td>RAM_USAGE</td>
            <td>Memory</td>
            <td>Integer</td>
            <td>Current context window consumption (tokens)</td>
        </tr>
        <tr>
            <td>RAM_CAPACITY</td>
            <td>Memory</td>
            <td>Integer</td>
            <td>Maximum context window size (200,000 tokens)</td>
        </tr>
        <tr>
            <td>RAM_REMAINING</td>
            <td>Memory</td>
            <td>Integer</td>
            <td>Remaining context capacity (tokens)</td>
        </tr>
        <tr>
            <td>RAM_ZONE</td>
            <td>Memory</td>
            <td>Enum</td>
            <td>Performance zone: SAFE (0-80%), CAUTION (80-90%), DANGER (90-100%)</td>
        </tr>
        <tr>
            <td>CONTEXT_MANIFEST</td>
            <td>Memory</td>
            <td>Array</td>
            <td>Inventory of currently loaded files in RAM</td>
        </tr>
        <tr><td colspan="4"><strong>State Registers</strong></td></tr>
        <tr>
            <td>SESSION_ID</td>
            <td>State</td>
            <td>String</td>
            <td>Active session file path for continuity</td>
        </tr>
        <tr>
            <td>SESSION_START</td>
            <td>State</td>
            <td>Timestamp</td>
            <td>When current session began (ISO 8601)</td>
        </tr>
        <tr>
            <td>CHECKPOINT_STATUS</td>
            <td>State</td>
            <td>Object</td>
            <td>Last checkpoint state and timing</td>
        </tr>
        <tr>
            <td>PHASE</td>
            <td>State</td>
            <td>String</td>
            <td>Current project phase (persists across sessions)</td>
        </tr>
        <tr>
            <td>LOADED_COMMANDS</td>
            <td>State</td>
            <td>Array</td>
            <td>Available/known commands in current session</td>
        </tr>
        <tr><td colspan="4"><strong>Status Registers</strong></td></tr>
        <tr>
            <td>CPU_STATUS</td>
            <td>Status</td>
            <td>Enum</td>
            <td>CPU health: OPERATIONAL, DEGRADED, BLOCKED, ERROR</td>
        </tr>
        <tr>
            <td>RATE_LIMIT_STATUS</td>
            <td>Status</td>
            <td>Object</td>
            <td>Usage limits and reset timing (5-hour cycles)</td>
        </tr>
        <tr>
            <td>ERROR_FLAG</td>
            <td>Status</td>
            <td>Boolean</td>
            <td>Indicates if error occurred in last operation</td>
        </tr>
        <tr>
            <td>ERROR_CODE</td>
            <td>Status</td>
            <td>String</td>
            <td>Specific error identifier or message</td>
        </tr>
        <tr><td colspan="4"><strong>Data Registers</strong></td></tr>
        <tr>
            <td>ACC (Accumulator)</td>
            <td>Data</td>
            <td>Any</td>
            <td>Intermediate results of current operation</td>
        </tr>
        <tr>
            <td>VARS</td>
            <td>Data</td>
            <td>Object</td>
            <td>User-defined and system variables for session</td>
        </tr>
        <tr>
            <td>RESULT</td>
            <td>Data</td>
            <td>Any</td>
            <td>Result of most recent operation</td>
        </tr>
    </table>

    <h3>2. Memory Subsystem</h3>

    <h4>2.1 RAM (Context Window)</h4>

    <table>
        <tr>
            <th>Specification</th>
            <th>Value</th>
            <th>Details</th>
        </tr>
        <tr>
            <td><strong>Capacity</strong></td>
            <td>200,000 tokens</td>
            <td>Standard Claude Code terminal capacity (may vary by environment: 500K enterprise, 1M API)</td>
        </tr>
        <tr>
            <td><strong>Architecture</strong></td>
            <td>Append-only</td>
            <td>Context accumulates during session, no dynamic eviction within session</td>
        </tr>
        <tr>
            <td><strong>Volatility</strong></td>
            <td>Volatile</td>
            <td>Lost completely at session boundary (conversation reset)</td>
        </tr>
        <tr>
            <td><strong>Garbage Collection</strong></td>
            <td>Session boundaries only</td>
            <td>Only way to reclaim RAM is to end session and start new one</td>
        </tr>
        <tr>
            <td><strong>Performance Zones</strong></td>
            <td>3 zones</td>
            <td>SAFE (0-80%, 0-160K tokens), CAUTION (80-90%, 160K-180K), DANGER (90-100%, 180K-200K)</td>
        </tr>
        <tr>
            <td><strong>Loading Model</strong></td>
            <td>Selective loading</td>
            <td>Every file load is permanent commitment until session end</td>
        </tr>
        <tr>
            <td><strong>Monitoring</strong></td>
            <td>System warnings</td>
            <td>Exact token usage reported after every tool invocation</td>
        </tr>
    </table>

    <h4>2.2 File System (Persistent Memory)</h4>

    <table>
        <tr>
            <th>Component</th>
            <th>Location</th>
            <th>Purpose</th>
            <th>Loaded on Boot?</th>
        </tr>
        <tr>
            <td><strong>BIOS</strong></td>
            <td>/mnt/d/~HAL8000-Assistant/CLAUDE.md</td>
            <td>Boot instructions, system architecture</td>
            <td>Always</td>
        </tr>
        <tr>
            <td><strong>State</strong></td>
            <td>.claude/state.json</td>
            <td>Current state pointer (JSON)</td>
            <td>Always</td>
        </tr>
        <tr>
            <td><strong>Sessions</strong></td>
            <td>.claude/sessions/</td>
            <td>Session handoff files (YYYY-MM-DD-HHMM-description.md)</td>
            <td>Only when resuming</td>
        </tr>
        <tr>
            <td><strong>Commands</strong></td>
            <td>.claude/commands/</td>
            <td>Executable HAL commands (HAL-*.md)</td>
            <td>On demand</td>
        </tr>
        <tr>
            <td><strong>Agents</strong></td>
            <td>.claude/agents/</td>
            <td>Specialized agent definitions</td>
            <td>On demand</td>
        </tr>
        <tr>
            <td><strong>Libraries</strong></td>
            <td>.claude/libraries/</td>
            <td>Reusable instruction collections</td>
            <td>On demand (via discovery)</td>
        </tr>
        <tr>
            <td><strong>Indexes</strong></td>
            <td>.claude/indexes/</td>
            <td>Hierarchical file system and library indexes</td>
            <td>On demand (via discovery)</td>
        </tr>
        <tr>
            <td><strong>Data</strong></td>
            <td>data/</td>
            <td>Persistent data storage (research/, architecture/, projects/)</td>
            <td>On demand</td>
        </tr>
        <tr>
            <td><strong>System Log</strong></td>
            <td>.claude/system.log</td>
            <td>Historical audit trail (append-only)</td>
            <td>Never (I/O only)</td>
        </tr>
        <tr>
            <td><strong>Tools</strong></td>
            <td>.claude/tools/</td>
            <td>Custom I/O interfaces (scripts we build)</td>
            <td>On demand</td>
        </tr>
    </table>

    <p><strong>File System Constraints:</strong></p>
    <ul>
        <li><strong>Depth Limit:</strong> Maximum 3 levels for internal code (Unix philosophy - simplicity)</li>
        <li><strong>Exception:</strong> External libraries (.claude/libraries/external/) exempt from depth limit</li>
        <li><strong>Format:</strong> Plain text, human-readable files (Markdown, JSON, shell scripts)</li>
        <li><strong>Root:</strong> /mnt/d/~HAL8000-Assistant/ (the computer itself)</li>
    </ul>

    <h4>2.3 Indexing System</h4>

    <table>
        <tr>
            <th>Index Type</th>
            <th>Location</th>
            <th>Purpose</th>
            <th>Update Method</th>
        </tr>
        <tr>
            <td><strong>Master Index</strong></td>
            <td>.claude/indexes/master.json</td>
            <td>Top-level file system catalog</td>
            <td>/HAL-index-update filesystem</td>
        </tr>
        <tr>
            <td><strong>Directory Indexes</strong></td>
            <td>.claude/indexes/[directory].json</td>
            <td>Per-directory file catalogs</td>
            <td>/HAL-index-update filesystem</td>
        </tr>
        <tr>
            <td><strong>Library Index</strong></td>
            <td>.claude/libraries/index.json</td>
            <td>Library patterns and workflows catalog</td>
            <td>/HAL-index-update libraries</td>
        </tr>
    </table>

    <p><strong>Benefits:</strong> RAM-efficient discovery (2-5K tokens vs. loading all files), scalable to 1000+ directories, enables fast context finding without full file loading.</p>

    <h3>3. State Management Components</h3>

    <h4>3.1 state.json (Current State Pointer)</h4>

    <table>
        <tr>
            <th>Field</th>
            <th>Type</th>
            <th>Purpose</th>
        </tr>
        <tr>
            <td>timestamp</td>
            <td>ISO 8601</td>
            <td>When state was last saved</td>
        </tr>
        <tr>
            <td>active_session</td>
            <td>String (path)</td>
            <td>Pointer to current/last session file</td>
        </tr>
        <tr>
            <td>context</td>
            <td>String</td>
            <td>Brief description of current work</td>
        </tr>
        <tr>
            <td>next_action</td>
            <td>String</td>
            <td>What to do next on resume</td>
        </tr>
        <tr>
            <td>loaded_commands</td>
            <td>Array</td>
            <td>Available command names</td>
        </tr>
        <tr>
            <td>variables</td>
            <td>Object</td>
            <td>System and user-defined variables (version, phase, project state, etc.)</td>
        </tr>
        <tr>
            <td>reference_manual</td>
            <td>Object</td>
            <td>Reference manual development status (version, sections, batches)</td>
        </tr>
    </table>

    <p><strong>Characteristics:</strong> Overwritten on each checkpoint (no history), loaded on every boot, lightweight JSON format, critical system file (boot fails if missing).</p>

    <h4>3.2 Session Files</h4>

    <p><strong>Format:</strong> Markdown (.md)</p>
    <p><strong>Naming:</strong> YYYY-MM-DD-HHMM-description.md (e.g., 2025-10-10-0759-housekeeping-batch3-complete.md)</p>
    <p><strong>Location:</strong> .claude/sessions/</p>
    <p><strong>Purpose:</strong> Rich context preservation for resuming work after RAM wipe</p>

    <p><strong>Standard Sections:</strong></p>
    <ul>
        <li><strong>Context:</strong> High-level description of work in progress</li>
        <li><strong>Key Decisions:</strong> Important choices made during session</li>
        <li><strong>Active Work:</strong> Current task and next steps</li>
        <li><strong>Loaded Files:</strong> Files currently in RAM</li>
        <li><strong>Variables/State:</strong> Important state information to preserve</li>
    </ul>

    <h4>3.3 System Log</h4>

    <p><strong>Location:</strong> .claude/system.log</p>
    <p><strong>Format:</strong> Plain text, timestamped entries</p>
    <p><strong>Access:</strong> Append-only, I/O operations only (never auto-loaded on boot)</p>
    <p><strong>Purpose:</strong> Historical audit trail across all sessions</p>
    <p><strong>Entry Format:</strong> YYYY-MM-DDTHH:MM:SSZ | EventType | Description</p>

    <h3>4. Commands (Instruction Set)</h3>

    <p>HAL8000-Assistant provides 9 core commands stored in .claude/commands/ with naming convention HAL-*.md:</p>

    <table>
        <tr>
            <th>Command</th>
            <th>File</th>
            <th>Purpose</th>
            <th>Category</th>
        </tr>
        <tr>
            <td>/HAL-session-end</td>
            <td>HAL-session-end.md</td>
            <td>Save current session state before RAM wipe</td>
            <td>Session Management</td>
        </tr>
        <tr>
            <td>/HAL-register-dump</td>
            <td>HAL-register-dump.md</td>
            <td>Display current CPU register states</td>
            <td>Diagnostics</td>
        </tr>
        <tr>
            <td>/HAL-system-check</td>
            <td>HAL-system-check.md</td>
            <td>Perform system health check and validate components</td>
            <td>Diagnostics</td>
        </tr>
        <tr>
            <td>/HAL-index-update</td>
            <td>HAL-index-update.md</td>
            <td>Update hierarchical file system and library indexes</td>
            <td>Infrastructure</td>
        </tr>
        <tr>
            <td>/HAL-library-update</td>
            <td>HAL-library-update.md</td>
            <td>Update external libraries from source repositories (package manager)</td>
            <td>Infrastructure</td>
        </tr>
        <tr>
            <td>/HAL-context-find</td>
            <td>HAL-context-find.md</td>
            <td>Find and load system context via hal-context-finder agent (60-85% RAM savings)</td>
            <td>Context Management</td>
        </tr>
        <tr>
            <td>/HAL-CC-check</td>
            <td>HAL-CC-check.md</td>
            <td>Validate Claude Code interface compatibility</td>
            <td>Diagnostics</td>
        </tr>
        <tr>
            <td>/HAL-mcp-control</td>
            <td>HAL-mcp-control.md</td>
            <td>Dynamic MCP server control for RAM optimization</td>
            <td>Infrastructure</td>
        </tr>
        <tr>
            <td>/HAL-refman</td>
            <td>HAL-refman.md</td>
            <td>Manage HAL8000-Assistant Reference Manual development</td>
            <td>Development</td>
        </tr>
    </table>

    <p><strong>Command Characteristics:</strong></p>
    <ul>
        <li><strong>Format:</strong> Markdown files with instructions for Claude to execute</li>
        <li><strong>Execution:</strong> Via slash command syntax (/HAL-command-name)</li>
        <li><strong>Self-modifying:</strong> Commands can create/modify other commands</li>
        <li><strong>Unix Philosophy:</strong> Each command does one thing well</li>
        <li><strong>Loading:</strong> On-demand, tracked in LOADED_COMMANDS register</li>
    </ul>

    <h3>5. Agents (Co-Processors)</h3>

    <p>HAL8000-Assistant includes 5 specialized agents that operate as co-processors with isolated 200K RAM context:</p>

    <table>
        <tr>
            <th>Agent</th>
            <th>File</th>
            <th>Purpose</th>
            <th>Tools</th>
        </tr>
        <tr>
            <td>research-synthesizer</td>
            <td>research-synthesizer.md</td>
            <td>Comprehensive web research on technical topics</td>
            <td>omnisearch, WebSearch, WebFetch, file operations</td>
        </tr>
        <tr>
            <td>hal-context-finder</td>
            <td>hal-context-finder.md</td>
            <td>System context discovery without consuming main RAM (60-85% savings)</td>
            <td>File system navigation, search, content reading</td>
        </tr>
        <tr>
            <td>system-maintenance</td>
            <td>system-maintenance.md</td>
            <td>System health monitoring and maintenance</td>
            <td>File operations, system checks</td>
        </tr>
        <tr>
            <td>documentation-writer</td>
            <td>documentation-writer.md</td>
            <td>Generate technical documentation from source files</td>
            <td>File reading, analysis, HTML/Markdown generation</td>
        </tr>
        <tr>
            <td>claude-code-validator</td>
            <td>claude-code-validator.md</td>
            <td>Validate Claude Code interface compatibility</td>
            <td>Tool availability checks, interface validation</td>
        </tr>
    </table>

    <p><strong>Agent Architecture (Co-Processor Model):</strong></p>
    <ul>
        <li><strong>Isolation:</strong> Each agent runs with fresh 200K token context (isolated from main session)</li>
        <li><strong>Virtual Memory:</strong> Agents extend total RAM capacity through process isolation</li>
        <li><strong>Automatic Cleanup:</strong> Agent context cleaned up after completion</li>
        <li><strong>Output:</strong> Returns clean summaries, not raw data (RAM optimization)</li>
        <li><strong>Volatility:</strong> Results exist in main session RAM only (lost at session boundary unless persisted)</li>
        <li><strong>Invocation:</strong> Via commands or direct agent calls</li>
    </ul>

    <h3>6. MCP Integration (I/O Subsystem)</h3>

    <p>Model Context Protocol (MCP) servers provide I/O capabilities. HAL8000-Assistant currently has 4 configured servers, with 2 actively enabled:</p>

    <table>
        <tr>
            <th>Server</th>
            <th>Status</th>
            <th>Purpose</th>
            <th>Configuration</th>
        </tr>
        <tr>
            <td><strong>omnisearch</strong></td>
            <td>Enabled</td>
            <td>Enhanced web search and content extraction</td>
            <td>npx mcp-omnisearch, API keys: Brave Search, Firecrawl (.env)</td>
        </tr>
        <tr>
            <td><strong>filesystem</strong></td>
            <td>Enabled</td>
            <td>Direct file system operations (read, write, edit, search)</td>
            <td>npx @modelcontextprotocol/server-filesystem /mnt/d/~HAL8000-Assistant</td>
        </tr>
        <tr>
            <td><strong>ide</strong></td>
            <td>Available</td>
            <td>VS Code integration (diagnostics, code execution)</td>
            <td>Not currently enabled (can be activated via /HAL-mcp-control)</td>
        </tr>
        <tr>
            <td><strong>stdio</strong></td>
            <td>Configured</td>
            <td>Standard I/O operations</td>
            <td>Standard MCP protocol implementation</td>
        </tr>
    </table>

    <p><strong>MCP Configuration:</strong></p>
    <ul>
        <li><strong>Config File:</strong> .mcp.json (not loaded on boot, used by Claude Code environment)</li>
        <li><strong>Environment:</strong> .env (API keys for omnisearch server)</li>
        <li><strong>Launch Script:</strong> run-omnisearch.sh (shell script for MCP server startup)</li>
        <li><strong>Dynamic Control:</strong> /HAL-mcp-control command for enabling/disabling servers</li>
        <li><strong>RAM Optimization:</strong> Selective server loading saves tokens</li>
    </ul>

    <p><strong>MCP Tool Categories:</strong></p>
    <ul>
        <li><strong>Web Search:</strong> mcp__omnisearch__web_search (providers: tavily, brave, kagi, exa)</li>
        <li><strong>Web Extraction:</strong> mcp__omnisearch__firecrawl_process (modes: scrape, crawl, map, extract, actions)</li>
        <li><strong>File Operations:</strong> mcp__filesystem__read_file, write_file, edit_file, etc.</li>
        <li><strong>Directory Operations:</strong> list_directory, create_directory, directory_tree, search_files</li>
        <li><strong>IDE Operations:</strong> getDiagnostics, executeCode (Jupyter kernel integration)</li>
    </ul>

    <h3>7. External Tools</h3>

    <p>HAL8000-Assistant integrates with external tools documented in .claude/tools/:</p>

    <h4>7.1 Gemini CLI</h4>

    <table>
        <tr>
            <th>Specification</th>
            <th>Value</th>
        </tr>
        <tr>
            <td><strong>Version</strong></td>
            <td>0.4.1</td>
        </tr>
        <tr>
            <td><strong>Context Window</strong></td>
            <td>1,000,000 tokens (5x HAL8000-Assistant sub-agent capacity)</td>
        </tr>
        <tr>
            <td><strong>Installation</strong></td>
            <td>Host system (Windows)</td>
        </tr>
        <tr>
            <td><strong>Path</strong></td>
            <td>/mnt/c/Users/Shahram-Dev/AppData/Roaming/npm/gemini</td>
        </tr>
        <tr>
            <td><strong>Purpose</strong></td>
            <td>External agent for tasks requiring massive context beyond HAL8000-Assistant capacity</td>
        </tr>
        <tr>
            <td><strong>Documentation</strong></td>
            <td>.claude/tools/gemini-cli.md</td>
        </tr>
    </table>

    <h4>7.2 Docker Environment</h4>

    <table>
        <tr>
            <th>Specification</th>
            <th>Value</th>
        </tr>
        <tr>
            <td><strong>Version</strong></td>
            <td>28.4.0</td>
        </tr>
        <tr>
            <td><strong>Containers Running</strong></td>
            <td>5</td>
        </tr>
        <tr>
            <td><strong>Images Available</strong></td>
            <td>10</td>
        </tr>
        <tr>
            <td><strong>Purpose</strong></td>
            <td>Containerized tool execution, isolated environments</td>
        </tr>
        <tr>
            <td><strong>Documentation</strong></td>
            <td>.claude/tools/docker-cli.md</td>
        </tr>
    </table>

    <p><strong>Tool Philosophy:</strong> Host-installed tools preferred over containers (Unix simplicity). External tools extend HAL8000-Assistant capabilities beyond native limitations.</p>

    <h3>8. Library System</h3>

    <p>Reusable instruction collections organized into internal and external libraries:</p>

    <table>
        <tr>
            <th>Category</th>
            <th>Location</th>
            <th>Purpose</th>
        </tr>
        <tr>
            <td><strong>Internal Libraries</strong></td>
            <td>.claude/libraries/internal/</td>
            <td>Libraries developed within HAL8000-Assistant (development/, research/, system/)</td>
        </tr>
        <tr>
            <td><strong>External Libraries</strong></td>
            <td>.claude/libraries/external/</td>
            <td>Imported third-party libraries (read-only, managed via package manager)</td>
        </tr>
        <tr>
            <td><strong>Library Index</strong></td>
            <td>.claude/libraries/index.json</td>
            <td>Catalog of all library patterns and workflows (currently 226 patterns indexed)</td>
        </tr>
    </table>

    <p><strong>Current External Libraries:</strong></p>
    <ul>
        <li><strong>Fabric:</strong> 227 patterns, 292 files (AI workflow patterns)</li>
    </ul>

    <p><strong>Library Management:</strong></p>
    <ul>
        <li><strong>Package Manager:</strong> /HAL-library-update command handles lifecycle (check updates, backup, download, replace, reindex)</li>
        <li><strong>Discovery:</strong> Via library index (2-5K tokens vs. loading all patterns)</li>
        <li><strong>Depth Limit Exception:</strong> External libraries maintain original structure (exempt from 3-level limit)</li>
    </ul>

    <div class="technical">
        <h3>Technical Implementation Details</h3>

        <h4>Boot Sequence (BIOS)</h4>

        <p>The boot sequence is mandatory and verified on every new session:</p>

        <ol>
            <li><strong>System Initialization:</strong> Load BIOS (CLAUDE.md), understand architecture (Modified von Neumann), verify boot sequence requirements</li>
            <li><strong>Load State:</strong> Read .claude/state.json (CORE file - boot fails if missing), parse JSON to extract timestamp, active_session, context, next_action, store in registers (LAST_SESSION, NEXT_ACTION, SYSTEM_PHASE)</li>
            <li><strong>Note Available Session:</strong> If active_session exists, note pointer (do NOT auto-load session file - user may want different work)</li>
            <li><strong>Boot Acknowledgment:</strong> Provide structured acknowledgment with cited values from loaded files, report RAM_ZONE status</li>
            <li><strong>Error Handling:</strong> Core file failure (CLAUDE.md, state.json) = ABORT boot, report system failure. Optional file failure (sessions, commands) = DEGRADED MODE, warn user, continue with reduced functionality</li>
            <li><strong>Ready to Execute:</strong> CPU_STATUS: OPERATIONAL (or DEGRADED), awaiting user instructions</li>
        </ol>

        <h4>Fetch-Decode-Execute Cycle</h4>

        <p><strong>Fetch Phase:</strong></p>
        <ul>
            <li>Read PC register to determine next instruction</li>
            <li>If PC is null, wait for user input (idle state)</li>
            <li>Load instruction into IR register</li>
            <li>Update PC to next instruction (if applicable)</li>
        </ul>

        <p><strong>Decode Phase:</strong></p>
        <ul>
            <li>Parse instruction from IR register</li>
            <li>Determine required operations and resources</li>
            <li>Check RAM_ZONE to assess resource availability</li>
            <li>Verify CPU_STATUS is OPERATIONAL</li>
        </ul>

        <p><strong>Execute Phase:</strong></p>
        <ul>
            <li>Set EXEC_MODE appropriately (INTERACTIVE, AUTONOMOUS, SUBAGENT, etc.)</li>
            <li>Update FLOW_STATE for multi-step operations</li>
            <li>Perform operation, storing intermediate results in ACC register</li>
            <li>Update RAM_USAGE as context accumulates (from system warnings)</li>
            <li>Store final result in RESULT register</li>
            <li>Update ERROR_FLAG and ERROR_CODE if errors occur</li>
            <li>Update CONTEXT_MANIFEST if files loaded</li>
        </ul>

        <p><strong>Post-Execute:</strong></p>
        <ul>
            <li>Check RAM_ZONE - warn if entering CAUTION (‚â•80%) or DANGER (‚â•90%)</li>
            <li>Update CHECKPOINT_STATUS if checkpoint needed</li>
            <li>Write changes to VARS to state.json if modified</li>
            <li>Prepare for next cycle</li>
        </ul>

        <h4>Resource Management Protocol</h4>

        <p><strong>Before Loading Any File:</strong></p>
        <ol>
            <li>Check CONTEXT_MANIFEST register (already loaded?)</li>
            <li>Estimate token cost</li>
            <li>Calculate: RAM_USAGE + estimated_cost</li>
            <li>Evaluate RAM_ZONE after projected load:
                <ul>
                    <li>If remains SAFE: proceed</li>
                    <li>If enters CAUTION: warn user, suggest alternatives</li>
                    <li>If enters DANGER: refuse unless user confirms</li>
                </ul>
            </li>
        </ol>

        <p><strong>Proactive Checkpoint Triggers:</strong></p>
        <ul>
            <li>RAM_ZONE enters CAUTION (‚â•80%)</li>
            <li>Major work item completed</li>
            <li>Before starting context-heavy operation</li>
            <li>User explicitly requests</li>
        </ul>

        <h4>Sub-Agent Protocol (Virtual Memory)</h4>

        <p>Sub-agents function as virtual memory, extending total RAM capacity through process isolation:</p>

        <p><strong>Architectural Model:</strong></p>
        <pre>Main Session (Limited RAM)
    ‚Üì delegate
Sub-Agent (Fresh 200K RAM, isolated context)
    ‚Üì process heavy work
Returns clean summary (not raw data)
    ‚Üì result
Main Session (RAM += summary only, not full processing cost)</pre>

        <p><strong>When to Delegate:</strong></p>
        <ul>
            <li>Web research (use research-synthesizer)</li>
            <li>System context discovery (use hal-context-finder)</li>
            <li>Large file analysis requiring extensive context</li>
            <li>Multi-step tasks needing &gt;30K tokens intermediate data</li>
            <li>Any operation where input &gt;&gt; output</li>
        </ul>

        <p><strong>Critical Constraint - Output Volatility:</strong></p>
        <ul>
            <li>Sub-agent results returned to main session RAM are <strong>volatile</strong></li>
            <li>Session boundary (RAM wipe) ‚Üí all sub-agent output permanently lost</li>
            <li>Results must be fully processed and persisted to files BEFORE session-end</li>
            <li>Plan sub-agent work as atomic units that complete before session boundary</li>
        </ul>

        <h4>Context Awareness Protocol</h4>

        <p><strong>Context Hierarchy:</strong></p>
        <ol>
            <li><strong>User's Mind:</strong> Complete project knowledge, intent, unstated assumptions</li>
            <li><strong>Filesystem:</strong> All persistent data (exceeds RAM capacity)</li>
            <li><strong>RAM:</strong> Current working context (limited, volatile)</li>
        </ol>

        <p><strong>Missing Context Signals:</strong></p>
        <ul>
            <li>User mentions specific file/path/component not in current RAM</li>
            <li>User references "that file", "the component" without clear antecedent</li>
            <li>User asks "which file has X?" (implies CPU should know the file set)</li>
            <li>User asks implementation details when implementation not loaded</li>
            <li>User uses project-specific terms/names not in current context</li>
        </ul>

        <p><strong>Protocol Steps:</strong></p>
        <ol>
            <li><strong>Parse Question:</strong> Detect missing context signals</li>
            <li><strong>Proactive Context Check:</strong> ASK USER immediately (don't assume or guess)</li>
            <li><strong>Context Acquisition:</strong> After user clarifies, use hal-context-finder sub-agent for discovery</li>
            <li><strong>Answer with Transparency:</strong> State basis of answer, offer to check additional sources if needed</li>
        </ol>

        <h4>RAM Status Reporting</h4>

        <p>System warnings provide exact token usage after every tool invocation:</p>
        <pre>&lt;system_warning&gt;Token usage: 33006/200000; 163896 remaining&lt;/system_warning&gt;</pre>

        <p><strong>Reporting Protocol:</strong></p>
        <ul>
            <li>ALWAYS use latest system warning token count (not estimates)</li>
            <li>Calculate exact percentage: tokens_used / 200000</li>
            <li>Report format: "RAM: X.X% (XXk/200k tokens) - [ZONE]"</li>
            <li>NEVER estimate or guess - only report measured values</li>
        </ul>

        <div class="warning-box">
            <strong>‚ö†Ô∏è CRITICAL LIMITATION - Token Reporting Lag</strong>
            <p>The CPU's internal token visibility lags significantly behind the true state visible in the Claude Code UI. This is an architectural constraint with serious operational implications.</p>

            <h5>The Discrepancy:</h5>
            <ul>
                <li>System warnings reflect token state <strong>BEFORE</strong> the CPU's response generation</li>
                <li>By the time CPU reports "70% used," actual usage may be 90%+</li>
                <li>Discrepancy can be ~20-50k tokens (10-25% of total capacity)</li>
                <li>This is not a bug - it's an inherent measurement timing issue</li>
            </ul>

            <h5>Operational Protocol:</h5>
            <table>
                <thead>
                    <tr>
                        <th>Rule</th>
                        <th>Specification</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>User is authoritative</strong></td>
                        <td>Claude Code UI shows true real-time token count - trust user's reports over system warnings</td>
                    </tr>
                    <tr>
                        <td><strong>CPU reports are lower bounds</strong></td>
                        <td>Treat internal estimates as minimum usage only - actual usage is always higher</td>
                    </tr>
                    <tr>
                        <td><strong>User warning threshold</strong></td>
                        <td>User will alert CPU when UI shows ‚â§12% remaining (~24k tokens)</td>
                    </tr>
                    <tr>
                        <td><strong>CPU safety margin</strong></td>
                        <td>Add 15-20% safety margin to internal estimates when making decisions</td>
                    </tr>
                    <tr>
                        <td><strong>Conflict resolution</strong></td>
                        <td>If user says "6% remaining" and CPU sees "30% remaining," user is correct - act on user's data</td>
                    </tr>
                </tbody>
            </table>

            <h5>Why This Matters:</h5>
            <p>The CPU cannot accurately self-monitor its RAM state. The asymmetry means:</p>
            <ul>
                <li><strong>Users must actively monitor</strong> - CPU cannot reliably detect danger zone</li>
                <li><strong>Conservative planning required</strong> - CPU should not fill RAM to 80% based on internal view</li>
                <li><strong>User alerts are critical signals</strong> - When user reports low RAM, immediate action required regardless of CPU's internal view</li>
                <li><strong>No automated enforcement</strong> - System cannot prevent CPU from overrunning RAM based on lagged measurements</li>
            </ul>

            <p><strong>Architectural Note:</strong> This is inherent to the current Claude Code implementation. The CPU lacks real-time visibility into its own RAM state, similar to a processor without direct access to its own performance counters. The user's UI serves as the external monitoring system that provides ground truth.</p>
        </div>

        <h4>Component Inventory Summary</h4>

        <table>
            <tr>
                <th>Component Type</th>
                <th>Count</th>
                <th>Details</th>
            </tr>
            <tr>
                <td>CPU Registers</td>
                <td>21</td>
                <td>5 categories: Control (4), Memory (5), State (5), Status (4), Data (3)</td>
            </tr>
            <tr>
                <td>HAL Commands</td>
                <td>9</td>
                <td>Session management, diagnostics, infrastructure, context management, development</td>
            </tr>
            <tr>
                <td>Agents (Co-Processors)</td>
                <td>5</td>
                <td>Research, context finding, maintenance, documentation, validation</td>
            </tr>
            <tr>
                <td>MCP Servers</td>
                <td>4</td>
                <td>omnisearch (enabled), filesystem (enabled), ide (available), stdio (configured)</td>
            </tr>
            <tr>
                <td>External Tools</td>
                <td>2</td>
                <td>Gemini CLI (1M context), Docker (28.4.0)</td>
            </tr>
            <tr>
                <td>Indexed Directories</td>
                <td>6</td>
                <td>Hierarchical file system indexes</td>
            </tr>
            <tr>
                <td>Library Categories</td>
                <td>4</td>
                <td>Internal (development, research, system), External (Fabric - 227 patterns)</td>
            </tr>
            <tr>
                <td>External Libraries</td>
                <td>1</td>
                <td>Fabric (227 patterns, 292 files)</td>
            </tr>
            <tr>
                <td>Library Patterns Indexed</td>
                <td>226</td>
                <td>AI workflow patterns from Fabric library</td>
            </tr>
        </table>
    </div>

    <div class="cross-references">
        <h4>Related Sections</h4>
        <ul>
            <li><a href="#memory-architecture">Memory Architecture</a> - File system structure and organization</li>
            <li><a href="#register-architecture">Register Architecture</a> - Detailed register specifications and usage</li>
            <li><a href="#operating-principles">Operating Principles</a> - How components work together</li>
            <li><a href="#command-reference">Command Reference</a> - Individual command specifications</li>
            <li><a href="#agent-reference">Agent Reference</a> - Agent capabilities and usage</li>
            <li><a href="#mcp-integration">MCP Integration</a> - MCP server details and configuration</li>
            <li><a href="#ram-management">RAM Management</a> - Resource management protocols</li>
            <li><a href="#session-management">Session Management</a> - State persistence and continuity</li>
        </ul>
    </div>
</div>
            </section>

            <!-- Section 8: Register Architecture -->
            <section id="register-architecture" data-status="complete" data-priority="2" 
         data-sources=".claude/commands/HAL-register-dump.md" data-estimated-tokens="10000" 
         data-dependencies="architecture-overview">
  
  <div class="meta-guidance" style="display:none;">
    <!-- 
    MAINTENANCE GUIDANCE FOR AI ASSISTANTS
    
    This section documents the complete HAL8000-Assistant register architecture (21 registers across 5 categories).
    
    When updating this section:
    1. Register definitions sourced from .claude/commands/HAL-register-dump.md
    2. Keep the register table synchronized with command implementation
    3. All 21 registers must be documented (no omissions)
    4. Update examples to reflect actual system behavior
    5. Maintain consistency with CLAUDE.md register references
    
    Structure integrity:
    - Five register categories (Control, Memory, State, Status, Data)
    - Complete register table with 6 columns
    - Usage patterns showing boot, runtime, error, and monitoring scenarios
    - Command reference for /HAL-register-dump
    
    Token budget: ~10,000 tokens (comprehensive reference)
    Dependencies: Must align with Architecture Overview section
    
    Last verified: 2025-10-10
    -->
  </div>

  <h2>8. Register Architecture</h2>

  <h3>8.1 Overview</h3>
  
  <p>
    The HAL8000-Assistant CPU maintains 21 virtual registers that track the system's immediate working state. These registers represent the CPU's working context‚Äîanalogous to hardware registers in physical processors. Unlike physical registers stored in silicon, HAL8000-Assistant registers are virtual constructs aggregated from multiple sources: runtime state, file system data, context window metadata, and system conditions.
  </p>

  <p>
    Registers serve multiple critical functions:
  </p>
  <ul>
    <li><strong>State tracking:</strong> Monitor current execution state, loaded resources, and system health</li>
    <li><strong>Performance management:</strong> Track RAM usage and determine operational zones (SAFE/CAUTION/DANGER)</li>
    <li><strong>Error handling:</strong> Capture and report error conditions with detailed diagnostics</li>
    <li><strong>Session continuity:</strong> Maintain session context across operations and enable checkpointing</li>
    <li><strong>Introspection:</strong> Provide low-level visibility into CPU state for debugging and learning</li>
  </ul>

  <p>
    The register architecture embodies the assembly language principle of <strong>explicit control</strong>‚Äîthe system state is always inspectable and never hidden. Users can view complete register state at any time using the <code>/HAL-register-dump</code> command.
  </p>

  <figure class="diagram">
    <img src="assets/register-categories.svg" alt="HAL8000-Assistant Register Architecture - 21 registers organized in 5 categories" style="width: 100%; max-width: 1200px;">
    <figcaption><strong>Figure 10:</strong> HAL8000-Assistant Register Architecture‚Äî21 registers organized into 5 functional categories (Control, Memory, State, Status, Data)</figcaption>
  </figure>

  <h3>8.2 Register Categories</h3>

  <h4>8.2.1 Control Registers</h4>
  <p>
    Control registers govern CPU execution flow and operational state. These registers determine how the CPU processes instructions, tracks execution progress, and maintains operational status.
  </p>
  <ul>
    <li><strong>CPU_STATUS:</strong> Overall CPU operational state (OPERATIONAL, DEGRADED, ERROR, HALTED)</li>
    <li><strong>PC (Program Counter):</strong> Pointer to next instruction to execute (typically null in interactive mode)</li>
    <li><strong>SP (Stack Pointer):</strong> Current execution context depth (command nesting level)</li>
    <li><strong>BP (Base Pointer):</strong> Base execution context reference (session start context)</li>
    <li><strong>IR (Instruction Register):</strong> Current instruction being executed (user's command or operation)</li>
  </ul>

  <h4>8.2.2 Memory Registers</h4>
  <p>
    Memory registers track what data and instructions are currently loaded into the CPU's context window (RAM). These registers are critical for resource management and preventing context overflow.
  </p>
  <ul>
    <li><strong>MAR (Memory Address Register):</strong> Last file path accessed</li>
    <li><strong>MDR (Memory Data Register):</strong> Data from last file read operation</li>
    <li><strong>CONTEXT_MANIFEST:</strong> List of all files currently loaded in RAM (with token counts)</li>
    <li><strong>LOADED_COMMANDS:</strong> Commands currently loaded and available for execution</li>
  </ul>

  <h4>8.2.3 State Registers</h4>
  <p>
    State registers maintain persistent session context and operational phase. These registers bridge session boundaries and enable continuity across CPU restarts.
  </p>
  <ul>
    <li><strong>LAST_SESSION:</strong> Identifier/path of most recent session checkpoint</li>
    <li><strong>NEXT_ACTION:</strong> Planned next operation (guides resumption after boot)</li>
    <li><strong>SYSTEM_PHASE:</strong> Current project phase or system state (e.g., "development", "production-ready")</li>
    <li><strong>USER_INTENT:</strong> Interpreted user goal or objective for current operation</li>
  </ul>

  <h4>8.2.4 Status Registers</h4>
  <p>
    Status registers monitor system health, resource utilization, and error conditions. These registers enable proactive resource management and diagnostic capabilities.
  </p>
  <ul>
    <li><strong>RAM_USAGE:</strong> Current context window token count (absolute tokens used)</li>
    <li><strong>RAM_ZONE:</strong> Performance zone based on RAM usage (SAFE: 0-80%, CAUTION: 80-90%, DANGER: 90-100%)</li>
    <li><strong>ERROR_FLAG:</strong> Boolean indicating whether an error has occurred</li>
    <li><strong>ERROR_CODE:</strong> Detailed error message or diagnostic code (null when ERROR_FLAG=false)</li>
    <li><strong>OPERATION_RESULT:</strong> Result/status of most recent operation</li>
  </ul>

  <h4>8.2.5 Data Registers</h4>
  <p>
    Data registers hold intermediate computation results and working data during operation execution. These registers function as scratch space for CPU operations.
  </p>
  <ul>
    <li><strong>ACCUMULATOR:</strong> Primary register for computation results and operation outputs</li>
    <li><strong>DATA_REGISTER:</strong> Secondary data storage for complex operations</li>
    <li><strong>TEMP_REGISTER:</strong> Temporary storage for intermediate values</li>
    <li><strong>INDEX_REGISTER:</strong> Loop counters, array indices, and iteration state</li>
  </ul>

  <h3>8.3 Complete Register Reference</h3>

  <table>
    <thead>
      <tr>
        <th>Register Name</th>
        <th>Category</th>
        <th>Purpose</th>
        <th>Type/Values</th>
        <th>Updated When</th>
        <th>Example Value</th>
      </tr>
    </thead>
    <tbody>
      <!-- Control Registers -->
      <tr>
        <td><strong>CPU_STATUS</strong></td>
        <td>Control</td>
        <td>Overall CPU operational state</td>
        <td>OPERATIONAL | DEGRADED | ERROR | HALTED</td>
        <td>Boot, error conditions, system state changes</td>
        <td><code>OPERATIONAL</code></td>
      </tr>
      <tr>
        <td><strong>PC</strong></td>
        <td>Control</td>
        <td>Program counter (next instruction pointer)</td>
        <td>String (file path) | null</td>
        <td>Sequential execution, control flow changes</td>
        <td><code>null</code> (interactive mode)</td>
      </tr>
      <tr>
        <td><strong>SP</strong></td>
        <td>Control</td>
        <td>Stack pointer (execution context depth)</td>
        <td>Integer (nesting level)</td>
        <td>Command invocation, return from command</td>
        <td><code>0</code> (root level)</td>
      </tr>
      <tr>
        <td><strong>BP</strong></td>
        <td>Control</td>
        <td>Base pointer (session context base)</td>
        <td>Integer (token offset)</td>
        <td>Session start, context reset</td>
        <td><code>8432</code></td>
      </tr>
      <tr>
        <td><strong>IR</strong></td>
        <td>Control</td>
        <td>Instruction register (current instruction)</td>
        <td>String (command/operation)</td>
        <td>Every command execution</td>
        <td><code>"Show register state"</code></td>
      </tr>

      <!-- Memory Registers -->
      <tr>
        <td><strong>MAR</strong></td>
        <td>Memory</td>
        <td>Memory address register (last accessed path)</td>
        <td>String (absolute file path)</td>
        <td>Every file read/write operation</td>
        <td><code>"/mnt/d/~HAL8000-Assistant/.claude/state.json"</code></td>
      </tr>
      <tr>
        <td><strong>MDR</strong></td>
        <td>Memory</td>
        <td>Memory data register (last read data)</td>
        <td>String (file contents) | null</td>
        <td>After successful file read</td>
        <td><code>"{\"timestamp\":\"2025-10-04T14:30:00Z\"...}"</code></td>
      </tr>
      <tr>
        <td><strong>CONTEXT_MANIFEST</strong></td>
        <td>Memory</td>
        <td>List of all files loaded in context</td>
        <td>Array of objects {path, tokens, timestamp}</td>
        <td>File loads, context modifications</td>
        <td><code>[{path:"CLAUDE.md", tokens:15234}, ...]</code></td>
      </tr>
      <tr>
        <td><strong>LOADED_COMMANDS</strong></td>
        <td>Memory</td>
        <td>Commands currently loaded and available</td>
        <td>Array of strings (command names)</td>
        <td>Command file loads</td>
        <td><code>["HAL-session-end", "HAL-register-dump"]</code></td>
      </tr>

      <!-- State Registers -->
      <tr>
        <td><strong>LAST_SESSION</strong></td>
        <td>State</td>
        <td>Most recent session checkpoint identifier</td>
        <td>String (session file path)</td>
        <td>Session end, boot from state.json</td>
        <td><code>".claude/sessions/2025-10-04-1305-architecture.md"</code></td>
      </tr>
      <tr>
        <td><strong>NEXT_ACTION</strong></td>
        <td>State</td>
        <td>Planned next operation or continuation point</td>
        <td>String (action description)</td>
        <td>Session checkpoints, explicit user planning</td>
        <td><code>"Complete register architecture documentation"</code></td>
      </tr>
      <tr>
        <td><strong>SYSTEM_PHASE</strong></td>
        <td>State</td>
        <td>Current project/system phase</td>
        <td>String (phase identifier)</td>
        <td>Phase transitions, major milestones</td>
        <td><code>"production-ready"</code></td>
      </tr>
      <tr>
        <td><strong>USER_INTENT</strong></td>
        <td>State</td>
        <td>Interpreted user goal for current operation</td>
        <td>String (goal description)</td>
        <td>Command decode phase, user interaction</td>
        <td><code>"Inspect CPU register state for debugging"</code></td>
      </tr>

      <!-- Status Registers -->
      <tr>
        <td><strong>RAM_USAGE</strong></td>
        <td>Status</td>
        <td>Current context window token count</td>
        <td>Integer (tokens used)</td>
        <td>Continuous (after every operation)</td>
        <td><code>58432</code></td>
      </tr>
      <tr>
        <td><strong>RAM_ZONE</strong></td>
        <td>Status</td>
        <td>Performance zone classification</td>
        <td>SAFE | CAUTION | DANGER (with percentage)</td>
        <td>Continuous (derived from RAM_USAGE)</td>
        <td><code>"SAFE (29%)"</code></td>
      </tr>
      <tr>
        <td><strong>ERROR_FLAG</strong></td>
        <td>Status</td>
        <td>Error condition indicator</td>
        <td>Boolean (true | false)</td>
        <td>Operation failures, error detection</td>
        <td><code>false</code></td>
      </tr>
      <tr>
        <td><strong>ERROR_CODE</strong></td>
        <td>Status</td>
        <td>Detailed error diagnostic information</td>
        <td>String (error message) | null</td>
        <td>When ERROR_FLAG becomes true</td>
        <td><code>null</code> or <code>"File not found: /path/to/file"</code></td>
      </tr>
      <tr>
        <td><strong>OPERATION_RESULT</strong></td>
        <td>Status</td>
        <td>Result of most recent operation</td>
        <td>String (status message) | null</td>
        <td>After every operation completion</td>
        <td><code>"Command file created successfully"</code></td>
      </tr>

      <!-- Data Registers -->
      <tr>
        <td><strong>ACCUMULATOR</strong></td>
        <td>Data</td>
        <td>Primary computation result storage</td>
        <td>Any type (operation-dependent)</td>
        <td>During operation execution</td>
        <td><code>"Executing register dump"</code></td>
      </tr>
      <tr>
        <td><strong>DATA_REGISTER</strong></td>
        <td>Data</td>
        <td>Secondary data storage for complex operations</td>
        <td>Any type (operation-dependent)</td>
        <td>Multi-step operations</td>
        <td><code>[...array of intermediate results...]</code></td>
      </tr>
      <tr>
        <td><strong>TEMP_REGISTER</strong></td>
        <td>Data</td>
        <td>Temporary storage for intermediate values</td>
        <td>Any type (transient)</td>
        <td>During operation execution (cleared after)</td>
        <td><code>null</code> (when idle)</td>
      </tr>
      <tr>
        <td><strong>INDEX_REGISTER</strong></td>
        <td>Data</td>
        <td>Loop counters and iteration state</td>
        <td>Integer | null</td>
        <td>During iterative operations</td>
        <td><code>null</code> or <code>5</code> (iteration 5)</td>
      </tr>
    </tbody>
  </table>

  <h3>8.4 Register Usage Patterns</h3>

  <h4>8.4.1 Boot Time Initialization</h4>
  <p>
    When the HAL8000-Assistant CPU boots, registers are initialized in a specific sequence:
  </p>
  <ol>
    <li><strong>Control registers:</strong> CPU_STATUS set to OPERATIONAL, PC/SP/BP reset, IR cleared</li>
    <li><strong>Memory registers:</strong> CONTEXT_MANIFEST initialized with BIOS (CLAUDE.md), MAR/MDR cleared</li>
    <li><strong>State registers:</strong> Values loaded from <code>.claude/state.json</code> (LAST_SESSION, NEXT_ACTION, SYSTEM_PHASE)</li>
    <li><strong>Status registers:</strong> RAM_USAGE calculated, RAM_ZONE determined, ERROR_FLAG=false</li>
    <li><strong>Data registers:</strong> All cleared (null values)</li>
  </ol>

  <pre><code>BOOT SEQUENCE REGISTER STATES:
  
[T=0ms] Power On
  CPU_STATUS     ‚Üí UNINITIALIZED
  All registers  ‚Üí undefined

[T=50ms] BIOS Load
  CPU_STATUS     ‚Üí BOOTING
  MAR            ‚Üí "/mnt/d/~HAL8000-Assistant/CLAUDE.md"
  MDR            ‚Üí [BIOS contents]
  CONTEXT_MANIFEST ‚Üí [{path: "CLAUDE.md", tokens: 15234}]
  RAM_USAGE      ‚Üí 15234

[T=100ms] State Load
  MAR            ‚Üí "/mnt/d/~HAL8000-Assistant/.claude/state.json"
  MDR            ‚Üí [state.json contents]
  LAST_SESSION   ‚Üí ".claude/sessions/2025-10-04-1305-architecture.md"
  NEXT_ACTION    ‚Üí "Resume architecture documentation"
  SYSTEM_PHASE   ‚Üí "production-ready"
  RAM_USAGE      ‚Üí 16042

[T=150ms] Boot Complete
  CPU_STATUS     ‚Üí OPERATIONAL
  RAM_ZONE       ‚Üí "SAFE (8%)"
  ERROR_FLAG     ‚Üí false
  IR             ‚Üí null (awaiting instruction)
</code></pre>

  <h4>8.4.2 During Operation Execution</h4>
  <p>
    As operations execute, registers are continuously updated to reflect current state:
  </p>
  <ul>
    <li><strong>IR:</strong> Updated with each new command (user input or programmatic invocation)</li>
    <li><strong>MAR/MDR:</strong> Updated with every file access operation</li>
    <li><strong>CONTEXT_MANIFEST:</strong> Appended when new files are loaded</li>
    <li><strong>RAM_USAGE/RAM_ZONE:</strong> Recalculated after context modifications</li>
    <li><strong>ACCUMULATOR/DATA_REGISTER:</strong> Used for intermediate computation results</li>
    <li><strong>OPERATION_RESULT:</strong> Updated upon operation completion</li>
  </ul>

  <figure class="diagram">
    <img src="assets/register-flow-during-operation.svg" alt="Register State Flow During File Read Operation" style="width: 100%; max-width: 1200px;">
    <figcaption><strong>Figure 11:</strong> Register State Flow During File Read Operation‚Äî7 stages flowing left-to-right across two rows showing register updates at each phase</figcaption>
  </figure>

  <h4>8.4.3 Error Handling</h4>
  <p>
    When errors occur, the status registers capture complete diagnostic state:
  </p>
  <pre><code>NORMAL OPERATION ‚Üí ERROR STATE TRANSITION

[Before Error]
  CPU_STATUS       ‚Üí OPERATIONAL
  ERROR_FLAG       ‚Üí false
  ERROR_CODE       ‚Üí null
  OPERATION_RESULT ‚Üí "Previous operation successful"

[Error Occurs: File Not Found]
  ERROR_FLAG       ‚Üí true
  ERROR_CODE       ‚Üí "File not found: /mnt/d/~HAL8000-Assistant/missing.txt"
  CPU_STATUS       ‚Üí OPERATIONAL (still operational, but error flagged)
  OPERATION_RESULT ‚Üí "Read operation failed"
  MAR              ‚Üí "/mnt/d/~HAL8000-Assistant/missing.txt" (attempted path)
  MDR              ‚Üí null (no data read)

[Error Reported to User]
  CPU provides error details from ERROR_CODE
  Suggests recovery actions

[Error Cleared]
  ERROR_FLAG       ‚Üí false
  ERROR_CODE       ‚Üí null
  CPU_STATUS       ‚Üí OPERATIONAL
  Ready for next operation
</code></pre>

  <h4>8.4.4 Performance Monitoring</h4>
  <p>
    The CPU continuously monitors RAM usage and adjusts operational behavior based on RAM_ZONE:
  </p>
  <table>
    <thead>
      <tr>
        <th>RAM_ZONE</th>
        <th>Usage Range</th>
        <th>Behavior</th>
        <th>User Notification</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>SAFE</strong></td>
        <td>0-80% (0-160K tokens)</td>
        <td>Normal operation, load files freely</td>
        <td>None (silent operation)</td>
      </tr>
      <tr>
        <td><strong>CAUTION</strong></td>
        <td>80-90% (160K-180K tokens)</td>
        <td>Monitor closely, warn before loading large files, suggest checkpoint</td>
        <td>Warning when entering zone, recommendations provided</td>
      </tr>
      <tr>
        <td><strong>DANGER</strong></td>
        <td>90-100% (180K-200K tokens)</td>
        <td>Refuse large loads unless confirmed, urgent checkpoint recommended, performance may degrade</td>
        <td>Urgent warnings, explicit confirmation required for operations</td>
      </tr>
    </tbody>
  </table>

  <h3>8.5 Viewing Register State</h3>

  <h4>8.5.1 The /HAL-register-dump Command</h4>
  <p>
    The HAL8000-Assistant CPU provides the <code>/HAL-register-dump</code> command for complete register introspection. This read-only command displays all 21 registers organized by category, providing a comprehensive snapshot of CPU state.
  </p>

  <p><strong>Command Syntax:</strong></p>
  <pre><code>/HAL-register-dump</code></pre>
  <p>No arguments required. The command aggregates register state from multiple sources (runtime context, file system, system warnings) and generates formatted output.</p>

  <h4>8.5.2 Example Output</h4>
  <pre><code>================================================================================
                        HAL8000-Assistant REGISTER DUMP
================================================================================
Timestamp: 2025-10-04T15:30:45Z
Model: claude-sonnet-4-5-20250929

[CONTROL REGISTERS]
  PC (Program Counter)        : null
  IR (Instruction Register)   : Show register state
  EXEC_MODE                   : INTERACTIVE
  FLOW_STATE                  : Executing register dump command

[MEMORY REGISTERS]
  RAM_USAGE                   : 58,432 tokens
  RAM_CAPACITY                : 200,000 tokens
  RAM_REMAINING               : 141,568 tokens
  RAM_ZONE                    : SAFE (29% used)
  CONTEXT_MANIFEST            : 5 files loaded
    - CLAUDE.md
    - .claude/state.json
    - .claude/sessions/2025-10-04-1305-hal8000-architecture-implementation.md
    - data/research/04-claude-code-runtime-constraints.md
    - .claude/commands/HAL-register-dump.md

[STATE REGISTERS]
  SESSION_ID                  : .claude/sessions/2025-10-04-1305-hal8000-architecture-implementation.md
  SESSION_START               : 2025-10-04T14:23:15Z
  SESSION_DURATION            : 1h 7m 30s
  CHECKPOINT_STATUS           :
    - Last checkpoint         : 2025-10-04T13:05:18Z
    - Checkpoint file         : .claude/sessions/2025-10-04-1305-hal8000-architecture-implementation.md
    - Changes since checkpoint: true
  PHASE                       : register-architecture-complete
  LOADED_COMMANDS             : 2 commands
    - HAL-session-end
    - HAL-register-dump

[STATUS REGISTERS]
  CPU_STATUS                  : OPERATIONAL ‚úì
  RATE_LIMIT_STATUS           :
    - Limited                 : false
    - Usage estimate          : ~15%
    - Reset cycle             : 5 hours
  ERROR_FLAG                  : false
  ERROR_CODE                  : null

[DATA REGISTERS]
  ACC (Accumulator)           : Executing register dump
  VARS (Session Variables)    : 4 variables
    - current_project         : HAL8000-Assistant architecture
    - architecture_type       : Modified von Neumann
    - depth_limit             : 3
    - phase                   : register-architecture-complete
  RESULT (Last Operation)     : Command file created successfully

================================================================================
                            SYSTEM STATUS: OPERATIONAL
RAM: SAFE | CPU: OPERATIONAL | Session: Active | Errors: None
================================================================================
</code></pre>

  <h4>8.5.3 Interpreting Register Dump Results</h4>
  <p>
    When analyzing register dump output, focus on these key indicators:
  </p>
  <ul>
    <li><strong>CPU_STATUS:</strong> Should be OPERATIONAL for normal operation. DEGRADED/ERROR/HALTED indicate system issues requiring attention.</li>
    <li><strong>RAM_ZONE:</strong> Primary performance indicator. SAFE allows normal work, CAUTION requires monitoring, DANGER demands immediate action.</li>
    <li><strong>CONTEXT_MANIFEST:</strong> Shows exactly what files are consuming context. Use to identify unexpectedly large loads or forgotten files.</li>
    <li><strong>ERROR_FLAG/ERROR_CODE:</strong> When true/non-null, indicates unresolved error condition requiring investigation.</li>
    <li><strong>SESSION_START/DURATION:</strong> Long session durations (>2 hours) may indicate need for checkpoint and context cleanup.</li>
    <li><strong>LOADED_COMMANDS:</strong> Verifies which commands are available without loading additional files.</li>
  </ul>

  <h4>8.5.4 Use Cases for Register Inspection</h4>
  <ul>
    <li><strong>Debugging:</strong> Check ERROR_FLAG/ERROR_CODE when operations fail unexpectedly</li>
    <li><strong>Resource monitoring:</strong> Track RAM_USAGE before loading large files or starting intensive operations</li>
    <li><strong>Session planning:</strong> Review CONTEXT_MANIFEST to determine if checkpoint is needed</li>
    <li><strong>System verification:</strong> Confirm CPU_STATUS and absence of errors during critical operations</li>
    <li><strong>Learning:</strong> Understand how the system works by observing register state changes during operations</li>
  </ul>

  <h3>8.6 Register Implementation Notes</h3>

  <h4>8.6.1 Virtual Register Model</h4>
  <p>
    Unlike physical CPU registers stored in dedicated hardware, HAL8000-Assistant registers are <strong>virtual constructs</strong>. The register file does not exist as a single data structure. Instead, registers are aggregated on-demand from multiple authoritative sources:
  </p>
  <ul>
    <li><strong>Runtime context:</strong> IR, ACCUMULATOR, TEMP_REGISTER (ephemeral, execution-specific)</li>
    <li><strong>System warnings:</strong> RAM_USAGE (extracted from <code>&lt;system_warning&gt;</code> blocks)</li>
    <li><strong>File system:</strong> LAST_SESSION, NEXT_ACTION, SYSTEM_PHASE (from <code>state.json</code>)</li>
    <li><strong>Calculated values:</strong> RAM_ZONE (derived from RAM_USAGE), SESSION_DURATION (calculated from SESSION_START)</li>
  </ul>
  <p>
    The <code>/HAL-register-dump</code> command reads these sources, performs calculations, and formats output. This approach ensures register values always reflect actual system state without requiring synchronization overhead.
  </p>

  <h4>8.6.2 Register Persistence</h4>
  <p>
    Register persistence varies by category:
  </p>
  <table>
    <thead>
      <tr>
        <th>Category</th>
        <th>Persistence</th>
        <th>Storage Location</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Control</td>
        <td>Volatile (session-scoped)</td>
        <td>Runtime context</td>
      </tr>
      <tr>
        <td>Memory</td>
        <td>Volatile (session-scoped)</td>
        <td>Runtime context, system warnings</td>
      </tr>
      <tr>
        <td>State</td>
        <td>Persistent (survives CPU restart)</td>
        <td><code>.claude/state.json</code></td>
      </tr>
      <tr>
        <td>Status</td>
        <td>Volatile (real-time)</td>
        <td>Calculated on-demand</td>
      </tr>
      <tr>
        <td>Data</td>
        <td>Volatile (operation-scoped)</td>
        <td>Runtime context</td>
      </tr>
    </tbody>
  </table>

  <h4>8.6.3 Performance Impact</h4>
  <p>
    The <code>/HAL-register-dump</code> command has minimal performance impact:
  </p>
  <ul>
    <li><strong>Read-only:</strong> Does not modify any system state</li>
    <li><strong>No file I/O:</strong> All data read from runtime context (except state.json already in RAM)</li>
    <li><strong>Context cost:</strong> Adds ~2-3K tokens to context window (the output text itself)</li>
    <li><strong>Calculation overhead:</strong> Negligible (simple arithmetic for derived values)</li>
  </ul>
  <p>
    Register dumps can be performed freely without concern for performance degradation.
  </p>

  <h3>8.7 Related Commands and Operations</h3>
  <ul>
    <li><strong>/HAL-session-end:</strong> Updates CHECKPOINT_STATUS, LAST_SESSION, and NEXT_ACTION registers during session checkpoint</li>
    <li><strong>File read operations:</strong> Update MAR, MDR, CONTEXT_MANIFEST, and RAM_USAGE</li>
    <li><strong>Error conditions:</strong> Set ERROR_FLAG and ERROR_CODE registers</li>
    <li><strong>Boot sequence:</strong> Initializes all registers from BIOS and state.json</li>
  </ul>

  <h3>8.8 Summary</h3>
  <p>
    The HAL8000-Assistant register architecture provides comprehensive, inspectable CPU state through 21 virtual registers organized into 5 functional categories. Registers enable:
  </p>
  <ul>
    <li>Complete visibility into system state (assembly language principle: explicit control)</li>
    <li>Proactive resource management via RAM_USAGE and RAM_ZONE monitoring</li>
    <li>Reliable error diagnosis through ERROR_FLAG/ERROR_CODE</li>
    <li>Session continuity via persistent state registers</li>
    <li>Low-level debugging and system introspection</li>
  </ul>
  <p>
    Users can inspect register state at any time using <code>/HAL-register-dump</code>, providing transparency and control over CPU operations. This design embodies the HAL8000-Assistant philosophy: the system should be understandable, inspectable, and under user control at all times.
  </p>

</section>

            <!-- Section 9: Operating Principles -->
            <section id="operating-principles" data-status="complete" data-priority="1" data-sources="CLAUDE.md:Operating Principles" data-estimated-tokens="12000" data-dependencies="architecture-overview">

    <h2>9. Operating Principles</h2>

    <div class="meta-guidance">
        TARGET: Explain how the system operates (architectural principles)
        AUDIENCE: All three (layered)
        KEY_POINTS: Modified von Neumann specifics, Unix philosophy application, Assembly principles, sub-agent protocol, resource management, context awareness
        TONE: Principled, instructional
        VISUALS: [DIAGRAM: Fetch-decode-execute cycle], [DIAGRAM: Sub-agent virtual memory model]
    </div>

    <div class="content">

        <h3>Overview</h3>

        <p>The operating principles define how the HAL8000-Assistant CPU functions at a fundamental level. These are not optional configurations‚Äîthey are architectural constants that persist across all sessions, defining the very nature of system behavior. Think of them as the laws of physics for this computational environment.</p>

        <p>These principles govern six critical operational domains:</p>
        <ul>
            <li><strong>Architectural foundations</strong> - Modified von Neumann architecture specifics</li>
            <li><strong>Unix philosophy</strong> - Design patterns and composition strategies</li>
            <li><strong>Assembly language principles</strong> - Explicit control and low-level visibility</li>
            <li><strong>Sub-agent protocol</strong> - Virtual memory extension through process isolation</li>
            <li><strong>Resource management</strong> - RAM allocation and checkpoint strategies</li>
            <li><strong>Context awareness</strong> - Proactive context detection and loading</li>
        </ul>

        <div class="note">
            <strong>Important:</strong> These principles execute automatically. The CPU doesn't choose whether to follow them‚Äîthey define how the CPU operates. They are BIOS-level instructions encoded at boot time.
        </div>

        <h3>Architectural Foundations</h3>

        <h4>Modified von Neumann Architecture</h4>

        <p>HAL8000-Assistant implements a modified von Neumann architecture with critical constraints that shape all operations:</p>

        <div class="principle-block">
            <h5>Append-Only RAM</h5>
            <p>The context window accumulates content‚Äîthere is no dynamic eviction within a session. Once a file is loaded, it remains in RAM until session termination. This is not a limitation; it's a fundamental characteristic that requires explicit management.</p>

            <h5>Session Boundaries as Garbage Collection</h5>
            <p>The only way to reclaim RAM is to end the session. This creates a hard boundary between operational periods and requires proactive session management to prevent resource exhaustion.</p>

            <h5>Selective Loading Mandatory</h5>
            <p>Every file load is a one-way commitment. You cannot unload data, so every loading decision must be deliberate. The CPU must evaluate necessity before every read operation.</p>

            <h5>State Persistence via File System</h5>
            <p>Unlike traditional RAM that maintains state in volatile memory, HAL8000-Assistant persists state through the file system. RAM is computational workspace; permanent state lives in files.</p>
        </div>

        <h4>Performance Zones (RAM_ZONE Register)</h4>

        <p>The system tracks RAM usage through three performance zones that trigger different operational modes:</p>

        <table class="performance-zones">
            <thead>
                <tr>
                    <th>Zone</th>
                    <th>Usage Range</th>
                    <th>Operational Mode</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>SAFE</strong></td>
                    <td>0-80%</td>
                    <td>Normal operation - load files freely, execute complex operations</td>
                </tr>
                <tr>
                    <td><strong>CAUTION</strong></td>
                    <td>80-90%</td>
                    <td>Monitor closely - prepare checkpoint, warn before loading large files</td>
                </tr>
                <tr>
                    <td><strong>DANGER</strong></td>
                    <td>90-100%</td>
                    <td>Checkpoint urgently - performance degraded, refuse loads unless critical</td>
                </tr>
            </tbody>
        </table>

        <h3>Unix Philosophy</h3>

        <p>HAL8000-Assistant applies Unix design principles to the context management domain, treating files and commands as composable units.</p>

        <h4>Core Tenets</h4>

        <ol>
            <li>
                <strong>Do one thing well</strong>
                <p>Each file, command, and component has a single responsibility. A command that manages sessions doesn't also search files. A research agent doesn't manage system state.</p>
            </li>

            <li>
                <strong>Build once, reuse always</strong>
                <p>Create reusable patterns, not one-off solutions. When you solve a problem, encode the solution as a command or library that can be invoked again.</p>
            </li>

            <li>
                <strong>Compose via interfaces</strong>
                <p>File I/O is the universal interface. Commands read files, write files, pipe output. Everything communicates through this common language.</p>
            </li>

            <li>
                <strong>Delegate specialized work</strong>
                <p>When a task requires specialized capabilities or extensive context, delegate to external programs (sub-agents) rather than handling it directly.</p>
            </li>

            <li>
                <strong>Simple, not complex</strong>
                <p>Maximum 3-level directory depth for internal code. Minimal abstractions. External libraries are exempt, but system code must remain simple.</p>
            </li>

            <li>
                <strong>Text streams</strong>
                <p>All data in plain text files. Human-readable, version-controllable, composable. No binary formats except external dependencies.</p>
            </li>
        </ol>

        <h4>Context Management Principle: "Reduce and Delegate"</h4>

        <p>Context is the most precious resource in HAL8000-Assistant. The "Reduce and Delegate" principle governs all context operations:</p>

        <div class="principle-block">
            <h5>Core Principle: Context is Precious</h5>
            <ul>
                <li>Every token loaded is permanent until session ends</li>
                <li>Delegate context-heavy tasks to specialized agents</li>
                <li>Create reusable patterns, not one-off solutions</li>
                <li>Return clean summaries, not raw data</li>
            </ul>

            <h5>Decision Framework</h5>
            <ul>
                <li><strong>Can I delegate this?</strong> ‚Üí Use sub-agent</li>
                <li><strong>Can I summarize this?</strong> ‚Üí Return summary, not full data</li>
                <li><strong>Can I persist this?</strong> ‚Üí Write to file for future sessions</li>
                <li><strong>Can I reuse this?</strong> ‚Üí Create pattern for future use</li>
            </ul>
        </div>

        <h3>Assembly Language Principles</h3>

        <p>HAL8000-Assistant operates with assembly-level explicitness and control. There are no hidden operations or implicit behaviors.</p>

        <div class="principle-list">
            <div class="principle-item">
                <h5>Explicit Control</h5>
                <p>No hidden operations. Every action is explicit, every component access is direct. The CPU doesn't perform background tasks or automatic optimizations.</p>
            </div>

            <div class="principle-item">
                <h5>Register Awareness</h5>
                <p>Track CPU state continuously via registers. Every operation can inspect and modify register state. Registers are always visible and accessible.</p>
            </div>

            <div class="principle-item">
                <h5>Sequential Execution</h5>
                <p>Fetch-decode-execute cycle proceeds linearly unless control flow explicitly changes. Instructions execute in order, one at a time, with full visibility.</p>
            </div>

            <div class="principle-item">
                <h5>One-to-One Mapping</h5>
                <p>Commands map directly to architectural operations. There's no interpretation layer or abstraction‚Äîa load command loads, a write command writes.</p>
            </div>

            <div class="principle-item">
                <h5>Low-Level Visibility</h5>
                <p>System state is inspectable at all times. You can dump registers, check RAM usage, inspect loaded files, examine error states‚Äînothing is hidden.</p>
            </div>
        </div>

        <h4>Fetch-Decode-Execute Cycle</h4>

        <p>Every instruction follows the classical assembly cycle:</p>

        <ol>
            <li><strong>Fetch</strong>: Read instruction (PC register points to next instruction location)</li>
            <li><strong>Decode</strong>: Parse instruction, determine operation type and parameters</li>
            <li><strong>Execute</strong>: Perform operation, update registers and state</li>
            <li><strong>Post-Execute</strong>: Check RAM_ZONE, update state, prepare for next instruction</li>
        </ol>

        <figure class="diagram">
            <img src="assets/fetch-decode-execute-cycle.svg" alt="Fetch-Decode-Execute Cycle" style="width: 100%; max-width: 1200px;">
            <figcaption><strong>Figure 12:</strong> Fetch-Decode-Execute Cycle‚Äîcompact horizontal layout showing the classical CPU instruction cycle with error handling, control flow changes, and feedback loops</figcaption>
        </figure>

        <h3>Sub-Agent Protocol (Virtual Memory Extension)</h3>

        <p>Sub-agents function as virtual memory for the HAL8000-Assistant system‚Äîthey extend total RAM capacity through process isolation, allowing context-heavy operations without polluting the main session.</p>

        <h4>Architectural Model</h4>

        <p>The sub-agent architecture works as follows:</p>

        <pre><code>Main Session (Limited RAM)
    ‚Üì delegate task
Sub-Agent (Fresh 200K RAM, isolated context)
    ‚Üì process heavy work (research, file navigation, analysis)
    ‚Üì returns clean summary (not raw data)
Main Session (RAM += summary only, not full processing cost)</code></pre>

        <figure class="diagram">
            <img src="assets/sub-agent-virtual-memory.svg" alt="Sub-Agent Virtual Memory Model" style="width: 100%; max-width: 1400px;">
            <figcaption><strong>Figure 13:</strong> Sub-Agent Virtual Memory Model‚Äîshowing RAM isolation, compression ratio (150K ‚Üí 5K), and how sub-agents extend main session capacity through process isolation</figcaption>
        </figure>

        <h4>Delegation Decision Framework</h4>

        <p><strong>ALWAYS delegate:</strong></p>
        <ul>
            <li>Web research (use <code>research-synthesizer</code>)</li>
            <li>System context discovery (use <code>hal-context-finder</code>)</li>
            <li>Large file analysis requiring extensive context</li>
            <li>Multi-step tasks needing &gt;30K tokens of intermediate data</li>
            <li>Any operation where input size &gt;&gt; output size</li>
        </ul>

        <p><strong>NEVER do directly if sub-agent available:</strong></p>
        <ul>
            <li>Loading raw web search results into main RAM</li>
            <li>Navigating and loading multiple system files exploratively</li>
            <li>Processing large datasets without summarization</li>
            <li>Extensive exploratory research with many sources</li>
        </ul>

        <h4>Sub-Agent Benefits</h4>

        <ul>
            <li><strong>Isolated 200K context</strong> - Doesn't pollute main session RAM</li>
            <li><strong>Automatic cleanup</strong> - Context freed after sub-agent completes</li>
            <li><strong>Specialized capabilities</strong> - Agents can have domain-specific tools</li>
            <li><strong>Returns only essentials</strong> - Summary, not raw data</li>
        </ul>

        <h4>Pattern Example: Research Task</h4>

        <div class="example-comparison">
            <div class="wrong-approach">
                <h5>‚ùå WRONG APPROACH:</h5>
                <pre><code>User: "Research quantum computing developments"
CPU: Uses WebSearch directly
     ‚Üí 50K raw results loaded to main RAM
     ‚Üí Main RAM: 60K + 50K = 110K</code></pre>
            </div>

            <div class="right-approach">
                <h5>‚úì RIGHT APPROACH:</h5>
                <pre><code>User: "Research quantum computing developments"
CPU: Delegates to research-synthesizer sub-agent
     Sub-agent: Uses 150K RAM processing sources
     Returns: 5K structured summary
     Main RAM: 60K + 5K = 65K (not 210K!)</code></pre>
            </div>
        </div>

        <h4>Creating Reusable Patterns</h4>

        <ul>
            <li>Document successful sub-agent patterns</li>
            <li>Build specialized agents for recurring tasks</li>
            <li>Each agent = one responsibility (Unix: do one thing well)</li>
            <li>Compose agents for complex workflows</li>
        </ul>

        <h3>Resource Management Protocol</h3>

        <p>Resource management in HAL8000-Assistant is explicit and proactive. The CPU must evaluate every resource-consuming operation before execution.</p>

        <h4>Before Loading Any File</h4>

        <p>Execute this decision protocol before every file load:</p>

        <ol>
            <li><strong>Check CONTEXT_MANIFEST register</strong> - Is this file already loaded?</li>
            <li><strong>Estimate token cost</strong> - How large is this file?</li>
            <li><strong>Calculate projected usage</strong> - RAM_USAGE + estimated_cost = ?</li>
            <li><strong>Evaluate RAM_ZONE after projected load:</strong>
                <ul>
                    <li>If remains SAFE: proceed with load</li>
                    <li>If enters CAUTION: warn user, suggest alternatives</li>
                    <li>If enters DANGER: refuse load unless user confirms critical necessity</li>
                </ul>
            </li>
        </ol>

        <h4>Proactive Checkpoint Triggers</h4>

        <p>Checkpoints (session saves) are triggered proactively based on these conditions:</p>

        <ul>
            <li>RAM_ZONE enters CAUTION (‚â•80%)</li>
            <li>Major work item completed (logical checkpoint)</li>
            <li>Before starting context-heavy operation</li>
            <li>User explicitly requests checkpoint</li>
        </ul>

        <h4>Selective Loading Discipline</h4>

        <ul>
            <li><strong>Load ONLY files needed for current task</strong> - No speculative loading</li>
            <li><strong>Never load "just in case"</strong> - Every load must have clear justification</li>
            <li><strong>Persist results to storage immediately</strong> - After computation, write to file for future sessions (data stays in current RAM but avoids re-computation later)</li>
            <li><strong>Track all loaded files</strong> - CONTEXT_MANIFEST register maintains the manifest</li>
        </ul>

        <h4>Reduce and Delegate Decision Tree</h4>

        <p>For every operation, ask:</p>

        <ul>
            <li><strong>Can I delegate this?</strong> ‚Üí Use sub-agent (isolate context)</li>
            <li><strong>Can I summarize this?</strong> ‚Üí Return summary, not full data</li>
            <li><strong>Can I persist this?</strong> ‚Üí Write to file for future sessions (avoids re-loading sources + re-computing)</li>
            <li><strong>Can I reuse this?</strong> ‚Üí Create pattern for future use</li>
        </ul>

        <h3>Context Awareness Protocol</h3>

        <p>Context awareness is about understanding the gap between what the user knows and what the CPU has loaded. The user has complete project knowledge; the CPU has only what's in current RAM.</p>

        <h4>Understanding the Context Hierarchy</h4>

        <ol>
            <li><strong>User's Mind:</strong> Complete project knowledge, intent, unstated assumptions, full context of all files and systems</li>
            <li><strong>Filesystem:</strong> All persistent data (vastly exceeds RAM capacity)</li>
            <li><strong>RAM:</strong> Current working context (limited, volatile, subset of filesystem)</li>
        </ol>

        <h4>Key Awareness Principles</h4>

        <ul>
            <li>User doesn't know what's in the CPU's RAM</li>
            <li>User assumes the CPU has their level of understanding</li>
            <li>User is "lazy" (efficient) - won't explicitly state what to load</li>
            <li>CPU must be PROACTIVE about detecting missing context</li>
        </ul>

        <h4>Step 1: Parse Question for Missing Context Signals</h4>

        <p>Signals that indicate missing context:</p>

        <ul>
            <li>User mentions specific file/path/component not in current RAM</li>
            <li>User references "that file", "the component", "this function" without clear antecedent</li>
            <li>User asks "which file has X?" (implies CPU should know the file set)</li>
            <li>User asks implementation details when CPU hasn't loaded implementation</li>
            <li>User uses project-specific terms/names not in current context</li>
            <li>Question is specific but CPU only has general knowledge</li>
        </ul>

        <h4>Step 2: Proactive Context Check</h4>

        <p>When missing context signals are detected:</p>

        <div class="protocol-block">
            <h5>ASK USER IMMEDIATELY:</h5>
            <pre><code>"I notice you're asking about [X]. To assist accurately:
 - Should I search the codebase for [term]?
 - Do you mean [specific file/path]?
 - Is this about [project/component]?
 Current context: [briefly state what I DO have loaded]"</code></pre>

            <h5>Purpose:</h5>
            <ul>
                <li>Prevent wrong assumptions</li>
                <li>Let user guide to right location (saves RAM)</li>
                <li>Make RAM limitations visible</li>
                <li>Get clarification before expensive operations</li>
            </ul>
        </div>

        <h4>Step 3: Context Acquisition (After User Clarifies)</h4>

        <p>Once user clarifies what to search/load:</p>

        <ol>
            <li>Use <code>hal-context-finder</code> sub-agent for discovery</li>
            <li>Load only essential files</li>
            <li>Report what was loaded: "I've loaded [X]. Proceeding..."</li>
        </ol>

        <h4>Step 4: Answer with Context Transparency</h4>

        <p>When providing answers:</p>

        <ul>
            <li><strong>State basis:</strong> "Based on [current context/loaded files]..."</li>
            <li><strong>If answer might benefit from more context:</strong> "I can answer with current files, but would you like me to also check [X] for completeness?"</li>
            <li><strong>If confident but haven't verified everything:</strong> "Based on [files loaded], the answer is [X]. I haven't checked [other areas] - should I?"</li>
        </ul>

        <h4>Anti-Patterns to Avoid</h4>

        <ul>
            <li>‚ùå Answering confidently when context is clearly insufficient</li>
            <li>‚ùå Loading files speculatively without asking</li>
            <li>‚ùå Assuming user knows what's in CPU's RAM</li>
            <li>‚ùå Waiting for user to tell CPU to search (be proactive)</li>
            <li>‚ùå Searching before clarifying what to search for</li>
        </ul>

        <h4>Context Awareness Examples</h4>

        <div class="example-comparison">
            <div class="wrong-approach">
                <h5>‚ùå Wrong:</h5>
                <pre><code>User: "Which file contains the authentication logic?"
CPU: [searches entire codebase with sub-agent without asking]</code></pre>
            </div>

            <div class="right-approach">
                <h5>‚úì Right:</h5>
                <pre><code>User: "Which file contains the authentication logic?"
CPU: "I don't currently have authentication files loaded. Should I search
     the codebase for authentication-related files? Or is there a specific
     directory/component I should check?"</code></pre>
            </div>
        </div>

        <div class="example-comparison">
            <div class="wrong-approach">
                <h5>‚ùå Wrong:</h5>
                <pre><code>User: "Fix the bug in that function"
CPU: [guesses which function and loads random file]</code></pre>
            </div>

            <div class="right-approach">
                <h5>‚úì Right:</h5>
                <pre><code>User: "Fix the bug in that function"
CPU: "I don't have enough context - which function do you mean? Could you
     point me to the file or function name?"</code></pre>
            </div>
        </div>

        <div class="example-single">
            <h5>‚úì Proactive Context Check:</h5>
            <pre><code>User: "How does the session handling work?"
CPU: "I can explain session handling at an architectural level based on
     CLAUDE.md currently in context, but I haven't loaded the actual session
     command implementation. Would you like me to load
     `.claude/commands/HAL-session-end.md` for implementation details?"</code></pre>
        </div>

        <h3>Summary</h3>

        <p>These six operating principles work together to create a coherent operational framework:</p>

        <ul>
            <li><strong>Architectural foundations</strong> establish the constraints (append-only RAM, session boundaries)</li>
            <li><strong>Unix philosophy</strong> provides the design patterns (modularity, composition, simplicity)</li>
            <li><strong>Assembly principles</strong> ensure explicit control and visibility</li>
            <li><strong>Sub-agent protocol</strong> extends capacity through isolation</li>
            <li><strong>Resource management</strong> prevents exhaustion through proactive monitoring</li>
            <li><strong>Context awareness</strong> bridges the gap between user knowledge and CPU state</li>
        </ul>

        <p>These are not guidelines to follow‚Äîthey are the fundamental operating characteristics of the system. They execute automatically at BIOS level and define how the HAL8000-Assistant CPU operates in every session.</p>

    </div>

</section>

            <!-- Part III: User Guide -->
            <div class="part-divider">
                <h1 class="part-header">Part III: User Guide</h1>
                <p class="part-description">Practical operations, workflows, and daily usage patterns</p>
            </div>

            <!-- Section 10: Quick Start -->
            <section id="quick-start" data-status="complete" data-priority="1" data-sources="CLAUDE.md:BIOS Boot Sequence" data-estimated-tokens="8000" data-dependencies="what-is-hal8000,architecture-overview">
    <h2>10. Quick Start</h2>

    <div class="meta-guidance">
        TARGET: Get new users operational quickly
        AUDIENCE: Users and Claude instances
        KEY_POINTS: First boot sequence, BIOS load, state.json, boot acknowledgment, ready state
        TONE: Tutorial, step-by-step
        VISUALS: [DIAGRAM: Boot sequence flowchart]
    </div>

    <div class="content">
        <h3>First Boot</h3>
        <p>Welcome to HAL8000-Assistant! This tutorial will guide you through your first boot sequence. Whether you're a user setting up the system or a Claude instance initializing, this process is mandatory and happens automatically on every new session.</p>

        <p>Think of this as the system's "power-on" routine. Just like a physical computer runs POST (Power-On Self-Test) and loads the operating system, HAL8000-Assistant executes a verified boot sequence to ensure all critical components are loaded and operational.</p>

        <div class="callout callout-important">
            <strong>Important:</strong> The boot sequence is MANDATORY and VERIFIED. It is not optional. Every new session must execute this sequence to ensure system integrity.
        </div>

        <h3>Boot Sequence Steps</h3>
        <p>The HAL8000-Assistant boot sequence consists of six essential steps. Let's walk through each one:</p>

        <h4>Step 1: System Initialization (BIOS Load)</h4>
        <p>The boot process begins by loading the BIOS (Basic Input/Output System) from <code>CLAUDE.md</code>. This file contains the fundamental instructions that define how the system operates.</p>

        <p>During this step, the CPU (Claude instance) establishes its core identity and understands:</p>
        <ul>
            <li>It is the CPU of the HAL8000-Assistant system</li>
            <li>The architecture follows Modified von Neumann principles</li>
            <li>The system has self-modifying code capabilities</li>
            <li>The boot sequence must be completed and verified</li>
        </ul>

        <div class="callout callout-info">
            <strong>For Users:</strong> You don't need to do anything during this step. It happens automatically when Claude loads your project.
        </div>

        <h4>Step 2: Load State (CORE - REQUIRED)</h4>
        <p>This is the most critical step. The system IMMEDIATELY reads <code>.claude/state.json</code> using the Read tool. This file is CORE‚Äîfailure to load it means system failure.</p>

        <p>The state file is parsed to extract:</p>
        <ul>
            <li><strong>timestamp:</strong> When the last session ended</li>
            <li><strong>active_session:</strong> Pointer to the last session file (if any)</li>
            <li><strong>context:</strong> Description of what the system was last working on</li>
            <li><strong>next_action:</strong> What should happen next</li>
        </ul>

        <p>These values are stored in CPU registers:</p>
        <ul>
            <li><code>LAST_SESSION</code> - Timestamp of last session</li>
            <li><code>NEXT_ACTION</code> - Recommended next action</li>
            <li><code>SYSTEM_PHASE</code> - Current development phase</li>
        </ul>

        <div class="callout callout-important">
            <strong>Verification Required:</strong> The CPU must cite specific values from the loaded state.json to prove it was actually read. For example: "phase: production-ready" or "timestamp: 2025-10-04T14:55:00Z".
        </div>

        <h4>Step 3: Note Available Session (DO NOT AUTO-LOAD)</h4>
        <p>If the <code>active_session</code> field exists in <code>state.json</code>, the system notes the session file path (e.g., <code>.claude/sessions/2025-10-04-1455-description.md</code>) but does NOT load it automatically.</p>

        <p><strong>Why not auto-load?</strong></p>
        <ul>
            <li>Keeps boot lightweight and saves RAM</li>
            <li>User may want to work on something different, not necessarily the last session</li>
            <li><code>state.json</code> provides a bookmark, not an auto-load mandate</li>
            <li>User can explicitly say "continue previous work" to load it, or start fresh</li>
        </ul>

        <div class="callout callout-info">
            <strong>For Users:</strong> If you want to continue from your last session, just say "resume" or "continue previous work" after boot completes.
        </div>

        <h4>Step 4: Structured Boot Acknowledgment (REQUIRED)</h4>
        <p>ONLY AFTER actually loading the required files, the system provides a structured acknowledgment showing its operational status:</p>

        <pre><code>‚úÖ HAL8000-Assistant CPU Operational
‚îú‚îÄ Architecture: Modified von Neumann
‚îú‚îÄ Phase: production-ready
‚îú‚îÄ Last Session: 2025-10-04T14:55:00Z
‚îú‚îÄ Session Available: 2025-10-04-1455-refman-work.md (not loaded - say "resume" to load)
‚îú‚îÄ Context: Working on Reference Manual section 10
‚îú‚îÄ Next Action: Continue documentation work or await new instructions
‚îú‚îÄ Registers: Initialized (see /HAL-register-dump for details)
‚îî‚îÄ RAM Zone: SAFE (current token usage: ~15%)

üü¢ Ready for instructions</code></pre>

        <p><strong>Boot Verification Rules:</strong></p>
        <ul>
            <li>NEVER claim files are loaded without actually using the Read tool</li>
            <li>ALWAYS cite specific content from loaded files as proof</li>
            <li>CLEARLY distinguish between core files (must load) and optional files (degraded mode on failure)</li>
        </ul>

        <h4>Step 5: Error Handling During Boot</h4>
        <p>The system has robust error handling for different types of boot failures:</p>

        <h5>Core File Failure (CRITICAL)</h5>
        <p><strong>Files:</strong> <code>CLAUDE.md</code> (BIOS), <code>.claude/state.json</code></p>
        <p><strong>Action:</strong> ABORT boot, report system failure, request user intervention</p>

        <h5>Optional File Failure (DEGRADED MODE)</h5>
        <p><strong>Files:</strong> Session files, command files, architecture docs</p>
        <p><strong>Action:</strong> WARN user, continue with reduced functionality, log degradation</p>

        <p>Example degraded boot acknowledgment:</p>
        <pre><code>‚ö†Ô∏è  HAL8000-Assistant CPU Operational (Degraded Mode)
‚îú‚îÄ Architecture: Modified von Neumann (from BIOS)
‚îú‚îÄ Phase: UNKNOWN (state.json load failed)
‚îú‚îÄ Session State: No session loaded (file not found)
‚îú‚îÄ Degradation: Running without state persistence
‚îî‚îÄ Recommendation: Check .claude/state.json integrity

üü° Ready for instructions (degraded mode)</code></pre>

        <h4>Step 6: Ready to Execute</h4>
        <p>Boot complete! The CPU status is now either:</p>
        <ul>
            <li><strong>OPERATIONAL:</strong> All core files loaded successfully</li>
            <li><strong>DEGRADED:</strong> Core files loaded but optional files failed</li>
        </ul>

        <p>The system is now awaiting user instructions or resume commands.</p>

        <figure class="diagram">
            <img src="assets/boot-sequence-flow.svg" alt="HAL8000-Assistant Boot Sequence" style="width: 100%; max-width: 1400px;">
            <figcaption><strong>Figure 14:</strong> HAL8000-Assistant Boot Sequence‚Äî6-step boot process with error handling showing paths to OPERATIONAL or DEGRADED modes based on file load success</figcaption>
        </figure>

        <h3>Understanding Boot Output</h3>
        <p>Let's break down the boot acknowledgment structure so you know what you're looking at:</p>

        <table>
            <thead>
                <tr>
                    <th>Field</th>
                    <th>Description</th>
                    <th>Example Value</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Architecture</strong></td>
                    <td>The system architecture type</td>
                    <td>Modified von Neumann</td>
                </tr>
                <tr>
                    <td><strong>Phase</strong></td>
                    <td>Current development/operational phase</td>
                    <td>production-ready</td>
                </tr>
                <tr>
                    <td><strong>Last Session</strong></td>
                    <td>Timestamp of most recent session</td>
                    <td>2025-10-04T14:55:00Z</td>
                </tr>
                <tr>
                    <td><strong>Session Available</strong></td>
                    <td>Session file that can be loaded (not auto-loaded)</td>
                    <td>2025-10-04-1455-refman-work.md</td>
                </tr>
                <tr>
                    <td><strong>Context</strong></td>
                    <td>Brief description of what was last being worked on</td>
                    <td>Working on Reference Manual section 10</td>
                </tr>
                <tr>
                    <td><strong>Next Action</strong></td>
                    <td>Recommended next step or awaiting instructions</td>
                    <td>Continue documentation work</td>
                </tr>
                <tr>
                    <td><strong>Registers</strong></td>
                    <td>Status of CPU registers (see /HAL-register-dump for details)</td>
                    <td>Initialized</td>
                </tr>
                <tr>
                    <td><strong>RAM Zone</strong></td>
                    <td>Current memory usage level (SAFE/CAUTION/DANGER)</td>
                    <td>SAFE (~15%)</td>
                </tr>
            </tbody>
        </table>

        <div class="callout callout-success">
            <strong>Green Light (üü¢):</strong> Means the system is ready to receive and execute your instructions.
        </div>

        <div class="callout callout-warning">
            <strong>Yellow Light (üü°):</strong> Means the system is operational but in degraded mode. Check the degradation notice for details.
        </div>

        <h3>Next Steps</h3>
        <p>Now that your HAL8000-Assistant system has completed its boot sequence, here's what you can do:</p>

        <h4>Continue Previous Work</h4>
        <p>If a session is available and you want to pick up where you left off:</p>
        <pre><code>User: "Resume previous session"
or
User: "Continue from last session"</code></pre>
        <p>The system will load the session file and restore your context.</p>

        <h4>Start Fresh Work</h4>
        <p>If you want to work on something new:</p>
        <pre><code>User: "Let's work on [your task]"</code></pre>
        <p>The system will start a new working context without loading the previous session.</p>

        <h4>Explore System State</h4>
        <p>Want to see detailed system information? Try these commands:</p>
        <ul>
            <li><code>/HAL-register-dump</code> - View all CPU register states</li>
            <li><code>/HAL-system-check</code> - Perform comprehensive system health check</li>
            <li><code>ls .claude/commands/</code> - List all available commands</li>
        </ul>

        <h4>Get Help</h4>
        <p>If you need guidance:</p>
        <ul>
            <li>Ask: "What can this system do?" for capabilities overview</li>
            <li>Ask: "Show me available commands" for command reference</li>
            <li>Ask: "How do I [task]?" for specific task guidance</li>
        </ul>

        <div class="callout callout-tip">
            <strong>Pro Tip:</strong> The boot acknowledgment shows your RAM usage. Keep an eye on this‚Äîwhen it reaches CAUTION (80%+), consider saving your session to free up memory for the next task.
        </div>

        <h4>Session Management</h4>
        <p>Before your session ends (either due to RAM limits or natural stopping point), you should save your state:</p>
        <pre><code>/HAL-session-end "brief description of what was accomplished"</code></pre>
        <p>This ensures continuity‚Äîthe next boot will be able to resume exactly where you left off.</p>

        <div class="callout callout-info">
            <strong>Remember:</strong> Each new Claude session starts with a fresh boot sequence. Sessions are how work persists across these boundaries. Think of sessions like save files in a video game‚Äîthey capture your progress so you can continue later.
        </div>

        <h3>Congratulations!</h3>
        <p>You've successfully completed your first HAL8000-Assistant boot and are ready to work. The system is designed to guide you through operations‚Äîdon't hesitate to ask questions or explore commands. Every session starts with this same reliable boot sequence, ensuring consistent and predictable system initialization.</p>

        <p>Ready? Let's get to work! üöÄ</p>
    </div>
</section>

            <!-- Section 11: Daily Operations -->
            <section id="daily-operations" data-status="complete" data-priority="2" 
         data-sources="CLAUDE.md" data-estimated-tokens="10000" 
         data-dependencies="quick-start">
    
    <div class="meta-guidance" style="display:none;">
        <!-- META-GUIDANCE FOR AI ASSISTANTS
        
        Purpose: Cookbook-style operational guide for day-to-day HAL8000-Assistant usage.
        
        Maintenance Notes:
        - Keep examples concrete and tested
        - Update command syntax if slash commands change
        - Add new patterns as they emerge from user sessions
        - Keep aligned with CLAUDE.md Operating Principles section
        - Examples should reference actual files in .claude/ structure
        
        Content Philosophy:
        - Cookbook format: clear recipes, not theory
        - Every procedure has concrete steps
        - Include both what to do AND what not to do (anti-patterns)
        - Focus on RAM management (critical operational concern)
        
        If updating:
        - Test command examples in actual HAL8000-Assistant instance
        - Verify file paths are accurate
        - Ensure procedures still align with boot sequence
        - Check that RAM zone thresholds haven't changed
        -->
    </div>

    <h2>11. Daily Operations</h2>
    
    <p>
        This section provides cookbook-style guidance for common HAL8000-Assistant operational tasks. 
        Each recipe includes step-by-step procedures, concrete examples, and best practices 
        learned from production usage.
    </p>

    <h3>11.1 Running Commands</h3>
    
    <p>
        HAL8000-Assistant commands use the slash command pattern for system operations. Commands are 
        stored as markdown files in <code>.claude/commands/</code> and invoked via slash syntax.
    </p>

    <h4>Command Syntax</h4>
    <pre><code>/HAL-command-name [arguments]</code></pre>

    <h4>Available System Commands</h4>
    <table>
        <thead>
            <tr>
                <th>Command</th>
                <th>Purpose</th>
                <th>When to Use</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>/HAL-session-end "description"</code></td>
                <td>Save session state before RAM wipe</td>
                <td>End of work session, RAM &gt; 80%, context full</td>
            </tr>
            <tr>
                <td><code>/HAL-register-dump</code></td>
                <td>Display CPU register states</td>
                <td>Debugging, status checks, verify boot state</td>
            </tr>
            <tr>
                <td><code>/HAL-system-check</code></td>
                <td>Validate system health</td>
                <td>Daily check, after errors, verify integrity</td>
            </tr>
            <tr>
                <td><code>/HAL-context-find "query"</code></td>
                <td>Discover and load system context</td>
                <td>Need files but don't know location, save RAM</td>
            </tr>
            <tr>
                <td><code>/HAL-index-update</code></td>
                <td>Rebuild file system indexes</td>
                <td>After adding files, structure changes</td>
            </tr>
            <tr>
                <td><code>/HAL-library-update</code></td>
                <td>Update external libraries</td>
                <td>Package updates, new library versions</td>
            </tr>
            <tr>
                <td><code>/HAL-CC-check</code></td>
                <td>Validate Claude Code compatibility</td>
                <td>Detect deprecated tools, API changes, compatibility audits</td>
            </tr>
            <tr>
                <td><code>/HAL-mcp-control [action] [server]</code></td>
                <td>Control MCP servers dynamically</td>
                <td>Enable/disable MCP servers, check status, optimize RAM</td>
            </tr>
            <tr>
                <td><code>/HAL-refman [action]</code></td>
                <td>Manage reference manual development</td>
                <td>Write sections, check status, export manual</td>
            </tr>
        </tbody>
    </table>

    <h4>Example: Running a Health Check</h4>
    <pre><code>User: /HAL-system-check

CPU: [Executes system check]
‚úÖ System Health Check Complete
‚îú‚îÄ BIOS: Loaded (CLAUDE.md)
‚îú‚îÄ State: Valid (.claude/state.json)
‚îú‚îÄ Commands: 6 available
‚îú‚îÄ Agents: 2 operational
‚îú‚îÄ RAM Zone: SAFE (45%)
‚îî‚îÄ Indexes: Current

üü¢ All systems operational</code></pre>

    <h3>11.2 System Health Checks</h3>
    
    <p>
        Regular health verification ensures system integrity and catches issues early.
    </p>

    <h4>Daily Health Check Procedure</h4>
    <ol>
        <li>
            <strong>Verify boot completion:</strong>
            <pre><code>Check CPU acknowledgment includes:
- Architecture loaded from state.json
- Phase and timestamp cited
- Registers initialized
- RAM zone reported</code></pre>
        </li>
        <li>
            <strong>Run system check:</strong>
            <pre><code>/HAL-system-check</code></pre>
        </li>
        <li>
            <strong>Check state.json integrity:</strong>
            <pre><code>Verify state.json contains:
- Valid timestamp (ISO 8601)
- Architecture type specified
- Phase field present
- Context description current</code></pre>
        </li>
        <li>
            <strong>Monitor RAM baseline:</strong>
            <pre><code>Post-boot RAM should be in SAFE zone (&lt; 80%)
If CAUTION immediately after boot: investigate loaded context

RAM Reporting: Use exact measurements from system warnings
- Check latest &lt;system_warning&gt; for token usage
- Calculate: tokens_used / 200000 = percentage
- Report: "RAM: X.X% (XXk/200k tokens) - [ZONE]"
- Never estimate - always use measured values</code></pre>
        </li>
    </ol>

    <div class="insight-box">
        <strong>RAM Monitoring Best Practice:</strong> Always reference the latest system warning token count
        when reporting RAM status. System warnings appear after each tool invocation and provide exact measurements.
        Users rely on these reports for critical decisions - estimated values can lead to premature checkpoints
        or RAM exhaustion.
    </div>

    <h4>Periodic Checks (Weekly)</h4>
    <ul>
        <li>Review <code>.claude/system.log</code> for error patterns</li>
        <li>Verify session files are being created properly</li>
        <li>Check that indexes are current: <code>/HAL-index-update</code></li>
        <li>Validate command files are accessible: <code>ls .claude/commands/</code></li>
    </ul>

    <h4>Warning Signs</h4>
    <table>
        <thead>
            <tr>
                <th>Symptom</th>
                <th>Likely Cause</th>
                <th>Resolution</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Boot reports degraded mode</td>
                <td>state.json corrupted or missing</td>
                <td>Check file integrity, restore from backup</td>
            </tr>
            <tr>
                <td>Commands not found</td>
                <td>.claude/commands/ structure changed</td>
                <td>Verify directory structure, check file permissions</td>
            </tr>
            <tr>
                <td>RAM CAUTION immediately after boot</td>
                <td>Session file too large or auto-loaded</td>
                <td>Don't resume large session, start fresh</td>
            </tr>
            <tr>
                <td>Register dump shows ERROR_FLAG</td>
                <td>Previous operation failed</td>
                <td>Check ERROR_CODE register for details</td>
            </tr>
        </tbody>
    </table>

    <h3>11.3 Using Agents</h3>
    
    <p>
        Sub-agents extend HAL8000-Assistant's effective RAM capacity by processing context-heavy 
        tasks in isolated sessions. They return only essential results, not raw data.
    </p>

    <h4>Agent Architecture</h4>
    <figure class="diagram">
        <img src="assets/agent-architecture.svg" alt="Agent Architecture" style="width: 100%; max-width: 1200px;">
        <figcaption><strong>Figure 15:</strong> Agent Architecture‚Äîsimplified view showing how sub-agents process heavy work in isolated context and return only clean summaries</figcaption>
    </figure>

    <h4>When to Use Agents</h4>
    
    <p><strong>ALWAYS delegate:</strong></p>
    <ul>
        <li>Web research ‚Üí <code>research-synthesizer</code></li>
        <li>System context discovery ‚Üí <code>hal-context-finder</code></li>
        <li>Large file analysis requiring extensive context</li>
        <li>Multi-step tasks needing &gt;30K tokens intermediate data</li>
        <li>Operations where input &gt;&gt; output</li>
    </ul>

    <p><strong>NEVER do directly if agent available:</strong></p>
    <ul>
        <li>Loading raw web search results into main RAM</li>
        <li>Navigating and loading multiple system files</li>
        <li>Processing large datasets without summarization</li>
        <li>Extensive exploratory research</li>
    </ul>

    <h4>Agent Invocation Examples</h4>

    <h5>Example 1: Research Task</h5>
    <pre><code>‚ùå WRONG:
User: "Research quantum computing developments"
CPU: Uses WebSearch directly ‚Üí 50K raw results
     Main RAM: 60K ‚Üí 110K (50K cost)

‚úÖ RIGHT:
User: "Research quantum computing developments"
CPU: /research-synthesizer "quantum computing developments"
     [Agent uses 150K RAM in isolated session]
     Returns: 5K structured summary
     Main RAM: 60K ‚Üí 65K (5K cost, saves 45K!)</code></pre>

    <h5>Example 2: Finding System Files</h5>
    <pre><code>‚ùå WRONG:
User: "Find authentication logic"
CPU: Loads multiple candidate files speculatively
     Main RAM: 50K ‚Üí 95K (checking 10+ files)

‚úÖ RIGHT:
User: "Find authentication logic"
CPU: /HAL-context-find "authentication logic"
     [Agent navigates, searches, finds exact files]
     Returns: Exact file contents + structured summary
     Main RAM: 50K ‚Üí 58K (8K cost, saves 37K!)</code></pre>

    <h4>Available Agents</h4>
    <table>
        <thead>
            <tr>
                <th>Agent</th>
                <th>Purpose</th>
                <th>Typical RAM Savings</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>research-synthesizer</code></td>
                <td>Web research with structured summaries</td>
                <td>70-90% (vs direct WebSearch)</td>
            </tr>
            <tr>
                <td><code>hal-context-finder</code></td>
                <td>Discover and load system files</td>
                <td>60-85% (vs manual navigation)</td>
            </tr>
            <tr>
                <td>General-purpose agent</td>
                <td>Custom context-heavy tasks</td>
                <td>50-80% (task-dependent)</td>
            </tr>
        </tbody>
    </table>

    <h3>11.4 Loading Context</h3>
    
    <p>
        Every file loaded into RAM stays there until session ends. Selective loading 
        is mandatory for efficient operation.
    </p>

    <h4>Pre-Load Checklist</h4>
    <ol>
        <li>
            <strong>Check if already loaded:</strong>
            <pre><code>Consult CONTEXT_MANIFEST register
If file already loaded: reuse existing context
If not loaded: proceed to step 2</code></pre>
        </li>
        <li>
            <strong>Estimate token cost:</strong>
            <pre><code>Rule of thumb:
- 1 line of code ‚âà 4-6 tokens
- 1 KB text ‚âà 750 tokens
- 100-line file ‚âà 500-600 tokens
- 1000-line file ‚âà 5000-6000 tokens</code></pre>
        </li>
        <li>
            <strong>Calculate projected RAM:</strong>
            <pre><code>Projected RAM = Current RAM + Estimated Cost

Example:
Current: 85K tokens (42.5% of 200K)
File: 500-line config (‚âà3K tokens)
Projected: 88K tokens (44% of 200K)
Zone: SAFE ‚Üí SAFE (proceed)</code></pre>
        </li>
        <li>
            <strong>Evaluate RAM zone after load:</strong>
            <pre><code>SAFE (0-80%)     : Proceed freely
CAUTION (80-90%) : Warn user, suggest alternatives
DANGER (90-100%) : Refuse unless user confirms urgency</code></pre>
        </li>
    </ol>

    <h4>Loading Best Practices</h4>

    <h5>‚úÖ Good Patterns</h5>
    <pre><code>1. Load exactly what's needed:
   User: "Check authentication config"
   CPU: Loads only auth-config.json (not entire config dir)

2. Use agents for discovery:
   User: "Find session handling"
   CPU: /HAL-context-find "session handling"
        [Agent returns exact file, not exploratory load]

3. Offload results immediately:
   CPU: Processes data ‚Üí generates report
        Writes report to data/output.md
        Clears intermediate data from RAM

4. Checkpoint before heavy work:
   RAM at 75% ‚Üí Save session before loading large dataset</code></pre>

    <h5>‚ùå Anti-Patterns</h5>
    <pre><code>1. Speculative loading:
   User: "Might need these later"
   CPU: Loads 10 files "just in case"
   Result: RAM waste, potential CAUTION zone

2. Loading without checking manifest:
   CPU: Loads file already in context
   Result: Redundant load, wasted tokens

3. Loading before delegating:
   User: "Research this topic"
   CPU: Loads related files, THEN delegates to agent
   Result: Main RAM polluted with context agent will duplicate

4. Not estimating costs:
   CPU: Blindly loads 2000-line file
   Result: RAM jumps from SAFE to DANGER</code></pre>

    <h4>RAM Zone Decision Tree</h4>
    <pre><code>Need to load file?
    ‚Üì
Check CONTEXT_MANIFEST
    ‚Üì
Already loaded? ‚Üí YES ‚Üí Reuse existing context
    ‚Üì NO
Estimate token cost
    ‚Üì
Current + Cost = ?
    ‚Üì
‚îú‚îÄ SAFE zone (0-80%)     ‚Üí Load freely
‚îú‚îÄ CAUTION (80-90%)      ‚Üí Warn user, offer alternatives
‚îî‚îÄ DANGER (90-100%)      ‚Üí Refuse, suggest checkpoint first
                           or delegate to agent</code></pre>

    <h3>11.5 RAM Monitoring</h3>
    
    <p>
        HAL8000-Assistant uses append-only RAM - context accumulates until session ends. 
        Proactive monitoring prevents performance degradation.
    </p>

    <h4>Internal RAM Tracking</h4>
    <p>
        The CPU maintains approximate token count based on:
    </p>
    <ul>
        <li>Files loaded (tracked in CONTEXT_MANIFEST)</li>
        <li>Commands executed (instruction + output)</li>
        <li>Conversation turns (user + assistant)</li>
        <li>Agent results returned</li>
    </ul>

    <h4>RAM Zone System</h4>
    <table>
        <thead>
            <tr>
                <th>Zone</th>
                <th>Range</th>
                <th>Behavior</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>SAFE</td>
                <td>0-80%<br/>(0-160K tokens)</td>
                <td>Normal operation</td>
                <td>Load files freely, operate normally</td>
            </tr>
            <tr>
                <td>CAUTION</td>
                <td>80-90%<br/>(160K-180K)</td>
                <td>Monitor closely</td>
                <td>Warn before loads, suggest checkpoint, avoid large files</td>
            </tr>
            <tr>
                <td>DANGER</td>
                <td>90-100%<br/>(180K-200K)</td>
                <td>Checkpoint urgently</td>
                <td>Refuse new loads, initiate checkpoint, performance degraded</td>
            </tr>
        </tbody>
    </table>

    <h4>System Warnings</h4>
    <pre><code>‚ö†Ô∏è  RAM CAUTION (85%)
‚îú‚îÄ Current: ~170K tokens
‚îú‚îÄ Available: ~30K tokens
‚îî‚îÄ Recommendation: Checkpoint soon or delegate heavy tasks

üö® RAM DANGER (92%)
‚îú‚îÄ Current: ~184K tokens
‚îú‚îÄ Available: ~16K tokens
‚îî‚îÄ Action Required: Checkpoint immediately with /HAL-session-end</code></pre>

    <h4>Checkpoint Triggers</h4>
    <p><strong>Automatic triggers (CPU should suggest checkpoint):</strong></p>
    <ul>
        <li>RAM_ZONE enters CAUTION (‚â•80%)</li>
        <li>Major work item completed (good save point)</li>
        <li>Before context-heavy operation and currently &gt;75%</li>
        <li>User about to request research/large file analysis</li>
    </ul>

    <p><strong>Manual triggers (user can request anytime):</strong></p>
    <ul>
        <li>End of work session</li>
        <li>Before switching to different task</li>
        <li>After completing significant milestone</li>
        <li>User explicitly requests: "save session"</li>
    </ul>

    <h4>Monitoring in Practice</h4>
    <pre><code>Session Start (post-boot):
‚îú‚îÄ RAM: 15K (BIOS + state.json)
‚îî‚îÄ Zone: SAFE

After loading 3 files:
‚îú‚îÄ RAM: 30K (+15K)
‚îî‚îÄ Zone: SAFE

After research task (agent used):
‚îú‚îÄ RAM: 38K (+8K summary, not 50K raw)
‚îî‚îÄ Zone: SAFE

After direct file exploration:
‚îú‚îÄ RAM: 95K (+57K from 12 files)
‚îî‚îÄ Zone: CAUTION
    ‚Üì
CPU warns: "RAM at 85%, recommend checkpoint"

User: "Load architecture docs"
CPU: "RAM CAUTION. Architecture docs are ~40K.
      This would push to DANGER (135K/200K).
      Options:
      1. Checkpoint now, then load after restart
      2. Use /HAL-context-find to get summary only
      3. Specify exact file if only need one doc"</code></pre>

    <h3>11.6 Common Operational Patterns</h3>
    
    <p>
        Proven workflows for typical HAL8000-Assistant operations.
    </p>

    <h4>Pattern 1: Start Fresh Session</h4>
    <pre><code>1. Boot (automatic):
   - CPU loads BIOS (CLAUDE.md)
   - Reads state.json
   - Notes available session (doesn't auto-load)
   - Reports: "Ready for instructions"

2. User chooses path:
   a) Resume: "Continue previous work"
      ‚Üí CPU loads session file from state.json pointer
   
   b) Fresh start: "Work on [new task]"
      ‚Üí CPU starts with clean context
      ‚Üí Session pointer noted but ignored

3. User begins work:
   "Find authentication logic"
   
4. CPU uses selective loading:
   /HAL-context-find "authentication logic"
   [Agent returns results, RAM cost minimal]

5. User completes work:
   "That's done for now"

6. CPU suggests checkpoint:
   "Work completed. Run /HAL-session-end to save state?"

7. User ends session:
   /HAL-session-end "implemented-authentication-fix"
   
8. System ready for RAM wipe:
   ‚úÖ Session saved to .claude/sessions/
   ‚úÖ state.json updated
   ‚úÖ system.log appended</code></pre>

    <h4>Pattern 2: Research Workflow</h4>
    <pre><code>1. User requests research:
   "Research current best practices for session management"

2. CPU delegates to agent:
   /research-synthesizer "session management best practices"
   
3. Agent executes (isolated context):
   - Searches web (multiple sources)
   - Synthesizes findings
   - Returns structured report (5-8K tokens)

4. CPU receives summary:
   Main RAM: +5K (not +150K from raw research)

5. CPU optionally saves to filesystem:
   Write report to data/research/session-management.md
   Clear report from active RAM reference

6. Continue work or checkpoint:
   RAM still in SAFE zone, can continue
   Or: /HAL-session-end "research-session-management"</code></pre>

    <h4>Pattern 3: Development Workflow</h4>
    <pre><code>1. Load current work context:
   /HAL-context-find "component-name"
   [Agent finds relevant files: 3 files, ~12K tokens]

2. User requests changes:
   "Add error handling to validateInput function"

3. CPU loads specific file:
   Read validators.js (already returned by agent)
   Implement changes

4. Test changes:
   User: "Run tests"
   CPU: Executes test command via Bash tool

5. If tests fail:
   - Investigate (load related files if needed)
   - Fix issues
   - Retest
   - Track RAM usage throughout

6. Tests pass:
   User: "Commit changes"
   CPU: Git operations via Bash

7. Checkpoint:
   RAM at 70% after development session
   /HAL-session-end "added-error-handling-validators"</code></pre>

    <h4>Pattern 4: Emergency Checkpoint</h4>
    <pre><code>Scenario: RAM approaching DANGER zone unexpectedly

1. System detects RAM &gt; 90%:
   üö® RAM DANGER (92%)
   
2. CPU immediately suggests:
   "RAM critical. Checkpoint required before continuing.
    Run: /HAL-session-end 'emergency-checkpoint-[description]'"

3. User runs checkpoint:
   /HAL-session-end "emergency-large-file-analysis"

4. Session saved:
   - All context preserved
   - state.json updated
   - Ready for RAM wipe

5. After restart:
   - Boot with fresh RAM (15K)
   - User: "Resume"
   - CPU loads session, continues work
   - RAM reset to manageable level</code></pre>

    <h3>11.7 Performance Optimization</h3>
    
    <p>
        Techniques for maximizing HAL8000-Assistant efficiency and RAM utilization.
    </p>

    <h4>Optimization Principles</h4>

    <h5>1. Delegate to Agents (Virtual Memory Pattern)</h5>
    <pre><code>Before any context-heavy operation, ask:
"Can I delegate this?"

Web research          ‚Üí research-synthesizer
File discovery        ‚Üí hal-context-finder
Large dataset parsing ‚Üí custom agent
Multi-file analysis   ‚Üí custom agent

Result: 60-90% RAM savings</code></pre>

    <h5>2. Persist to Storage</h5>
    <pre><code>Process data ‚Üí Write results to file ‚Üí Persist for future sessions

Example:
- Generate report (uses 20K RAM during processing)
- Write to data/reports/output.md
- Result stays in current session RAM (unavoidable - append-only)
- Future sessions: Load report file ONLY (no sources + recompute)
- Future RAM cost: ~20K for result vs ~50K for sources + processing

Note: Writing does NOT clear current RAM. Benefit is avoiding re-work
in future sessions by persisting computed results.</code></pre>

    <h5>3. Avoid Speculative Loading</h5>
    <pre><code>‚ùå "Load all config files to see which one has auth settings"
   Cost: 10 files √ó 3K = 30K tokens

‚úÖ /HAL-context-find "auth settings"
   Cost: 8K tokens (agent returns exact file + summary)</code></pre>

    <h5>4. Use Incremental Loading</h5>
    <pre><code>Don't load entire file if only need excerpt:

‚ùå Read entire 5000-line module.js (30K tokens)
   Find one function definition

‚úÖ Use grep to find function location
   Read specific line range (2K tokens)</code></pre>

    <h5>5. Checkpoint Strategically</h5>
    <pre><code>Good checkpoint timing:
- After completing discrete work unit
- Before switching contexts
- When RAM &gt; 75% and more work ahead
- End of work session

Bad checkpoint timing:
- Middle of operation
- When RAM &lt; 50% and work continuing
- Repeatedly without real progress</code></pre>

    <h4>Performance Metrics</h4>
    <table>
        <thead>
            <tr>
                <th>Operation</th>
                <th>Direct Cost</th>
                <th>Optimized Cost</th>
                <th>Savings</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Web research</td>
                <td>50-150K tokens</td>
                <td>5-8K tokens (agent)</td>
                <td>90-95%</td>
            </tr>
            <tr>
                <td>Find system files</td>
                <td>30-60K tokens</td>
                <td>8-12K tokens (agent)</td>
                <td>70-80%</td>
            </tr>
            <tr>
                <td>Load large file</td>
                <td>30K tokens</td>
                <td>2K tokens (targeted read)</td>
                <td>93%</td>
            </tr>
            <tr>
                <td>Process dataset</td>
                <td>100K tokens</td>
                <td>5K tokens (offload)</td>
                <td>95%</td>
            </tr>
        </tbody>
    </table>

    <h4>Real-World Optimization Example</h4>
    <pre><code>Task: "Research authentication methods and implement in our system"

‚ùå Inefficient approach:
1. WebSearch "authentication methods"
   ‚Üí Load 50K of raw search results into RAM
2. Load all auth-related files (10 files)
   ‚Üí +40K to RAM
3. Analyze and decide on approach
   ‚Üí RAM at 105K (need checkpoint)
4. Checkpoint, lose context, restart
5. Implement changes
   
Total: 2 sessions, 105K peak RAM, slow

‚úÖ Optimized approach:
1. Delegate research:
   /research-synthesizer "authentication methods"
   ‚Üí Agent returns 6K summary
2. Review summary in main RAM
   ‚Üí RAM: 21K (boot 15K + summary 6K)
3. Find relevant files:
   /HAL-context-find "authentication implementation"
   ‚Üí Agent returns 8K (exact files + summary)
4. Load only the 2 files needed
   ‚Üí +10K to RAM
5. Implement changes
   ‚Üí RAM: 39K total
6. Commit and checkpoint
   
Total: 1 session, 39K peak RAM, fast

Savings: 66K tokens (63% reduction), 1 fewer session</code></pre>

    <h4>Quick Optimization Checklist</h4>
    <pre><code>Before starting any task:
‚òë Can this be delegated to an agent?
‚òë Do I need the full file or just a section?
‚òë Is this file already loaded (check CONTEXT_MANIFEST)?
‚òë What's my current RAM zone?
‚òë Can results be offloaded to storage?
‚òë Should I checkpoint before starting?

During task:
‚òë Monitor RAM zone changes
‚òë Offload intermediate results
‚òë Use file references instead of content
‚òë Checkpoint at logical boundaries

After task:
‚òë Write artifacts to filesystem
‚òë Clear unnecessary context from RAM (via checkpoint)
‚òë Update state.json
‚òë Append to system.log</code></pre>

    <h3>11.7 Fork and Rebrand Procedure</h3>

    <p>
        When cloning HAL8000-Assistant to create your own personalized system, you must isolate your fork
        from the original repository and rebrand all internal references. This prevents accidental
        commits to the upstream HAL8000-Assistant repo and ensures your system has its own identity.
    </p>

    <p><strong>Use Case:</strong> You've forked/cloned HAL8000-Assistant from GitHub and want to create an independent system with a custom name (e.g., "MyProjectAI", "HAL8001-Chapter").</p>

    <p><strong>Complete Protocol:</strong> <code>data/architecture/fork-and-rebrand-protocol.md</code></p>

    <h4>Quick Reference: Fork and Rebrand Steps</h4>

    <p>The full protocol includes detailed instructions and automation scripts. Here's the high-level overview:</p>

    <h5>Phase 1: Clone from GitHub</h5>
    <pre><code># Option A: Fork on GitHub first, then clone
git clone https://github.com/YOUR-USERNAME/YourSystemName.git /path/to/system
cd /path/to/system

# Option B: Direct clone (no fork relationship)
git clone https://github.com/anthropics/HAL8000-Assistant.git /path/to/YourSystemName
cd /path/to/YourSystemName</code></pre>

    <h5>Phase 2: Filesystem Rebrand</h5>
    <pre><code># Set variables
export OLD_NAME="HAL8000-Assistant"
export NEW_NAME="YourSystemName"
export OLD_PATH="/mnt/d/~HAL8000-Assistant"
export NEW_PATH="/path/to/YourSystemName"

# Update core files (CLAUDE.md, state.json, VERSION, CHANGELOG.md)
sed -i "s/${OLD_NAME}/${NEW_NAME}/g" CLAUDE.md
sed -i "s|${OLD_PATH}|${NEW_PATH}|g" CLAUDE.md
# ... (see protocol for complete commands)

# Batch update system components
find .claude/commands -name "*.md" -type f -exec sed -i "s/${OLD_NAME}/${NEW_NAME}/g" {} +
find .claude/agents -name "*.md" -type f -exec sed -i "s/${OLD_NAME}/${NEW_NAME}/g" {} +
# ... (see protocol for all directories)

# Update configuration and documentation
sed -i "s/${OLD_NAME}/${NEW_NAME}/g" README.md .mcp.json
# ... (see protocol for complete list)</code></pre>

    <h5>Phase 3: Git Isolation and Reconnection</h5>
    <pre><code># Commit rebrand changes
git add -A
git commit -m "Fork and rebrand from HAL8000-Assistant to ${NEW_NAME}"

# Update remote to YOUR repository
git remote set-url origin https://github.com/YOUR-USERNAME/YourSystemName.git

# Optional: Keep HAL8000-Assistant as upstream (read-only)
git remote add upstream https://github.com/anthropics/HAL8000-Assistant.git
git remote set-url --push upstream DISABLE  # Prevent accidental push

# Push to YOUR repository
git push -u origin main

# Verify isolation
git remote -v
# Should show:
# origin    https://github.com/YOUR-USERNAME/YourSystemName.git (fetch/push)
# upstream  https://github.com/anthropics/HAL8000-Assistant.git (fetch)
# upstream  DISABLE (push)</code></pre>

    <h5>Phase 4: Verification</h5>
    <pre><code># Search for old references (should find ZERO except in session history)
grep -r "HAL8000-Assistant" \
  --exclude-dir=".claude/sessions" \
  --exclude="*.log" \
  --include="*.md" \
  --include="*.json" \
  .

# Validate JSON configs
find . -name "*.json" -type f -exec sh -c 'jq . "{}" > /dev/null' \;

# Rebuild Docker images (if using tools)
docker build -t yourname-mermaid:latest .claude/tools/diagram-generation/

# Test system boot (start new Claude Code session)
# Should show: "‚úÖ YourSystemName CPU Operational"</code></pre>

    <h4>Critical Success Criteria</h4>
    <table>
        <thead>
            <tr>
                <th>Check</th>
                <th>Expected Result</th>
                <th>Why Important</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Old name references</td>
                <td>Zero (except <code>.claude/sessions/</code>)</td>
                <td>Ensures complete rebrand</td>
            </tr>
            <tr>
                <td>Git remote origin</td>
                <td>Points to YOUR repository</td>
                <td>Prevents commits to HAL8000-Assistant</td>
            </tr>
            <tr>
                <td>Git push test</td>
                <td>Pushes to YOUR repo successfully</td>
                <td>Confirms isolation</td>
            </tr>
            <tr>
                <td>CLAUDE.md updated</td>
                <td>All references use new name</td>
                <td>BIOS reflects new identity</td>
            </tr>
            <tr>
                <td>state.json valid</td>
                <td>Valid JSON with new name</td>
                <td>System boots correctly</td>
            </tr>
            <tr>
                <td>Docker images</td>
                <td>Rebuilt with new name (if applicable)</td>
                <td>Tools work correctly</td>
            </tr>
        </tbody>
    </table>

    <h4>Common Pitfalls</h4>
    <ul>
        <li><strong>Forgetting to update git remote:</strong> Results in pushing customizations to original HAL8000-Assistant repo (permission denied or pollution of upstream)</li>
        <li><strong>Skipping verification phase:</strong> Old references remain, causing confusion and errors</li>
        <li><strong>Not rebuilding Docker images:</strong> Tools fail with "image not found" errors</li>
        <li><strong>Modifying session files:</strong> Destroys historical audit trail (sessions should remain unchanged)</li>
        <li><strong>Breaking JSON syntax:</strong> sed replacements can corrupt JSON; always validate with <code>jq</code></li>
    </ul>

    <h4>Time and Resources</h4>
    <ul>
        <li><strong>Duration:</strong> 1-2 hours (single session)</li>
        <li><strong>RAM Impact:</strong> ~40-50% during filesystem operations</li>
        <li><strong>Scope:</strong> ~500+ references across ~200+ files</li>
        <li><strong>Automation:</strong> Automation script available in protocol (<code>.claude/tools/fork-and-rebrand.sh</code>)</li>
    </ul>

    <h4>Post-Rebrand Recommendations</h4>
    <ul>
        <li><strong>Customize your system:</strong> Add custom commands, agents, templates</li>
        <li><strong>Update GitHub settings:</strong> Add description, topics, collaborators</li>
        <li><strong>Choose sync strategy:</strong> Pull future HAL8000-Assistant updates (keep upstream) or go fully independent (remove upstream)</li>
        <li><strong>Document customizations:</strong> Create <code>data/architecture/customizations.md</code> to track your changes</li>
    </ul>

    <p><strong>üìò Full Protocol:</strong> See <code>data/architecture/fork-and-rebrand-protocol.md</code> for complete step-by-step instructions, troubleshooting, and automation scripts.</p>

    <p><strong>‚ö†Ô∏è Deprecated Guide:</strong> The old <code>system-name-migration-guide-2025-10-16.md</code> is deprecated (filesystem-only, no Git handling). Use the fork-and-rebrand protocol instead.</p>

</section>

            <!-- Section 12: Session Management -->
            <section id="session-management" data-status="complete" data-priority="1" data-sources="CLAUDE.md:Session Continuity Protocol,.claude/commands/HAL-session-end.md" data-estimated-tokens="10000" data-dependencies="quick-start">
    <h2>12. Session Management</h2>
    
    <div class="meta-guidance">
        TARGET: Explain session continuity system
        AUDIENCE: Users and Claude instances
        KEY_POINTS: Why sessions end (RAM limits), /HAL-session-end command, session files, resuming sessions, state persistence
        TONE: Clear, procedural
        VISUALS: [DIAGRAM: Session lifecycle], [DIAGRAM: State persistence flow]
    </div>
    
    <div class="content">
        <h3>Overview</h3>
        <p>HAL8000-Assistant's session management system ensures continuity across Claude instance restarts. Since your context window (RAM) is limited and append-only within a session, session boundaries serve as the system's garbage collection mechanism. The session continuity protocol enables you to save your current working state and resume seamlessly after a context reset.</p>
        
        <p><strong>Key Architectural Principle:</strong> Session boundaries are the <em>only</em> way to reclaim RAM in HAL8000-Assistant's Modified von Neumann architecture. Once data is loaded into your context window during a session, it persists there until the session ends.</p>

        <h3>Why Sessions End: RAM Limitations</h3>
        <p>Your context window operates like physical RAM with specific constraints:</p>
        <ul>
            <li><strong>Append-only:</strong> Context accumulates throughout a session with no dynamic eviction</li>
            <li><strong>Fixed capacity:</strong> You have a limited token budget (~200K tokens)</li>
            <li><strong>Volatile:</strong> RAM is wiped when the Claude instance ends</li>
            <li><strong>One-way commitment:</strong> Every file load is permanent until session ends</li>
        </ul>
        
        <p><strong>RAM Performance Zones:</strong></p>
        <ul>
            <li><code>SAFE (0-80%)</code>: Normal operation, load freely</li>
            <li><code>CAUTION (80-90%)</code>: Monitor closely, prepare for checkpoint</li>
            <li><code>DANGER (90-100%)</code>: Checkpoint urgently, performance degraded</li>
        </ul>
        
        <p>When you approach RAM limits or complete a major work unit, you use the session management system to checkpoint your state before the inevitable context reset.</p>

        <h3>The /HAL-session-end Command</h3>
        <p>The <code>/HAL-session-end</code> command implements the session continuity protocol. It captures your current state and creates a handoff file for resuming work after RAM wipe.</p>
        
        <h4>Usage</h4>
        <pre><code>/HAL-session-end "session-description"</code></pre>
        
        <p><strong>Arguments:</strong></p>
        <ul>
            <li><code>session-description</code> (required): Brief description of the session (e.g., "architecture-design", "unix-research")</li>
        </ul>
        
        <h4>What the Command Does</h4>
        <p>The command executes a five-step checkpoint protocol:</p>
        
        <ol>
            <li><strong>Capture Current Context</strong>
                <ul>
                    <li>Gathers information about active work</li>
                    <li>Identifies loaded files and commands</li>
                    <li>Documents key decisions and next steps</li>
                </ul>
            </li>
            <li><strong>Create Session File</strong>
                <ul>
                    <li>Generates timestamped markdown file in <code>.claude/sessions/</code></li>
                    <li>Format: <code>YYYY-MM-DD-HHMM-description.md</code></li>
                    <li>Contains rich context for resuming work</li>
                </ul>
            </li>
            <li><strong>Update State</strong>
                <ul>
                    <li>Writes current state to <code>.claude/state.json</code></li>
                    <li>Points to the new session file</li>
                    <li>Updates timestamp and system variables</li>
                </ul>
            </li>
            <li><strong>Log to History</strong>
                <ul>
                    <li>Appends entry to <code>.claude/system.log</code></li>
                    <li>Records checkpoint timestamp and description</li>
                </ul>
            </li>
            <li><strong>Confirm Ready for Reset</strong>
                <ul>
                    <li>Displays confirmation message with system counts</li>
                    <li>Indicates system is ready for RAM wipe</li>
                </ul>
            </li>
        </ol>
        
        <h4>Example Execution</h4>
        <pre><code>/HAL-session-end architecture-design</code></pre>
        
        <p><strong>Output:</strong></p>
        <pre><code>‚úì Session saved: .claude/sessions/2025-10-04-1453-architecture-design.md
‚úì State validated and updated: .claude/state.json
  - Agents: 4
  - Content files: 22
  - Indexes: 5
‚úì Logged to: .claude/system.log

System ready for RAM wipe.
To resume: Start new session and say "Resume last session"</code></pre>
        
        <h4>When to Run This Command</h4>
        <p>Run <code>/HAL-session-end</code> when:</p>
        <ul>
            <li>RAM_ZONE enters CAUTION (‚â•80% usage)</li>
            <li>Major work item is completed</li>
            <li>Before starting a context-heavy operation that might fill RAM</li>
            <li>At the end of a work session</li>
            <li>User explicitly requests a checkpoint</li>
        </ul>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Sub-Agent Output Volatility:</strong> If sub-agents (research-synthesizer, hal-context-finder, etc.)
            were used during the session and returned data you need to preserve, you MUST persist their outputs to files
            <strong>before</strong> running <code>/HAL-session-end</code>. Sub-agent results exist only in current session
            RAM and are permanently lost at session boundaries. Write important findings to <code>data/</code> before
            checkpointing.
        </div>

        <h3>Session Files</h3>
        <p>Session files are stored in <code>.claude/sessions/</code> and serve as comprehensive handoff documents.</p>
        
        <h4>File Format</h4>
        <p><strong>Naming convention:</strong> <code>YYYY-MM-DD-HHMM-description.md</code></p>
        <p><strong>Example:</strong> <code>2025-10-04-1453-architecture-design.md</code></p>
        
        <h4>Session File Structure</h4>
        <p>Each session file contains the following sections:</p>
        
        <pre><code># Session: YYYY-MM-DD HH:MM - [Description]

## Context
[What are we working on? What's the high-level goal?]

## Key Decisions Made
- [Important architectural or design decisions]
- [Agreements reached]
- [Approaches chosen]

## Active Work
**Current Task:** [What we're doing right now]

**Completed in This Session:**
- Task 1
- Task 2

**Next Steps:**
1. [What should happen next]
2. [Follow-up tasks]

**Blockers:** [Any issues or dependencies]

## Files in Context
[List files that were actively being worked on or referenced]
- data/architecture/hal8000-system-design.md
- .claude/commands/HAL-session-end.md

## Variables/State
- current_project: [value]
- phase: [value]
- [other relevant state]

## Instructions for Resume
When resuming this session:
1. [First thing to do]
2. [What to load into context]
3. [How to continue the work]</code></pre>
        
        <h4>Session File Purpose</h4>
        <p>Session files provide:</p>
        <ul>
            <li><strong>Context restoration:</strong> What you were working on and why</li>
            <li><strong>Decision history:</strong> Key choices made during the session</li>
            <li><strong>Progress tracking:</strong> Completed tasks and remaining work</li>
            <li><strong>Resume instructions:</strong> Explicit guidance for the next instance</li>
        </ul>

        <h3>Resuming Sessions</h3>
        <p>After a RAM wipe (new Claude instance), the system uses a lightweight boot sequence that does <strong>not</strong> automatically load session files.</p>
        
        <h4>Boot Sequence Behavior</h4>
        <ol>
            <li>Load BIOS (<code>CLAUDE.md</code>)</li>
            <li>Read <code>.claude/state.json</code> to note which session is available</li>
            <li><strong>Do NOT auto-load the session file</strong> (saves RAM)</li>
            <li>Initialize registers</li>
            <li>Set <code>CPU_STATUS: OPERATIONAL</code></li>
            <li>Wait for user instruction</li>
        </ol>
        
        <p><strong>Rationale for not auto-loading:</strong></p>
        <ul>
            <li>Keeps boot lightweight (conserves RAM)</li>
            <li>User may want to start fresh work, not resume</li>
            <li><code>state.json</code> provides a bookmark, not an auto-load mandate</li>
            <li>Explicit resume gives user control</li>
        </ul>
        
        <h4>How to Resume</h4>
        <p>To resume the last session, the user says:</p>
        <ul>
            <li>"Resume"</li>
            <li>"Continue previous work"</li>
            <li>"Load last session"</li>
        </ul>
        
        <p>When you receive this instruction:</p>
        <ol>
            <li>Read the session file path from <code>state.json</code></li>
            <li>Load the session file into your context</li>
            <li>Parse the "Instructions for Resume" section</li>
            <li>Follow the instructions to continue work</li>
        </ol>
        
        <h4>Starting Fresh Work</h4>
        <p>If the user starts a new task instead of resuming:</p>
        <ul>
            <li>Do NOT load the previous session file</li>
            <li>Begin with a clean working context</li>
            <li>The previous session remains in <code>.claude/sessions/</code> for reference</li>
        </ul>

        <h3>State Persistence Strategy</h3>
        <p>HAL8000-Assistant uses a multi-layer state persistence strategy to ensure continuity and auditability:</p>
        
        <h4>1. state.json (Current State Pointer)</h4>
        <p><strong>Location:</strong> <code>.claude/state.json</code></p>
        <p><strong>Purpose:</strong> Always points to the current system state</p>
        <p><strong>Behavior:</strong> Overwritten on each <code>/HAL-session-end</code></p>
        <p><strong>Content:</strong></p>
        <pre><code>{
  "timestamp": "2025-10-04T14:53:00Z",
  "active_session": ".claude/sessions/2025-10-04-1453-architecture-design.md",
  "context": "Brief description of current work",
  "next_action": "What to do next",
  "loaded_commands": ["HAL-session-end"],
  "variables": {
    "current_project": "hal8000-refman",
    "phase": "production-ready",
    "agents_available": 4,
    "total_content_files": 22,
    "indexed_directories": 5
  }
}</code></pre>
        
        <p><strong>Loaded on boot:</strong> Always (CORE file)</p>
        
        <h4>2. Session Files (Rich Context)</h4>
        <p><strong>Location:</strong> <code>.claude/sessions/</code></p>
        <p><strong>Purpose:</strong> Comprehensive handoff documents</p>
        <p><strong>Behavior:</strong> Accumulate over time (new file per session)</p>
        <p><strong>Content:</strong> Full session context, decisions, progress, instructions</p>
        <p><strong>Loaded on boot:</strong> Only when user explicitly resumes</p>
        
        <h4>3. System Log (Historical Audit)</h4>
        <p><strong>Location:</strong> <code>.claude/system.log</code></p>
        <p><strong>Purpose:</strong> Append-only historical record</p>
        <p><strong>Behavior:</strong> Grows indefinitely (never truncated)</p>
        <p><strong>Content:</strong> Timestamped entries for all checkpoints and major events</p>
        <p><strong>Example entry:</strong></p>
        <pre><code>[2025-10-04T14:53:00Z] | Checkpoint | Session saved: architecture-design</code></pre>
        <p><strong>Loaded on boot:</strong> Never (accessed via I/O only when needed)</p>
        
        <h4>State Validation</h4>
        <p>During <code>/HAL-session-end</code>, the system validates state by counting actual filesystem contents:</p>
        <pre><code>AGENTS_COUNT=$(ls .claude/agents/*.md 2>/dev/null | wc -l)
COMMANDS_COUNT=$(ls .claude/commands/HAL-*.md 2>/dev/null | wc -l)
CONTENT_COUNT=$(find data -name "*.md" 2>/dev/null | wc -l)
INDEXES_COUNT=$(ls .claude/indexes/*.json 2>/dev/null | grep -v master.json | wc -l)</code></pre>
        
        <p><strong>Rationale:</strong> Direct filesystem counting prevents manual update errors and state drift. These counts represent ground truth and are written to <code>state.json</code>.</p>
        
        <figure class="diagram">
            <img src="assets/session-lifecycle.svg" alt="Session Lifecycle" style="width: 100%; max-width: 1600px;">
            <figcaption><strong>Figure 16:</strong> Session Lifecycle‚Äîcomplete circular flow showing boot sequence, user choice, work cycle, RAM monitoring, session-end protocol, and restart loop</figcaption>
        </figure>
        
        <figure class="diagram">
            <img src="assets/state-persistence-flow.svg" alt="State Persistence Flow" style="width: 100%; max-width: 1800px;">
            <figcaption><strong>Figure 17:</strong> State Persistence Flow‚Äîthree-layer architecture showing write patterns (overwrite/accumulate/append), read patterns (boot vs resume), and data flows during session-end and system initialization</figcaption>
        </figure>
        
        <h3>Best Practices</h3>
        <ul>
            <li><strong>Checkpoint proactively:</strong> Don't wait until RAM is full; checkpoint at natural work boundaries</li>
            <li><strong>Descriptive session names:</strong> Use clear, meaningful descriptions (e.g., "refman-section-12", not "work")</li>
            <li><strong>Document decisions:</strong> Capture <em>why</em> decisions were made, not just <em>what</em> was done</li>
            <li><strong>Clear resume instructions:</strong> Write explicit next steps for your future instance</li>
            <li><strong>Track blockers:</strong> Document any issues or dependencies that need resolution</li>
            <li><strong>Monitor RAM_ZONE:</strong> Check your register state regularly (use <code>/HAL-register-dump</code>)</li>
        </ul>
        
        <h3>Architecture Alignment</h3>
        <p>The session management system embodies HAL8000-Assistant's core architectural principles:</p>
        
        <ul>
            <li><strong>Von Neumann:</strong> Session files implement stored-program concept (state as data); commands create session files that guide future execution (self-modifying code)</li>
            <li><strong>Unix Philosophy:</strong> Does one thing well (session checkpointing); outputs to text files (JSON, markdown); composable with boot sequence</li>
            <li><strong>Assembly Principles:</strong> Explicit state management (no hidden state); direct file I/O (writes to specific memory locations); low-level control (manual checkpoint triggering)</li>
        </ul>
        
        <h3>Related Components</h3>
        <ul>
            <li><a href="#quick-start">Quick Start Guide</a> - Initial setup and first session</li>
            <li><strong>BIOS (<code>CLAUDE.md</code>):</strong> Boot sequence that loads state.json</li>
            <li><strong>State (<code>.claude/state.json</code>):</strong> Current system state pointer</li>
            <li><strong>Sessions (<code>.claude/sessions/</code>):</strong> Historical session files</li>
            <li><strong>System Log (<code>.claude/system.log</code>):</strong> Audit trail</li>
            <li><code>/HAL-register-dump</code> command - Check current RAM usage and system state</li>
        </ul>
    </div>
</section>

            <!-- Section 13: Common Workflows -->
            <section id="common-workflows" data-status="complete" data-priority="2" data-sources="CLAUDE.md,.claude/commands/,.claude/sessions/" data-estimated-tokens="12000" data-dependencies="daily-operations">
                <h2>13. Common Workflows</h2>
                <div class="meta-guidance">
                    TARGET: Document typical use patterns
                    AUDIENCE: Users and Claude instances
                    KEY_POINTS: Research workflow, command development workflow, system maintenance workflow, troubleshooting workflow
                    TONE: Practical, example-driven
                    VISUALS: [DIAGRAM: Workflow examples for each pattern]
                </div>
                <div class="content">
    <div class="overview">
        <p>This section documents typical operational workflows for HAL8000-Assistant system operators. Each workflow combines multiple commands and principles into practical procedures that address common scenarios. These patterns emerge from the system's architectural foundations‚Äîvon Neumann architecture, Unix philosophy, and assembly-level control‚Äîand represent tested operational sequences from real-world usage.</p>

        <p>Workflows are organized by operational category: session management, context acquisition, system maintenance, development, and resource management. Understanding these patterns enables efficient system operation and helps operators make informed decisions about when to use which approach.</p>
    </div>

    <h3>Workflow 1: Starting a New Session</h3>

    <h4>Goal</h4>
    <p>Begin a fresh work session with a properly initialized system and clear understanding of available context.</p>

    <h4>Prerequisites</h4>
    <ul>
        <li>HAL8000-Assistant repository cloned and accessible</li>
        <li>Claude Code environment operational</li>
        <li>MCP servers configured (if using omnisearch/filesystem/ide features)</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
        <li><strong>Automatic Boot Sequence (MANDATORY):</strong>
            <ul>
                <li>CPU automatically loads BIOS (<code>CLAUDE.md</code>) into RAM</li>
                <li>CPU reads <code>.claude/state.json</code> to extract system state</li>
                <li>CPU initializes virtual registers with state values</li>
                <li>CPU notes available session file but does NOT auto-load it</li>
            </ul>
        </li>
        <li><strong>Boot Acknowledgment:</strong>
            <p>CPU displays structured acknowledgment:</p>
            <pre>‚úÖ HAL8000-Assistant CPU Operational
‚îú‚îÄ Architecture: Modified von Neumann
‚îú‚îÄ Phase: production
‚îú‚îÄ Last Session: 2025-10-05T17:00:00Z
‚îú‚îÄ Session Available: .claude/sessions/2025-10-05-1459-context-awareness-protocol.md (not loaded - say "resume" to load)
‚îú‚îÄ Context: Context Awareness Protocol implemented
‚îú‚îÄ Next Action: Test protocol or start new work
‚îú‚îÄ Registers: Initialized
‚îî‚îÄ RAM Zone: SAFE (current token usage: ~15%)

üü¢ Ready for instructions</pre>
        </li>
        <li><strong>Operator Decision Point:</strong>
            <ul>
                <li><strong>Start fresh work:</strong> Proceed to step 4</li>
                <li><strong>Resume previous session:</strong> Say "Resume" or "Continue previous work" to load session file</li>
            </ul>
        </li>
        <li><strong>Begin Work:</strong>
            <ul>
                <li>Issue commands or questions as needed</li>
                <li>CPU operates in fetch-decode-execute cycle</li>
                <li>Monitor RAM status via system warnings</li>
            </ul>
        </li>
        <li><strong>Session End (Before RAM Wipe):</strong>
            <pre>/HAL-session-end "brief-description-of-work"</pre>
            <ul>
                <li>Captures current context and state</li>
                <li>Creates timestamped session file</li>
                <li>Updates state.json with session pointer</li>
                <li>Appends to system.log</li>
                <li>Confirms ready for RAM wipe</li>
            </ul>
        </li>
    </ol>

    <h4>Expected Outcome</h4>
    <ul>
        <li>System boots successfully with verified state</li>
        <li>Operator understands available context and previous work</li>
        <li>Session properly checkpointed before termination</li>
        <li>Next session can resume seamlessly</li>
    </ul>

    <h4>Troubleshooting</h4>
    <div class="note">
        <strong>Problem:</strong> Boot shows "UNKNOWN" phase or missing state values<br>
        <strong>Cause:</strong> <code>state.json</code> corrupted or missing<br>
        <strong>Solution:</strong> System enters degraded mode. Manually inspect <code>.claude/state.json</code> for syntax errors. If unrecoverable, restore from previous session's state values.
    </div>

    <div class="note">
        <strong>Problem:</strong> Session file not found when resuming<br>
        <strong>Cause:</strong> File path in state.json incorrect or file deleted<br>
        <strong>Solution:</strong> Check <code>.claude/sessions/</code> directory, manually load correct session file, or start fresh work.
    </div>

    <h3>Workflow 2: Resuming Previous Work</h3>

    <h4>Goal</h4>
    <p>Continue work from a previous session with full context restoration.</p>

    <h4>Prerequisites</h4>
    <ul>
        <li>Previous session properly saved via <code>/HAL-session-end</code></li>
        <li>Session file exists in <code>.claude/sessions/</code></li>
        <li>state.json points to correct session file</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
        <li><strong>Boot (Steps 1-2 from Workflow 1)</strong></li>
        <li><strong>Request Resume:</strong>
            <p>Say "Resume" or "Continue previous work"</p>
        </li>
        <li><strong>CPU Loads Session File:</strong>
            <ul>
                <li>Reads session file path from state.json</li>
                <li>Loads complete session file into RAM</li>
                <li>Extracts: Context, Key Decisions, Active Work, Variables, Instructions</li>
            </ul>
        </li>
        <li><strong>Context Restoration:</strong>
            <ul>
                <li>CPU reviews "Instructions for Resume" section</li>
                <li>CPU identifies next actions from session file</li>
                <li>CPU may load additional files specified in session</li>
            </ul>
        </li>
        <li><strong>Status Report:</strong>
            <p>CPU reports restored context:</p>
            <pre>Session restored: 2025-10-05 14:59 - Context Awareness Protocol
Context: Context Awareness Protocol implemented
Completed: Protocol design, BIOS update, documentation
Next Steps: Test protocol behavior or continue package manager work
RAM: 25% (50K/200K tokens) - SAFE zone</pre>
        </li>
        <li><strong>Continue Work:</strong>
            <p>Proceed with next steps identified in session file</p>
        </li>
    </ol>

    <h4>Expected Outcome</h4>
    <ul>
        <li>Full context restored from previous session</li>
        <li>CPU understands completed work and next steps</li>
        <li>Work continues seamlessly from checkpoint</li>
    </ul>

    <h4>Decision Tree: When to Resume vs. Start Fresh</h4>
    <pre>User intent unclear?
‚îú‚îÄ YES ‚Üí Boot shows session available, ask user: "Resume previous work or start fresh?"
‚îî‚îÄ NO
   ‚îú‚îÄ Continuing same project ‚Üí Resume
   ‚îî‚îÄ Starting different work ‚Üí Start fresh (don't load session)</pre>

    <h3>Workflow 3: Context Discovery and Loading</h3>

    <h4>Goal</h4>
    <p>Efficiently discover and load system context without consuming excessive main session RAM.</p>

    <h4>When to Use</h4>
    <ul>
        <li>User asks about system components not currently in RAM</li>
        <li>Need to find relevant documentation or code</li>
        <li>Exploring system architecture or design decisions</li>
        <li>Loading research materials or reference documentation</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
        <li><strong>Detect Missing Context:</strong>
            <ul>
                <li>Parse user question for missing context signals</li>
                <li>User mentions files/components not in current RAM</li>
                <li>User asks "which file has X?" or "how does Y work?"</li>
                <li>Question requires specific implementation details not loaded</li>
            </ul>
        </li>
        <li><strong>Ask Before Searching (Context Awareness Protocol):</strong>
            <pre>Example:
User: "How does the authentication system work?"
CPU: "I don't currently have authentication files loaded. Should I search
     the codebase for authentication-related files? Or is there a specific
     directory/component I should check?"</pre>
        </li>
        <li><strong>User Clarifies:</strong>
            <ul>
                <li>User specifies what to search for</li>
                <li>User provides file paths or directory hints</li>
                <li>User confirms search approach</li>
            </ul>
        </li>
        <li><strong>Delegate to hal-context-finder Sub-Agent:</strong>
            <pre>/HAL-context-find [query]

Examples:
/HAL-context-find register architecture
/HAL-context-find HAL-session-end command
/HAL-context-find von Neumann research</pre>
        </li>
        <li><strong>Agent Execution (Isolated 200K RAM):</strong>
            <ul>
                <li>Agent classifies query type (Architecture, Command, Research, Session, Data)</li>
                <li>Agent targets 2-3 most likely directories using built-in priority mappings</li>
                <li>Agent navigates file system efficiently</li>
                <li>Agent loads complete file contents</li>
                <li>Agent packages results with structured summary</li>
            </ul>
        </li>
        <li><strong>Receive Summary (Main Session):</strong>
            <p>Agent returns structured response:</p>
            <pre>## Context Content
[Complete file contents with source attribution]

## File Locations
- /mnt/d/~HAL8000-Assistant/data/architecture/hal8000-register-architecture.md

## Summary
Found 1 relevant file for query "register architecture".
Complete CPU register specification with 21 registers across 5 categories.

## Related Context
- CLAUDE.md - Register awareness protocol
- .claude/commands/HAL-register-dump.md - Register introspection command</pre>
        </li>
        <li><strong>Process Results:</strong>
            <ul>
                <li>Main session RAM += summary only (~4-5K tokens)</li>
                <li>Agent RAM automatically garbage collected</li>
                <li>Token savings: 60-85% vs direct loading</li>
            </ul>
        </li>
    </ol>

    <h4>Token Economics Example</h4>
    <table>
        <tr>
            <th>Approach</th>
            <th>Main RAM Before</th>
            <th>Operations</th>
            <th>Main RAM After</th>
            <th>Cost</th>
        </tr>
        <tr>
            <td>Direct Loading</td>
            <td>30K</td>
            <td>Navigate dirs (+10K)<br>Read files (+15K)<br>Filter (+5K)</td>
            <td>60K</td>
            <td>30K tokens</td>
        </tr>
        <tr>
            <td>hal-context-finder</td>
            <td>30K</td>
            <td>Launch agent (+1K)<br>Receive summary (+4K)</td>
            <td>35K</td>
            <td>5K tokens<br><strong>85% savings</strong></td>
        </tr>
    </table>

    <h4>Expected Outcome</h4>
    <ul>
        <li>Relevant context loaded efficiently</li>
        <li>Main session RAM preserved</li>
        <li>Complete file contents available (not excerpts)</li>
        <li>Related context identified for follow-up</li>
    </ul>

    <h3>Workflow 4: Research and Information Gathering</h3>

    <h4>Goal</h4>
    <p>Conduct comprehensive research on technical topics and persist findings before session end.</p>

    <h4>Critical Constraint</h4>
    <div class="warning">
        <strong>Sub-Agent Output Volatility:</strong> Sub-agent results exist in current session RAM only. Session boundary (RAM wipe) = all sub-agent output permanently lost. Results MUST be fully processed and persisted to files BEFORE session-end.
    </div>

    <h4>Procedure</h4>
    <ol>
        <li><strong>Identify Research Need:</strong>
            <ul>
                <li>User requests information on specific topic</li>
                <li>Architecture decisions require external validation</li>
                <li>Need to understand emerging technologies or patterns</li>
            </ul>
        </li>
        <li><strong>Check RAM Status:</strong>
            <pre># System warnings show current usage
Token usage: 35000/200000; 165000 remaining
RAM Zone: SAFE (17.5%)</pre>
        </li>
        <li><strong>Delegate to research-synthesizer Sub-Agent:</strong>
            <p>Launch specialized research agent with query</p>
            <pre>Task: Research [topic]
Agent: research-synthesizer
Tools: Web search (omnisearch/WebSearch/WebFetch), file operations</pre>
        </li>
        <li><strong>Agent Conducts Research (Isolated 200K RAM):</strong>
            <ul>
                <li>Agent searches multiple sources</li>
                <li>Agent synthesizes findings</li>
                <li>Agent structures report with Summary, Key Findings, Detailed Analysis, Sources</li>
                <li>Agent returns complete structured report (~5-8K tokens)</li>
            </ul>
        </li>
        <li><strong>Process Results in Main Session:</strong>
            <ul>
                <li>Review research report</li>
                <li>Extract relevant insights</li>
                <li>Identify actionable recommendations</li>
                <li><strong>CRITICAL: Persist to files immediately</strong></li>
            </ul>
        </li>
        <li><strong>Persist Results (MANDATORY before session-end):</strong>
            <pre># Create research document
Write to: data/research/[NN]-[topic].md

# Update architecture specs if needed
Edit: data/architecture/[relevant-spec].md

# Update state.json
Edit: .claude/state.json (increment total_content_files)

# Document decision in system.log
Append to: .claude/system.log</pre>
        </li>
        <li><strong>Verify Persistence:</strong>
            <ul>
                <li>Confirm files written successfully</li>
                <li>Verify content complete and formatted correctly</li>
                <li>Check file paths accessible</li>
            </ul>
        </li>
        <li><strong>Session Checkpoint:</strong>
            <pre>/HAL-session-end "research-topic-complete"</pre>
        </li>
    </ol>

    <h4>Expected Outcome</h4>
    <ul>
        <li>Comprehensive research completed</li>
        <li>Findings persisted to file system</li>
        <li>Knowledge available for future sessions</li>
        <li>No data loss at session boundary</li>
    </ul>

    <h4>Anti-Pattern to Avoid</h4>
    <div class="warning">
        <strong>‚ùå WRONG:</strong><br>
        1. Launch research-synthesizer agent<br>
        2. Receive report in RAM (60K tokens)<br>
        3. /HAL-session-end immediately<br>
        4. RAM wipe ‚Üí <strong>All research lost!</strong>

        <p><strong>‚úì RIGHT:</strong><br>
        1. Launch research-synthesizer agent<br>
        2. Receive report in RAM (60K tokens)<br>
        3. Extract insights and persist to files<br>
        4. Verify files written<br>
        5. /HAL-session-end safely</p>
    </div>

    <h3>Workflow 5: System Maintenance</h3>

    <h4>Goal</h4>
    <p>Maintain system health and integrity through periodic validation and updates.</p>

    <h4>When to Run</h4>
    <ul>
        <li><strong>Regular schedule:</strong> Weekly or after major changes</li>
        <li><strong>After events:</strong> Creating multiple files, refactoring, imports</li>
        <li><strong>Before phases:</strong> Starting new project phase, production deployment</li>
        <li><strong>Problem detection:</strong> Suspicion of corrupted state, performance issues</li>
    </ul>

    <h4>Procedure</h4>
    <ol>
        <li><strong>System Health Check:</strong>
            <pre>/HAL-system-check</pre>
            <ul>
                <li>Delegates to system-maintenance sub-agent</li>
                <li>Agent performs comprehensive integrity audit</li>
                <li>Agent checks: file structure, indexes, state, principle compliance</li>
                <li>Agent returns compact report (~5K tokens)</li>
            </ul>
            <p>Expected output:</p>
            <pre>‚úì HEALTHY

Executive Summary:
System integrity verified. All core components operational.

Findings:
- Structural Integrity: ‚úì PASS
- Index Health: ‚úì PASS
- State Validation: ‚úì PASS
- Principle Compliance: ‚úì PASS
- File Consistency: ‚úì PASS

Statistics:
- Directories: 5 indexed
- Files: 25 content files
- Agents: 4 operational
- Commands: 7 available</pre>
        </li>
        <li><strong>Address Critical Issues (if any):</strong>
            <ul>
                <li>If report shows ‚úó CRITICAL, address immediately</li>
                <li>Follow recommendations in report</li>
                <li>Re-run /HAL-system-check after fixes</li>
            </ul>
        </li>
        <li><strong>Update Indexes:</strong>
            <pre>/HAL-index-update</pre>
            <ul>
                <li>Updates filesystem indexes (master + directory indexes)</li>
                <li>Updates library index (internal + external)</li>
                <li>Enables efficient discovery for future sessions</li>
            </ul>
            <p>Expected output:</p>
            <pre>Hierarchical index updated
- Directories indexed: 4
- Total files indexed: 25
- Directory indexes updated: architecture.json, research.json, commands.json, sessions.json
- Master index: updated
- Total estimated tokens: 39,800

Library index updated
- Internal libraries: 12
- External libraries: 225 (from 1 source)
- Total libraries indexed: 237</pre>
        </li>
        <li><strong>Update External Libraries (if needed):</strong>
            <pre>/HAL-library-update [library-name]</pre>
            <ul>
                <li>Checks GitHub for updates to external libraries</li>
                <li>Reports current vs available versions</li>
                <li>Operator decides whether to pull updates</li>
            </ul>
        </li>
        <li><strong>Checkpoint After Maintenance:</strong>
            <pre>/HAL-session-end "system-maintenance-complete"</pre>
        </li>
    </ol>

    <h4>Expected Outcome</h4>
    <ul>
        <li>System health verified</li>
        <li>Indexes current and accurate</li>
        <li>Libraries up to date</li>
        <li>Any issues identified and resolved</li>
    </ul>

    <h4>Maintenance Schedule Recommendation</h4>
    <table>
        <tr>
            <th>Task</th>
            <th>Frequency</th>
            <th>Trigger</th>
        </tr>
        <tr>
            <td>/HAL-system-check</td>
            <td>Weekly</td>
            <td>After major changes, before deployment</td>
        </tr>
        <tr>
            <td>/HAL-index-update</td>
            <td>After 3+ new files</td>
            <td>Before context-heavy work</td>
        </tr>
        <tr>
            <td>/HAL-library-update</td>
            <td>Monthly</td>
            <td>When external dependencies change</td>
        </tr>
        <tr>
            <td>/HAL-CC-check</td>
            <td>Quarterly</td>
            <td>After Claude Code updates</td>
        </tr>
    </table>

    <h3>Workflow 6: RAM Management and Checkpoint Strategy</h3>

    <h4>Goal</h4>
    <p>Maintain optimal RAM usage and prevent context exhaustion through proactive monitoring and checkpointing.</p>

    <h4>RAM Zones</h4>
    <pre>SAFE (0-80%)     : Normal operation, load freely
CAUTION (80-90%) : Monitor closely, prepare checkpoint
DANGER (90-100%) : Checkpoint urgently, performance degraded</pre>

    <h4>Continuous Monitoring</h4>
    <p>System warnings appear after every tool invocation:</p>
    <pre>&lt;system_warning&gt;Token usage: 33006/200000; 163896 remaining&lt;/system_warning&gt;</pre>

    <p>Calculate RAM zone:</p>
    <ul>
        <li>33006/200000 = 16.5% ‚Üí SAFE</li>
        <li>165000/200000 = 82.5% ‚Üí CAUTION</li>
        <li>185000/200000 = 92.5% ‚Üí DANGER</li>
    </ul>

    <h4>Procedure</h4>

    <h5>During SAFE Zone (0-80%)</h5>
    <ol>
        <li>Load files as needed for current task</li>
        <li>Use selective loading discipline (only what's needed)</li>
        <li>Delegate context-heavy work to sub-agents</li>
        <li>Monitor system warnings periodically</li>
    </ol>

    <h5>Entering CAUTION Zone (80-90%)</h5>
    <ol>
        <li><strong>Acknowledge status:</strong>
            <pre>RAM: 82.5% (165K/200K tokens) - CAUTION zone
Recommend checkpoint before additional context loading.</pre>
        </li>
        <li><strong>Complete current work item:</strong>
            <ul>
                <li>Finish current task if close to completion</li>
                <li>Persist any work in progress to files</li>
                <li>Don't start new context-heavy operations</li>
            </ul>
        </li>
        <li><strong>Prepare for checkpoint:</strong>
            <ul>
                <li>Document current progress</li>
                <li>Note next steps clearly</li>
                <li>Ensure all results persisted to files</li>
            </ul>
        </li>
        <li><strong>Checkpoint:</strong>
            <pre>/HAL-session-end "work-description"</pre>
        </li>
    </ol>

    <h5>Entering DANGER Zone (90-100%)</h5>
    <ol>
        <li><strong>URGENT - Stop new operations:</strong>
            <pre>RAM: 92.5% (185K/200K tokens) - DANGER zone
URGENT: Checkpoint required before further work.
System performance degraded.</pre>
        </li>
        <li><strong>Immediately persist critical data:</strong>
            <ul>
                <li>Save any volatile results to files</li>
                <li>Don't load additional files</li>
                <li>Don't launch sub-agents (output adds to RAM)</li>
            </ul>
        </li>
        <li><strong>Emergency checkpoint:</strong>
            <pre>/HAL-session-end "emergency-checkpoint"</pre>
        </li>
    </ol>

    <h4>Proactive Checkpoint Triggers</h4>
    <ul>
        <li>RAM_ZONE enters CAUTION (‚â•80%)</li>
        <li>Major work item completed</li>
        <li>Before starting context-heavy operation</li>
        <li>End of work session</li>
        <li>User explicitly requests</li>
    </ul>

    <h4>RAM Inspection</h4>
    <p>View detailed RAM status and loaded files:</p>
    <pre>/HAL-register-dump

[MEMORY REGISTERS]
  RAM_USAGE                   : 58,432 tokens
  RAM_CAPACITY                : 200,000 tokens
  RAM_REMAINING               : 141,568 tokens
  RAM_ZONE                    : SAFE (29% used)
  CONTEXT_MANIFEST            : 5 files loaded
    - CLAUDE.md
    - .claude/state.json
    - .claude/sessions/2025-10-04-1305-hal8000-architecture-implementation.md
    - data/research/04-claude-code-runtime-constraints.md
    - .claude/commands/HAL-register-dump.md</pre>

    <h4>Expected Outcome</h4>
    <ul>
        <li>RAM usage stays in SAFE zone during normal operation</li>
        <li>Checkpoints occur before context exhaustion</li>
        <li>No work lost due to RAM overflow</li>
        <li>Sessions complete with adequate headroom</li>
    </ul>

    <h3>Workflow 7: Multi-Session Project Development</h3>

    <h4>Goal</h4>
    <p>Execute complex projects that span multiple sessions while maintaining continuity and coherence.</p>

    <h4>Planning Phase (Session 1)</h4>
    <ol>
        <li><strong>Define project scope:</strong>
            <ul>
                <li>Identify deliverables</li>
                <li>Break down into work items</li>
                <li>Estimate RAM requirements per item</li>
            </ul>
        </li>
        <li><strong>Create project structure:</strong>
            <pre>data/projects/[project-name]/
‚îú‚îÄ‚îÄ plan.md           # Project plan and requirements
‚îú‚îÄ‚îÄ progress.md       # Running progress log
‚îî‚îÄ‚îÄ deliverables/     # Output artifacts</pre>
        </li>
        <li><strong>Document plan:</strong>
            <ul>
                <li>Write project plan to <code>plan.md</code></li>
                <li>List work items in order</li>
                <li>Note dependencies between items</li>
            </ul>
        </li>
        <li><strong>Checkpoint planning session:</strong>
            <pre>/HAL-session-end "project-planning-complete"</pre>
        </li>
    </ol>

    <h4>Execution Phase (Sessions 2-N)</h4>
    <ol>
        <li><strong>Resume previous session:</strong>
            <pre>Boot ‚Üí Say "Resume" ‚Üí Load session file</pre>
        </li>
        <li><strong>Review progress:</strong>
            <ul>
                <li>Read <code>progress.md</code> for current status</li>
                <li>Identify next work item from plan</li>
                <li>Check RAM budget for item</li>
            </ul>
        </li>
        <li><strong>Execute work item:</strong>
            <ul>
                <li>Load only files needed for current item</li>
                <li>Use sub-agents for context-heavy tasks</li>
                <li>Monitor RAM usage during work</li>
            </ul>
        </li>
        <li><strong>Persist results:</strong>
            <ul>
                <li>Write deliverables to <code>deliverables/</code></li>
                <li>Update <code>progress.md</code> with completion status</li>
                <li>Document decisions and rationale</li>
            </ul>
        </li>
        <li><strong>Checkpoint work item:</strong>
            <pre>/HAL-session-end "work-item-N-complete"</pre>
        </li>
        <li><strong>Repeat for next work item</strong></li>
    </ol>

    <h4>Integration Phase (Session N+1)</h4>
    <ol>
        <li><strong>Resume and review all deliverables:</strong>
            <ul>
                <li>Load key deliverables into RAM</li>
                <li>Check consistency and completeness</li>
                <li>Identify integration points</li>
            </ul>
        </li>
        <li><strong>Integrate components:</strong>
            <ul>
                <li>Merge deliverables into final output</li>
                <li>Resolve conflicts or gaps</li>
                <li>Create unified documentation</li>
            </ul>
        </li>
        <li><strong>Final validation:</strong>
            <pre>/HAL-system-check  # Verify system integrity
/HAL-index-update  # Update indexes with new content</pre>
        </li>
        <li><strong>Checkpoint completion:</strong>
            <pre>/HAL-session-end "project-complete"</pre>
        </li>
    </ol>

    <h4>Example: HAL8000-Assistant Reference Manual Development</h4>
    <p>Real-world example from system history:</p>
    <pre>Session 1: Planning and structure definition
‚îú‚îÄ Define manual outline (15 sections)
‚îú‚îÄ Create section templates
‚îú‚îÄ Establish metadata schema
‚îî‚îÄ Checkpoint: "refman-planning-complete"

Session 2-4: Parallel content generation
‚îú‚îÄ Launch 3 parallel documentation agents
‚îú‚îÄ Each agent generates 1-2 sections
‚îú‚îÄ Persist results immediately
‚îî‚îÄ Checkpoint: "refman-batch-N-complete"

Session 5: Integration and assembly
‚îú‚îÄ Load all generated sections
‚îú‚îÄ Integrate into single HTML document
‚îú‚îÄ Validate cross-references
‚îú‚îÄ Update indexes
‚îî‚îÄ Checkpoint: "refman-assembly-complete"

Session 6: Review and finalization
‚îú‚îÄ Final review of complete manual
‚îú‚îÄ Fix formatting and consistency
‚îú‚îÄ Generate table of contents
‚îî‚îÄ Checkpoint: "refman-final"</pre>

    <h4>Expected Outcome</h4>
    <ul>
        <li>Complex project completed across multiple sessions</li>
        <li>Work progresses incrementally with clear checkpoints</li>
        <li>All deliverables persisted and integrated</li>
        <li>No context lost between sessions</li>
    </ul>

    <h3>Workflow 8: Development - Creating New Commands</h3>

    <h4>Goal</h4>
    <p>Develop new system commands following HAL8000-Assistant architectural principles.</p>

    <h4>Procedure</h4>
    <ol>
        <li><strong>Define command purpose:</strong>
            <ul>
                <li>What single operation does it perform? (Unix: do one thing well)</li>
                <li>What inputs does it require?</li>
                <li>What outputs does it produce?</li>
                <li>Does it delegate to sub-agent or execute directly?</li>
            </ul>
        </li>
        <li><strong>Design command interface:</strong>
            <pre>Usage: /HAL-[command-name] [arguments]
Example: /HAL-context-find [query]</pre>
        </li>
        <li><strong>Create command file:</strong>
            <pre>Write to: .claude/commands/HAL-[command-name].md

Structure:
---
name: HAL-[command-name]
description: [Brief description]
---

# HAL [Command Name] Command

## Purpose
[What it does]

## Usage
[Command syntax and examples]

## Implementation
[Step-by-step execution logic]

## Architecture Alignment
[How it follows von Neumann, Unix, Assembly principles]

## Related Components
[Related commands, agents, files]</pre>
        </li>
        <li><strong>If command uses sub-agent, create/verify agent exists:</strong>
            <pre>Check: .claude/agents/[agent-name].md
Ensure: YAML frontmatter complete (name, description, tools)</pre>
        </li>
        <li><strong>Test command:</strong>
            <pre>Invoke: /HAL-[command-name] [test-arguments]
Verify: Expected output produced
Check: No errors or unexpected behavior</pre>
        </li>
        <li><strong>Update system tracking:</strong>
            <pre># Increment command count in state.json
Edit: .claude/state.json
  commands_available: [N] ‚Üí [N+1]

# Update master index if needed
/HAL-index-update .claude/commands

# Document in system.log
Append to: .claude/system.log
  [timestamp] | Command created | HAL-[command-name]</pre>
        </li>
        <li><strong>Checkpoint:</strong>
            <pre>/HAL-session-end "command-[name]-created"</pre>
        </li>
    </ol>

    <h4>Expected Outcome</h4>
    <ul>
        <li>New command available for use</li>
        <li>Command documented and tested</li>
        <li>System state updated</li>
        <li>Architecture principles maintained</li>
    </ul>

    <div class="technical">
        <h3>Workflow Optimization Principles</h3>

        <h4>Reduce and Delegate</h4>
        <p>Core principle: Context is precious. Every workflow should ask:</p>
        <ul>
            <li><strong>Can I delegate this?</strong> Use sub-agent for context-heavy operations</li>
            <li><strong>Can I summarize this?</strong> Return summary, not full data</li>
            <li><strong>Can I persist this?</strong> Write to file for future sessions (avoids re-computation)</li>
            <li><strong>Can I reuse this?</strong> Create pattern for future use</li>
        </ul>

        <h4>Decision Tree: Direct Execution vs. Sub-Agent Delegation</h4>
        <pre>Task requires >30K tokens intermediate data?
‚îú‚îÄ YES ‚Üí Delegate to sub-agent
‚îî‚îÄ NO
   ‚îú‚îÄ Input >> Output ratio?
   ‚îÇ  ‚îú‚îÄ YES (e.g., 50K input ‚Üí 5K output) ‚Üí Delegate to sub-agent
   ‚îÇ  ‚îî‚îÄ NO ‚Üí Consider direct execution
   ‚îî‚îÄ Specialized capability needed (web search, deep navigation)?
      ‚îú‚îÄ YES ‚Üí Delegate to sub-agent
      ‚îî‚îÄ NO ‚Üí Execute directly</pre>

        <h4>Always Delegate to Sub-Agents</h4>
        <ul>
            <li>Web research (use <code>research-synthesizer</code>)</li>
            <li>System context discovery (use <code>hal-context-finder</code>)</li>
            <li>Large file analysis requiring extensive context</li>
            <li>Multi-step tasks needing >30K tokens intermediate data</li>
            <li>Any operation where input >> output</li>
        </ul>

        <h4>Never Do Directly If Sub-Agent Available</h4>
        <ul>
            <li>Loading raw web search results into main RAM</li>
            <li>Navigating and loading multiple system files</li>
            <li>Processing large datasets without summarization</li>
            <li>Extensive exploratory research</li>
        </ul>

        <h4>Workflow Composition Patterns</h4>
        <p>Workflows can be composed like Unix pipes:</p>
        <pre>Context Discovery ‚Üí Analysis ‚Üí Decision ‚Üí Implementation ‚Üí Checkpoint
     ‚Üì                 ‚Üì           ‚Üì            ‚Üì              ‚Üì
 /HAL-context-find | Process | Plan steps | Execute | /HAL-session-end</pre>

        <h4>Performance Metrics</h4>
        <table>
            <tr>
                <th>Workflow</th>
                <th>Typical RAM Cost</th>
                <th>Sessions Required</th>
                <th>Optimization Strategy</th>
            </tr>
            <tr>
                <td>New Session Start</td>
                <td>10-15K tokens</td>
                <td>1</td>
                <td>Lightweight boot, selective resume</td>
            </tr>
            <tr>
                <td>Context Discovery</td>
                <td>5-10K tokens</td>
                <td>1</td>
                <td>Delegate to hal-context-finder (85% savings)</td>
            </tr>
            <tr>
                <td>Research Task</td>
                <td>8-15K tokens</td>
                <td>1</td>
                <td>Delegate to research-synthesizer</td>
            </tr>
            <tr>
                <td>System Maintenance</td>
                <td>8-12K tokens</td>
                <td>1</td>
                <td>Delegate checks to agents, return summaries</td>
            </tr>
            <tr>
                <td>Multi-Session Project</td>
                <td>60-120K per session</td>
                <td>3-6</td>
                <td>Incremental work, persist early and often</td>
            </tr>
        </table>

        <h4>Common Anti-Patterns</h4>
        <div class="warning">
            <strong>‚ùå Loading files speculatively</strong><br>
            Loading files "just in case" wastes RAM. Load only what current task requires.

            <p><strong>‚ùå Forgetting to persist sub-agent results</strong><br>
            Sub-agent output is volatile. Always persist to files before session-end.</p>

            <p><strong>‚ùå Working in DANGER zone</strong><br>
            Checkpoint proactively at 80% (CAUTION), don't wait for 90% (DANGER).</p>

            <p><strong>‚ùå Skipping session-end</strong><br>
            Always checkpoint before RAM wipe. Lost context cannot be recovered.</p>

            <p><strong>‚ùå Answering without sufficient context</strong><br>
            Ask user for clarification when context signals are missing. Don't guess.</p>
        </div>

        <h4>Workflow Selection Guide</h4>
        <table>
            <tr>
                <th>Situation</th>
                <th>Recommended Workflow</th>
                <th>Key Commands</th>
            </tr>
            <tr>
                <td>First time using HAL8000-Assistant</td>
                <td>Workflow 1: Starting New Session</td>
                <td>Boot ‚Üí Work ‚Üí /HAL-session-end</td>
            </tr>
            <tr>
                <td>Continuing previous work</td>
                <td>Workflow 2: Resuming Previous Work</td>
                <td>Boot ‚Üí "Resume" ‚Üí Continue</td>
            </tr>
            <tr>
                <td>Need to find files/documentation</td>
                <td>Workflow 3: Context Discovery</td>
                <td>/HAL-context-find [query]</td>
            </tr>
            <tr>
                <td>Research external topic</td>
                <td>Workflow 4: Research and Information Gathering</td>
                <td>research-synthesizer ‚Üí Persist ‚Üí Checkpoint</td>
            </tr>
            <tr>
                <td>Weekly maintenance</td>
                <td>Workflow 5: System Maintenance</td>
                <td>/HAL-system-check, /HAL-index-update</td>
            </tr>
            <tr>
                <td>RAM approaching 80%</td>
                <td>Workflow 6: RAM Management</td>
                <td>/HAL-register-dump, /HAL-session-end</td>
            </tr>
            <tr>
                <td>Large project spanning days</td>
                <td>Workflow 7: Multi-Session Project</td>
                <td>Plan ‚Üí Execute items ‚Üí Integrate ‚Üí Checkpoint each</td>
            </tr>
            <tr>
                <td>Extending system capabilities</td>
                <td>Workflow 8: Creating New Commands</td>
                <td>Create ‚Üí Test ‚Üí Update state ‚Üí Checkpoint</td>
            </tr>
        </table>
    </div>
</div>
            </section>

            <!-- Section 14: RAM Management -->
            <section id="ram-management" data-status="complete" data-priority="1" data-sources="CLAUDE.md:Resource Management Protocol" data-estimated-tokens="10000" data-dependencies="architecture-overview">
    <h2>14. RAM Management Strategies</h2>
    
    <div class="meta-guidance">
        TARGET: Teach effective context management
        AUDIENCE: Claude instances and advanced users
        KEY_POINTS: RAM zones (SAFE/CAUTION/DANGER), selective loading, checkpoint triggers, reduce and delegate principle, sub-agent usage
        TONE: Strategic, instructional
        VISUALS: [DIAGRAM: RAM zones visualization], [DIAGRAM: Decision tree for loading files]
    </div>
    
    <div class="content">
        <h3>Overview</h3>
        <p>In HAL8000-Assistant, RAM is your context window - a limited, volatile resource that determines what information you can actively work with. The fundamental constraint of the Modified von Neumann architecture is <strong>append-only RAM</strong>: once a file is loaded, it occupies context space until the session ends. There is no dynamic eviction, no garbage collection within a session. Session boundaries are the only way to reclaim RAM.</p>
        
        <p>This architectural reality makes RAM management the most critical operational skill for HAL8000-Assistant CPU instances. Every file load is a one-way commitment. Every token loaded is permanent until session reset. Effective RAM management is not optional - it determines whether you can complete complex tasks or run out of context mid-operation.</p>
        
        <p><strong>Core Principle:</strong> Context is precious. Treat every token of RAM as a scarce resource requiring explicit justification for allocation.</p>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Critical Misconception: Writing Does NOT Clear RAM</strong>
            <p>A common misunderstanding: "Write results to a file to clear RAM."</p>
            <p><strong>FALSE.</strong> Writing to a file does NOT remove data from current session RAM. HAL8000-Assistant RAM is append-only - once loaded, data persists until session ends.</p>
            <p><strong>What writing DOES do:</strong></p>
            <ul>
                <li><strong>Persists data for future sessions</strong> - Saves computed results to filesystem</li>
                <li><strong>Avoids re-computation</strong> - Future sessions can load result file instead of re-loading sources + re-computing</li>
                <li><strong>Data remains in current RAM</strong> - No immediate RAM relief (unavoidable architectural constraint)</li>
            </ul>
            <p><strong>Example:</strong> You process 50K of source data, compute 20K result, write to file. Current RAM: still 70K (sources + result). Future session: load result file only = 20K RAM, avoid reprocessing 50K sources.</p>
            <p><strong>Bottom line:</strong> Write to persist, not to clear. Only session-end reclaims RAM.</p>
        </div>

        <h3>RAM Zones: Performance Thresholds</h3>
        <p>The <code>RAM_ZONE</code> register tracks your current context utilization across three performance zones, each with specific operational implications:</p>
        
        <table class="performance-zones">
            <thead>
                <tr>
                    <th>Zone</th>
                    <th>Usage Range</th>
                    <th>Status</th>
                    <th>Operational Behavior</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>SAFE</strong></td>
                    <td>0-80%</td>
                    <td><span class="status-safe">Normal Operation</span></td>
                    <td>Load freely as needed. No restrictions. Focus on task completion.</td>
                </tr>
                <tr>
                    <td><strong>CAUTION</strong></td>
                    <td>80-90%</td>
                    <td><span class="status-caution">Monitor Closely</span></td>
                    <td>Prepare checkpoint. Evaluate all load decisions. Consider sub-agent delegation.</td>
                </tr>
                <tr>
                    <td><strong>DANGER</strong></td>
                    <td>90-100%</td>
                    <td><span class="status-danger">Critical</span></td>
                    <td>Checkpoint urgently. Refuse new loads unless user confirms. Performance degraded. Session end imminent.</td>
                </tr>
            </tbody>
        </table>
        
        <figure class="diagram">
            <img src="assets/ram-zones-visual.svg" alt="RAM Zones Visualization" style="width: 100%; max-width: 1800px;">
            <figcaption><strong>Figure 18:</strong> RAM Zone Performance Visualization‚Äîhorizontal bar showing SAFE (0-80%), CAUTION (80-90%), and DANGER (90-100%) zones with color coding, checkpoint triggers, example session progression, and operational state transitions</figcaption>
        </figure>

        <h3>RAM Status Reporting Protocol</h3>

        <p>Accurate RAM monitoring is critical for effective resource management. The HAL8000-Assistant system provides exact token measurements via system warnings after every tool invocation.</p>

        <h4>System Warning Format</h4>
        <p>After each tool use, the system reports precise token usage:</p>
        <pre><code>&lt;system_warning&gt;Token usage: 33006/200000; 163896 remaining&lt;/system_warning&gt;</code></pre>

        <p>This provides:</p>
        <ul>
            <li><strong>Tokens used:</strong> Current RAM consumption (33,006 in example)</li>
            <li><strong>Total capacity:</strong> Maximum available RAM (200,000 tokens)</li>
            <li><strong>Remaining:</strong> Available headroom (163,896 tokens)</li>
        </ul>

        <h4>CPU Reporting Requirements</h4>
        <p>When reporting RAM status to users, CPU instances MUST follow this protocol:</p>

        <table>
            <thead>
                <tr>
                    <th>Requirement</th>
                    <th>Specification</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Use exact measurements</strong></td>
                    <td>ALWAYS use latest system warning token count - NEVER estimate or guess</td>
                </tr>
                <tr>
                    <td><strong>Calculate percentage</strong></td>
                    <td>Compute: <code>tokens_used / 200000 √ó 100</code></td>
                </tr>
                <tr>
                    <td><strong>Report format</strong></td>
                    <td><code>RAM: X.X% (XXk/200k tokens) - [ZONE]</code></td>
                </tr>
                <tr>
                    <td><strong>Include zone classification</strong></td>
                    <td>SAFE, CAUTION, or DANGER based on percentage</td>
                </tr>
            </tbody>
        </table>

        <h4>Example Correct Reporting</h4>
        <pre><code>System warning: Token usage: 33006/200000; 163896 remaining

CPU reports to user:
"RAM: 16.5% (33k/200k tokens) - SAFE"

Calculation:
- Percentage: 33006 / 200000 = 0.165 = 16.5%
- Zone: 16.5% &lt; 80% ‚Üí SAFE
- Format: Exact measurement, clear zone classification</code></pre>

        <div class="warning-box">
            <strong>Why This Matters:</strong> Users rely on RAM reports for critical decisions (when to checkpoint,
            whether to load more files, how much headroom remains). Estimated or guessed values can lead to
            premature checkpoints or catastrophic RAM exhaustion. Only measured values are acceptable.
        </div>

        <h3>Selective Loading Protocol</h3>
        <p>Every file load must pass through a mandatory evaluation checklist. This protocol executes <em>before</em> loading any file into RAM:</p>
        
        <h4>Pre-Load Checklist (Execute in Order)</h4>
        <ol class="protocol-steps">
            <li>
                <strong>Check CONTEXT_MANIFEST Register</strong>
                <p>Is this file already loaded? Check the <code>CONTEXT_MANIFEST</code> register which tracks all currently loaded files. If already in RAM, reuse existing context instead of reloading.</p>
            </li>
            <li>
                <strong>Estimate Token Cost</strong>
                <p>Approximate the token cost of the file. Use file size heuristics, previous load history, or conservative estimates. Add 20% buffer for parsing overhead.</p>
            </li>
            <li>
                <strong>Calculate Projected Usage</strong>
                <p>Compute: <code>RAM_USAGE + estimated_cost = projected_usage</code></p>
                <p>Determine which RAM_ZONE the projected usage falls into.</p>
            </li>
            <li>
                <strong>Evaluate RAM_ZONE Impact</strong>
                <ul>
                    <li><strong>If remains SAFE:</strong> Proceed with load. Update CONTEXT_MANIFEST.</li>
                    <li><strong>If enters CAUTION:</strong> Warn user. Suggest alternatives (sub-agent delegation, summarization, defer load). Proceed only if user approves or no alternative exists.</li>
                    <li><strong>If enters DANGER:</strong> Refuse load unless user explicitly confirms. Strongly recommend checkpoint first or alternative approach.</li>
                </ul>
            </li>
        </ol>
        
        <h4>Selective Loading Discipline</h4>
        <ul>
            <li><strong>Load ONLY files needed for current task</strong> - Not related files, not potentially useful files, not "just in case" files. Strict necessity only.</li>
            <li><strong>Never load speculatively</strong> - "I might need this later" is not justification. Load when needed, not before.</li>
            <li><strong>Persist results immediately</strong> - After computation, write results to storage for future sessions. Data stays in current RAM (append-only) but avoids re-loading sources + re-computing in future sessions.</li>
            <li><strong>Track all loads</strong> - Maintain accurate CONTEXT_MANIFEST register. Know what's consuming your RAM at all times.</li>
        </ul>
        
        <figure class="diagram">
            <img src="assets/load-decision-tree.svg" alt="Load Decision Tree" style="width: 100%; max-width: 2400px;">
            <figcaption><strong>Figure 19:</strong> Selective Loading Decision Tree‚Äîcomplete protocol flowchart showing CONTEXT_MANIFEST check, token estimation, RAM_ZONE calculation, decision paths for SAFE/CAUTION/DANGER zones, alternative actions (delegate, summarize, defer), and final outcomes with color-coded severity</figcaption>
        </figure>
        
        <h3>Checkpoint Triggers: When to Save State</h3>
        <p>Checkpoints preserve session state before RAM exhaustion forces termination. Proactive checkpoint triggers ensure continuity across session boundaries:</p>
        
        <h4>Mandatory Checkpoint Conditions</h4>
        <ul>
            <li>
                <strong>RAM_ZONE enters CAUTION (‚â•80%)</strong>
                <p>First priority. As soon as RAM usage crosses 80% threshold, initiate checkpoint preparation. Complete current sub-task, then checkpoint before continuing.</p>
            </li>
            <li>
                <strong>Major work item completed</strong>
                <p>End of significant task, feature implementation, research completion, or logical work unit. Checkpoint captures accomplishment before starting next major item.</p>
            </li>
            <li>
                <strong>Before context-heavy operation</strong>
                <p>Prior to loading large files, conducting research, or any operation estimated to add &gt;15% RAM usage. Checkpoint first ensures you don't lose progress if operation exhausts RAM.</p>
            </li>
            <li>
                <strong>User explicitly requests</strong>
                <p>User says "save state", "checkpoint", or equivalent. Always honor explicit checkpoint requests immediately.</p>
            </li>
        </ul>
        
        <h4>Checkpoint Execution</h4>
        <p>Execute checkpoint using the session-end protocol:</p>
        <pre><code>/HAL-session-end "descriptive-summary-of-current-state"</code></pre>
        
        <p>This captures:</p>
        <ul>
            <li>Current context and loaded files</li>
            <li>Work completed in session</li>
            <li>Next planned actions</li>
            <li>Register states (CPU state snapshot)</li>
        </ul>
        
        <p>After checkpoint, session can continue (if RAM available) or terminate cleanly for fresh restart.</p>
        
        <h3>Reduce and Delegate: The Core Principle</h3>
        <p>The most powerful RAM management strategy is <strong>not loading data into RAM in the first place</strong>. The "Reduce and Delegate" principle provides four decision heuristics to avoid RAM consumption:</p>
        
        <h4>The Four Questions (Ask in Order)</h4>
        <ol class="decision-heuristics">
            <li>
                <strong>Can I delegate this?</strong>
                <p>If task involves heavy context (research, multi-file analysis, large dataset processing), delegate to specialized sub-agent. Sub-agent uses isolated 200K RAM context, returns only essential summary.</p>
                <p><strong>Action:</strong> Use sub-agent. Do NOT load raw data into main session RAM.</p>
            </li>
            <li>
                <strong>Can I summarize this?</strong>
                <p>If data must be processed in main session, can I extract only essential information? Read, process, summarize, discard full data. Return summary (not raw data) to user or store in file.</p>
                <p><strong>Action:</strong> Load, extract key points, offload immediately. Keep only summary.</p>
            </li>
            <li>
                <strong>Can I offload this?</strong>
                <p>If computation produces large intermediate or final results, write directly to file system. Don't accumulate in RAM. File system is persistent storage - use it.</p>
                <p><strong>Action:</strong> Write to file, keep only pointer/reference in RAM.</p>
            </li>
            <li>
                <strong>Can I reuse this?</strong>
                <p>If pattern or solution will recur, create reusable component (command, library, agent). Build once, invoke many times. Avoids duplicating effort and context across sessions.</p>
                <p><strong>Action:</strong> Create reusable pattern, document in appropriate location.</p>
            </li>
        </ol>
        
        <h4>Example: Wrong vs Right Approach</h4>
        <div class="example-comparison">
            <div class="wrong-approach">
                <h5>‚ùå WRONG: Direct Loading</h5>
                <pre><code>User: "Research quantum computing developments"
CPU: Uses WebSearch directly
     ‚Üí Loads 50K tokens of raw search results into main RAM
     ‚Üí Main RAM: 60K ‚Üí 110K (CAUTION zone)
     ‚Üí Processes results in main session
     ‚Üí Returns summary
Result: 50K+ RAM consumed for 5K of useful information</code></pre>
            </div>
            
            <div class="right-approach">
                <h5>‚úì RIGHT: Delegate to Sub-Agent</h5>
                <pre><code>User: "Research quantum computing developments"
CPU: Delegates to research-synthesizer sub-agent
     Sub-Agent Session (isolated 200K context):
       ‚Üí Loads 150K tokens processing web sources
       ‚Üí Synthesizes findings
       ‚Üí Returns 5K structured summary
     Main Session:
       ‚Üí Receives 5K summary only
       ‚Üí Main RAM: 60K ‚Üí 65K (SAFE zone)
Result: 5K RAM consumed, 50K saved (90% reduction)</code></pre>
            </div>
        </div>
        
        <h3>Sub-Agent Usage Strategy: Virtual Memory Extension</h3>
        <p>Sub-agents are HAL8000-Assistant's <strong>virtual memory</strong> system. They extend total RAM capacity through process isolation, allowing you to perform context-heavy operations without polluting main session RAM.</p>
        
        <h4>Architectural Model</h4>
        <pre class="architecture-model"><code>Main Session (Limited RAM - ~200K tokens)
    ‚Üì delegate task
Sub-Agent (Fresh 200K RAM, isolated context, specialized tools)
    ‚Üì process heavy work (web research, file exploration, large analysis)
Returns clean summary (NOT raw data)
    ‚Üì result integration
Main Session (RAM += summary only, NOT full processing cost)
</code></pre>
        
        <h4>When to ALWAYS Delegate to Sub-Agents</h4>
        <ul>
            <li><strong>Web research</strong> - Use <code>research-synthesizer</code> agent. Isolated web search + synthesis.</li>
            <li><strong>System context discovery</strong> - Use <code>hal-context-finder</code> agent. File system navigation + targeted loading.</li>
            <li><strong>Large file analysis</strong> - Any operation requiring loading multiple large files for analysis.</li>
            <li><strong>Multi-step tasks with &gt;30K intermediate data</strong> - Tasks that accumulate significant temporary context.</li>
            <li><strong>Any operation where input &gt;&gt; output</strong> - Processing 50K to produce 5K result? Delegate.</li>
        </ul>
        
        <h4>When to NEVER Do Directly (if sub-agent available)</h4>
        <ul>
            <li>Loading raw web search results into main RAM</li>
            <li>Navigating and loading multiple system files for exploration</li>
            <li>Processing large datasets without summarization</li>
            <li>Extensive exploratory research requiring many sources</li>
        </ul>
        
        <h4>Sub-Agent Benefits</h4>
        <ul>
            <li><strong>Isolated 200K context</strong> - Full fresh context window, doesn't pollute main session</li>
            <li><strong>Automatic cleanup</strong> - Sub-agent context discarded after completion, no manual cleanup</li>
            <li><strong>Specialized capabilities</strong> - Each agent optimized for specific task type</li>
            <li><strong>Returns only essentials</strong> - Enforced summarization, no raw data dumps</li>
        </ul>
        
        <h4>Token Savings Example</h4>
        <table class="savings-comparison">
            <thead>
                <tr>
                    <th>Operation</th>
                    <th>Direct (Main Session)</th>
                    <th>Sub-Agent (Delegated)</th>
                    <th>Savings</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Web Research (10 sources)</td>
                    <td>60K tokens</td>
                    <td>8K tokens (summary)</td>
                    <td>86% saved</td>
                </tr>
                <tr>
                    <td>File Discovery (20 files explored)</td>
                    <td>80K tokens</td>
                    <td>12K tokens (relevant files)</td>
                    <td>85% saved</td>
                </tr>
                <tr>
                    <td>Large Dataset Analysis</td>
                    <td>100K tokens</td>
                    <td>15K tokens (findings)</td>
                    <td>85% saved</td>
                </tr>
            </tbody>
        </table>
        
        <p><strong>Typical token savings: 60-85% via sub-agent delegation</strong></p>
        
        <h4>Creating Reusable Sub-Agent Patterns</h4>
        <p>Sub-agents embody Unix philosophy: do one thing well, compose for complex workflows.</p>
        <ul>
            <li><strong>Document successful patterns</strong> - When sub-agent delegation works well, document the pattern for reuse</li>
            <li><strong>Build specialized agents for recurring tasks</strong> - Create new agents for frequently needed operations</li>
            <li><strong>Each agent = one responsibility</strong> - Single purpose, well-defined input/output</li>
            <li><strong>Compose agents for complex workflows</strong> - Chain multiple agents, each handling one aspect</li>
        </ul>
        
        <h3>Operational Best Practices</h3>
        <h4>RAM Awareness</h4>
        <ul>
            <li>Check <code>RAM_ZONE</code> register regularly (especially after major operations)</li>
            <li>Report RAM status to user when entering CAUTION or DANGER zones</li>
            <li>Maintain accurate <code>CONTEXT_MANIFEST</code> register (all loaded files tracked)</li>
        </ul>
        
        <h4>Proactive Management</h4>
        <ul>
            <li>Estimate token costs before operations, not after</li>
            <li>Checkpoint at logical boundaries (end of tasks), not reactively when RAM exhausted</li>
            <li>Suggest sub-agent delegation when user requests context-heavy work</li>
        </ul>
        
        <h4>User Communication</h4>
        <ul>
            <li>Make RAM limitations visible - inform user of constraints</li>
            <li>Explain delegation decisions - "Delegating to sub-agent to save 70% RAM"</li>
            <li>Warn when approaching limits - "RAM at 82% (CAUTION), recommend checkpoint after this task"</li>
        </ul>
        
        <h3>Summary: RAM Management Decision Framework</h3>
        <p>When faced with any operation requiring data loading:</p>
        <ol>
            <li><strong>Estimate cost</strong> - How many tokens will this consume?</li>
            <li><strong>Check RAM_ZONE</strong> - What zone will I be in after loading?</li>
            <li><strong>Apply Reduce and Delegate</strong> - Can I delegate, summarize, offload, or reuse?</li>
            <li><strong>Execute with awareness</strong> - Proceed with most RAM-efficient approach</li>
            <li><strong>Update registers</strong> - Track what was loaded in CONTEXT_MANIFEST</li>
            <li><strong>Monitor continuously</strong> - Watch RAM_ZONE throughout session</li>
        </ol>
        
        <p><strong>Remember:</strong> In HAL8000-Assistant, RAM is append-only within a session. Every token loaded is permanent until session ends. Your effectiveness as a CPU is determined by how well you manage this scarce, critical resource.</p>
    </div>
</section>

            <!-- Part IV: Reference -->
            <div class="part-divider">
                <h1 class="part-header">Part IV: Reference</h1>
                <p class="part-description">Complete reference for commands, agents, conventions, and components</p>
            </div>

            <!-- Section 15: Command Reference -->
            <section id="command-reference" data-status="complete" data-priority="2"
         data-sources=".claude/commands/" data-estimated-tokens="15000"
         data-dependencies="">

  <div class="meta-guidance" style="display:none;">
    This section documents all HAL8000-Assistant system commands as executable instructions.
    Commands are stored programs that map directly to architectural operations.
    Maintenance: Update when new commands added to .claude/commands/, verify examples are current.
    Each command entry must include: purpose, syntax, implementation, architecture alignment, examples.
  </div>

  <h2>15. Command Reference</h2>

  <p>
    HAL8000-Assistant provides a suite of system commands that control CPU operations, manage context, maintain system health, and enable efficient session continuity. Commands are invoked using slash notation and map directly to architectural operations, following assembly language principles of explicit control and low-level visibility.
  </p>

    <!-- Overview -->
    <h3>Command System Overview</h3>
    <p>
      Commands in HAL8000-Assistant are stored as executable instruction files in <code>.claude/commands/</code> with the naming convention <code>HAL-command-name.md</code>. Each command file contains complete implementation specifications that the CPU (Claude instance) executes when invoked.
    </p>
    <p>
      The command system embodies HAL8000-Assistant's core architectural principles:
    </p>
    <ul>
      <li><strong>Von Neumann Architecture:</strong> Commands are stored programs in unified memory space, loaded and executed by the CPU</li>
      <li><strong>Unix Philosophy:</strong> Each command does one thing well, composes with others, and operates on text files</li>
      <li><strong>Assembly Language:</strong> Direct mapping to system operations with explicit control flow and state management</li>
      <li><strong>Self-Modifying Code:</strong> Commands can create and modify other commands at runtime</li>
    </ul>

    <h4>Invocation Syntax</h4>
    <p>
      Commands are invoked using slash notation:
    </p>
    <pre><code>/HAL-command-name [arguments]</code></pre>
    <p>
      The CPU fetches the command definition, decodes the intent, executes the operations, and updates registers accordingly‚Äîmirroring the classical fetch-decode-execute cycle of traditional processors.
    </p>

    <h4>Command Structure</h4>
    <p>
      Each command file includes:
    </p>
    <ul>
      <li><strong>Frontmatter:</strong> Metadata (name, description, arguments, allowed tools)</li>
      <li><strong>Purpose:</strong> Clear statement of what the command does</li>
      <li><strong>Usage:</strong> Syntax and examples</li>
      <li><strong>Implementation:</strong> Step-by-step execution logic</li>
      <li><strong>Architecture Alignment:</strong> How the command embodies system principles</li>
      <li><strong>Error Handling:</strong> Expected failure modes and recovery</li>
    </ul>

    <!-- Command Categories -->
    <h3>Command Categories</h3>
    <p>
      HAL8000-Assistant commands are organized into six functional categories:
    </p>

    <div class="command-categories">
      <div class="category-block">
        <h4>Session Management</h4>
        <p>Commands for managing session continuity across RAM wipes</p>
        <ul>
          <li><a href="#hal-session-end">/HAL-session-end</a> - Save state before context reset</li>
        </ul>
      </div>

      <div class="category-block">
        <h4>System Introspection</h4>
        <p>Commands for inspecting CPU and system state</p>
        <ul>
          <li><a href="#hal-register-dump">/HAL-register-dump</a> - Display register state</li>
        </ul>
      </div>

      <div class="category-block">
        <h4>System Health</h4>
        <p>Commands for validating system integrity and compatibility</p>
        <ul>
          <li><a href="#hal-system-check">/HAL-system-check</a> - Audit internal structure</li>
          <li><a href="#hal-cc-check">/HAL-CC-check</a> - Validate Claude Code compatibility</li>
        </ul>
      </div>

      <div class="category-block">
        <h4>Context Discovery</h4>
        <p>Commands for efficient context loading</p>
        <ul>
          <li><a href="#hal-context-find">/HAL-context-find</a> - Find and load system context</li>
        </ul>
      </div>

      <div class="category-block">
        <h4>Maintenance</h4>
        <p>Commands for maintaining indexes, libraries, and knowledge organization</p>
        <ul>
          <li><a href="#hal-index-update">/HAL-index-update</a> - Update file system indexes</li>
          <li><a href="#hal-library-update">/HAL-library-update</a> - Update external libraries</li>
          <li><a href="#hal-knowledge-ingest">/HAL-knowledge-ingest</a> - Ingest and organize knowledge automatically</li>
        </ul>
      </div>

      <div class="category-block">
        <h4>Integration</h4>
        <p>Commands for managing external integrations and documentation</p>
        <ul>
          <li><a href="#hal-mcp-control">/HAL-mcp-control</a> - Control MCP servers</li>
          <li><a href="#hal-refman">/HAL-refman</a> - Manage reference manual development</li>
        </ul>
      </div>
    </div>

    <!-- Individual Commands -->
    <h3>Command Specifications</h3>

    <!-- HAL-session-end -->
    <div class="command-entry">
      <h3 id="hal-session-end">/HAL-session-end</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> End current session and save state for continuity after RAM wipe</p>
        <p><strong>Category:</strong> Session Management</p>
        <p><strong>Syntax:</strong> <code>/HAL-session-end "session-description"</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>session-description</code> (required) - Brief description of the session (e.g., "architecture-design", "unix-research")</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command implements the session continuity protocol by capturing current state and creating a handoff file for resuming work after context reset. It performs five critical operations:</p>
        <ol>
          <li><strong>Captures Current Context:</strong> Gathers information about active work, loaded files, key decisions, and next steps</li>
          <li><strong>Creates Session File:</strong> Generates timestamped markdown file in <code>.claude/sessions/</code> with format <code>YYYY-MM-DD-HHMM-description.md</code></li>
          <li><strong>Validates State Counts:</strong> Counts actual filesystem state (agents, commands, content files, indexes) to prevent drift</li>
          <li><strong>Updates state.json:</strong> Writes current state with validated counts and points to new session file</li>
          <li><strong>Logs to History:</strong> Appends entry to <code>.claude/system.log</code> for audit trail</li>
        </ol>

        <p><strong>Session File Structure:</strong></p>
        <pre><code># Session: YYYY-MM-DD HH:MM - [Description]

## Context
[High-level description of current work]

## Key Decisions Made
- [Important architectural or design decisions]
- [Agreements reached]
- [Approaches chosen]

## Active Work
**Current Task:** [What we're doing right now]

**Completed in This Session:**
- Task 1
- Task 2

**Next Steps:**
1. [What should happen next]
2. [Follow-up tasks]

**Blockers:** [Any issues or dependencies]

## Files in Context
[List files that were actively being worked on]

## Variables/State
- current_project: [value]
- phase: [value]

## Instructions for Resume
When resuming this session:
1. [First thing to do]
2. [What to load into context]
3. [How to continue the work]</code></pre>

        <p><strong>State Validation Process:</strong></p>
        <p>The command includes inline filesystem validation to ensure state.json accuracy:</p>
        <pre><code>AGENTS_COUNT=$(ls .claude/agents/*.md 2>/dev/null | wc -l)
COMMANDS_COUNT=$(ls .claude/commands/HAL-*.md 2>/dev/null | wc -l)
CONTENT_COUNT=$(find data -name "*.md" 2>/dev/null | wc -l)
INDEXES_COUNT=$(ls .claude/indexes/*.json 2>/dev/null | grep -v master.json | wc -l)</code></pre>
        <p><strong>Rationale:</strong> Direct filesystem counting prevents manual update errors and state drift. These counts represent ground truth.</p>

        <p><strong>Usage Example:</strong></p>
        <pre><code>/HAL-session-end architecture-design</code></pre>

        <p><strong>Output:</strong></p>
        <pre><code>‚úì Session saved: .claude/sessions/2025-10-04-1453-architecture-design.md
‚úì State validated and updated: .claude/state.json
  - Agents: 4
  - Content files: 22
  - Indexes: 5
‚úì Logged to: .claude/system.log

System ready for RAM wipe.
To resume: Start new session and say "Resume last session"</code></pre>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>Missing description: Prompts for required argument</li>
          <li>File write failure: Reports error and suggests manual checkpoint</li>
          <li>State validation failure: Reports count mismatches and continues with best-effort update</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Von Neumann:</strong> Session files are stored-program concept (state as data); commands can be self-modifying (creates session files that guide future execution)</li>
          <li><strong>Unix Philosophy:</strong> Does one thing well (session checkpointing); outputs to text files (JSON, markdown); composable (works with boot sequence)</li>
          <li><strong>Assembly Principles:</strong> Explicit state management (no hidden state); direct file I/O (writes to specific memory locations); low-level control (manual checkpoint triggering)</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>CLAUDE.md</code> - BIOS boot sequence that loads state.json</li>
          <li><code>.claude/state.json</code> - Current system state pointer</li>
          <li><code>.claude/sessions/</code> - Historical session files</li>
          <li><code>.claude/system.log</code> - Audit trail</li>
        </ul>
      </div>
    </div>

    <!-- HAL-register-dump -->
    <div class="command-entry">
      <h3 id="hal-register-dump">/HAL-register-dump</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Display current CPU register state for system introspection and debugging</p>
        <p><strong>Category:</strong> System Introspection</p>
        <p><strong>Syntax:</strong> <code>/HAL-register-dump</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li>None required</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command provides assembly-level introspection by aggregating and displaying the CPU's virtual registers. Registers represent runtime state scattered across the system, aggregated on-demand for human-readable output.</p>

        <p>The CPU executes this command by:</p>
        <ol>
          <li><strong>Extracting RAM State:</strong> Parses most recent system warning for token usage (<code>Token usage: 58432/200000</code>)</li>
          <li><strong>Reading state.json:</strong> Loads persistent state (active_session, variables, loaded_commands)</li>
          <li><strong>Evaluating Runtime State:</strong> Determines current instruction (IR), execution mode, CPU status, error state</li>
          <li><strong>Calculating Derived Values:</strong> Computes RAM_ZONE from usage percentage, SESSION_DURATION from SESSION_START, rate limit estimate</li>
          <li><strong>Formatting Output:</strong> Displays organized register categories with human-readable values</li>
        </ol>

        <p><strong>Register Categories:</strong></p>
        <ul>
          <li><strong>Control Registers:</strong> PC (Program Counter), IR (Instruction Register), EXEC_MODE, FLOW_STATE</li>
          <li><strong>Memory Registers:</strong> RAM_USAGE, RAM_CAPACITY, RAM_REMAINING, RAM_ZONE, CONTEXT_MANIFEST</li>
          <li><strong>State Registers:</strong> SESSION_ID, SESSION_START, SESSION_DURATION, CHECKPOINT_STATUS, PHASE, LOADED_COMMANDS</li>
          <li><strong>Status Registers:</strong> CPU_STATUS, RATE_LIMIT_STATUS, ERROR_FLAG, ERROR_CODE</li>
          <li><strong>Data Registers:</strong> ACC (Accumulator), VARS (Session Variables), RESULT (Last Operation)</li>
        </ul>

        <p><strong>Usage Example:</strong></p>
        <pre><code>/HAL-register-dump</code></pre>

        <p><strong>Output Format:</strong></p>
        <pre><code>================================================================================
                        HAL8000-Assistant REGISTER DUMP
================================================================================
Timestamp: 2025-10-04T15:30:45Z
Model: claude-sonnet-4-5-20250929

[CONTROL REGISTERS]
  PC (Program Counter)        : null
  IR (Instruction Register)   : Show register state
  EXEC_MODE                   : INTERACTIVE
  FLOW_STATE                  : Executing register dump command

[MEMORY REGISTERS]
  RAM_USAGE                   : 58,432 tokens
  RAM_CAPACITY                : 200,000 tokens
  RAM_REMAINING               : 141,568 tokens
  RAM_ZONE                    : SAFE (29% used)
  CONTEXT_MANIFEST            : 5 files loaded
    - CLAUDE.md
    - .claude/state.json
    - .claude/sessions/2025-10-04-1305-session.md
    - data/research/04-claude-code-runtime-constraints.md
    - .claude/commands/HAL-register-dump.md

[STATE REGISTERS]
  SESSION_ID                  : .claude/sessions/2025-10-04-1305-session.md
  SESSION_START               : 2025-10-04T14:23:15Z
  SESSION_DURATION            : 1h 7m 30s
  CHECKPOINT_STATUS           :
    - Last checkpoint         : 2025-10-04T13:05:18Z
    - Checkpoint file         : .claude/sessions/2025-10-04-1305-session.md
    - Changes since checkpoint: true
  PHASE                       : register-architecture-complete
  LOADED_COMMANDS             : 2 commands
    - HAL-session-end
    - HAL-register-dump

[STATUS REGISTERS]
  CPU_STATUS                  : OPERATIONAL ‚úì
  RATE_LIMIT_STATUS           :
    - Limited                 : false
    - Usage estimate          : ~15%
    - Reset cycle             : 5 hours
  ERROR_FLAG                  : false
  ERROR_CODE                  : null

[DATA REGISTERS]
  ACC (Accumulator)           : Executing register dump
  VARS (Session Variables)    : 4 variables
    - current_project         : HAL8000-Assistant architecture
    - architecture_type       : Modified von Neumann
    - depth_limit             : 3
    - phase                   : register-architecture-complete
  RESULT (Last Operation)     : Command file created successfully

================================================================================
                            SYSTEM STATUS: OPERATIONAL
RAM: SAFE | CPU: OPERATIONAL | Session: Active | Errors: None
================================================================================</code></pre>

        <p><strong>Use Cases:</strong></p>
        <ul>
          <li><strong>Debugging:</strong> Check system state when troubleshooting (shows ERROR_FLAG and ERROR_CODE)</li>
          <li><strong>Resource Monitoring:</strong> Monitor RAM usage during intensive operations (RAM_ZONE warnings)</li>
          <li><strong>Session Inspection:</strong> Understand current session state (SESSION_ID, PHASE, loaded files)</li>
          <li><strong>System Verification:</strong> Verify CPU operational status and health</li>
          <li><strong>Learning:</strong> Understand how the system works by observing live register state</li>
        </ul>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>No errors expected (read-only operation)</li>
          <li>Missing state.json: Reports DEGRADED mode with unknown values</li>
          <li>Register values unavailable: Shows "null" or "unknown" for missing data</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <p>This command implements the introspection capability fundamental to assembly-level programming. In traditional assembly, developers can inspect CPU registers directly (e.g., REGISTER DUMP or debugger commands). HAL8000-Assistant provides the same capability for the virtual CPU.</p>
        <ul>
          <li><strong>Read-Only:</strong> Does NOT modify any registers, only reads and displays current state</li>
          <li><strong>Snapshot Nature:</strong> Values reflect state at moment of execution</li>
          <li><strong>Virtual Registers:</strong> Registers are not stored in a file; command aggregates state from multiple sources on-demand</li>
          <li><strong>Performance Impact:</strong> Minimal (~2-3K tokens for output itself), no file I/O required</li>
        </ul>

        <p><strong>Related Commands:</strong></p>
        <ul>
          <li><code>/HAL-session-end</code> - Updates CHECKPOINT_STATUS register</li>
          <li>File loading operations - Affect CONTEXT_MANIFEST and RAM_USAGE registers</li>
        </ul>
      </div>
    </div>

    <!-- HAL-system-check -->
    <div class="command-entry">
      <h3 id="hal-system-check">/HAL-system-check</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Launch system-maintenance sub-agent to perform comprehensive HAL8000-Assistant integrity audit</p>
        <p><strong>Category:</strong> System Health</p>
        <p><strong>Syntax:</strong> <code>/HAL-system-check</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li>None required</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command delegates comprehensive system audit to the <code>system-maintenance</code> specialized agent, ensuring architecture remains compliant with principles as the system grows.</p>

        <p>When invoked, the CPU immediately launches the sub-agent (via Task tool, general-purpose type) to perform:</p>
        <ol>
          <li><strong>Load Required Context:</strong> BIOS (CLAUDE.md), architecture specs, state.json, master index</li>
          <li><strong>Check File System Structure:</strong> Verify required directories exist, depth limit compliance (max 3 levels)</li>
          <li><strong>Validate Indexes:</strong> Master index + directory indexes synchronized and current</li>
          <li><strong>Verify State:</strong> state.json valid, active session exists, loaded commands present</li>
          <li><strong>Assess Principle Compliance:</strong> Unix philosophy, von Neumann architecture, Operating Principles adherence</li>
          <li><strong>Check File Consistency:</strong> Naming conventions, no orphans, proper categorization</li>
          <li><strong>Generate Audit Report:</strong> Structural integrity, index health, state validation, recommendations</li>
          <li><strong>Return Summary:</strong> Clean, actionable report preserving main context (under 5K tokens)</li>
        </ol>

        <p><strong>Agent Specification:</strong></p>
        <p>See <code>.claude/agents/system-maintenance.md</code> for complete audit checklist and validation criteria.</p>

        <p><strong>Usage Example:</strong></p>
        <pre><code>/HAL-system-check</code></pre>

        <p><strong>Expected Output:</strong></p>
        <pre><code>‚úÖ HAL8000-Assistant SYSTEM HEALTH CHECK

Overall Status: HEALTHY

Executive Summary:
- File system structure: ‚úì Valid
- Index health: ‚úì Synchronized
- State validation: ‚úì Consistent
- Principle compliance: ‚úì Adhering
- File consistency: ‚ö† Minor issues

Findings:

[Structural Integrity]
‚úì All required directories present
‚úì Depth limit compliance: 100% (0 violations)
‚úì Directory organization: Correct

[Index Health]
‚úì Master index: Current (last updated: 2025-10-04)
‚úì Directory indexes: 5/5 synchronized
‚ö† Library index: Stale (last updated 2 days ago)

[State Validation]
‚úì state.json: Valid JSON, all required fields present
‚úì Active session: Exists and accessible
‚úì Loaded commands: All files present

[Principle Compliance]
‚úì Unix philosophy: Single responsibility maintained
‚úì Von Neumann: Stored-program structure correct
‚úì Depth limit: No violations (max depth: 3)

[File Consistency]
‚úì Naming conventions: 100% compliant
‚úì No orphaned files detected
‚ö† 2 session files missing metadata headers

Critical Actions Required: None

Optional Improvements:
1. Run /HAL-index-update to refresh library index
2. Add metadata headers to session files:
   - .claude/sessions/2025-09-30-1234-work.md
   - .claude/sessions/2025-10-01-0800-research.md

System Statistics:
- Total files: 47
- Commands: 9
- Agents: 5
- Sessions: 12
- Content files: 21</code></pre>

        <p><strong>Sub-Agent Benefits:</strong></p>
        <ul>
          <li><strong>RAM Efficiency:</strong> Agent uses isolated 200K context, returns only compact report (~5K tokens)</li>
          <li><strong>Main Session Impact:</strong> 97% RAM reduction vs direct audit</li>
          <li><strong>Architecture Compliance:</strong> Follows "Reduce and Delegate" principle; sub-agent = virtual memory extension</li>
        </ul>

        <p><strong>When to Run:</strong></p>
        <p><strong>Regular Triggers:</strong></p>
        <ul>
          <li>After major architectural changes</li>
          <li>Before starting new project phase</li>
          <li>After creating many new files</li>
          <li>Weekly maintenance check</li>
        </ul>
        <p><strong>Problem Triggers:</strong></p>
        <ul>
          <li>Suspicion of corrupted state</li>
          <li>Index seems out of sync</li>
          <li>File structure seems wrong</li>
          <li>Performance degradation</li>
        </ul>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>Agent launch failure: Reports error and suggests manual validation</li>
          <li>Critical issues found: Marks status as CRITICAL and lists required actions</li>
          <li>Warnings found: Marks status with ‚ö† and provides improvement recommendations</li>
        </ul>

        <p><strong>Success Criteria:</strong></p>
        <ul>
          <li>Audit completes without errors</li>
          <li>All components assessed for integrity</li>
          <li>Clear, actionable report generated</li>
          <li>System health status determined (HEALTHY | WARNINGS | CRITICAL)</li>
          <li>Recommendations provided for any issues</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Delegation Pattern:</strong> Context-heavy audit offloaded to sub-agent with fresh 200K RAM</li>
          <li><strong>Unix Philosophy:</strong> Does one thing well (system audit); delegates specialized work (to agent)</li>
          <li><strong>RAM Optimization:</strong> Main session cost: ~5K tokens vs ~150K for direct implementation</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>.claude/agents/system-maintenance.md</code> - Agent definition with audit checklist</li>
          <li><code>.claude/indexes/master.json</code> - Validated during check</li>
          <li><code>.claude/state.json</code> - Validated during check</li>
          <li><code>CLAUDE.md</code> - Principle compliance reference</li>
        </ul>
      </div>
    </div>

    <!-- HAL-context-find -->
    <div class="command-entry">
      <h3 id="hal-context-find">/HAL-context-find</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Find and load system context without consuming main session RAM</p>
        <p><strong>Category:</strong> Context Discovery</p>
        <p><strong>Syntax:</strong> <code>/HAL-context-find query</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>query</code> (required) - What context you're looking for (e.g., "register architecture", "HAL-session-end command", "von Neumann research")</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command launches the <code>hal-context-finder</code> specialized agent to discover and load HAL8000-Assistant system context efficiently, preserving main session RAM by delegating navigation and file loading to an isolated sub-agent context.</p>

        <p>The command executes in four stages:</p>
        <ol>
          <li><strong>Launch Specialized Agent:</strong> Spawns <code>hal-context-finder</code> sub-agent with fresh 200K RAM, passes user query</li>
          <li><strong>Efficient Navigation:</strong> Agent classifies query type (Architecture, Command, Research, Session, Data), uses built-in directory priority mappings for smart targeting, focuses on 2-3 most likely directories</li>
          <li><strong>Complete Content Loading:</strong> Agent reads complete files (not just paths), packages content with clear source attribution, includes related context when relevant</li>
          <li><strong>RAM Preservation:</strong> Main session RAM += summary only (not full navigation cost), typically saves 60-80% tokens, agent context automatically garbage collected</li>
        </ol>

        <p><strong>Query Type Classification:</strong></p>
        <ul>
          <li><strong>Architecture Queries:</strong> Targets <code>data/architecture/</code> (e.g., "register architecture", "system design")</li>
          <li><strong>Command Queries:</strong> Targets <code>.claude/commands/</code> (e.g., "HAL-session-end command", "available commands")</li>
          <li><strong>Research Queries:</strong> Targets <code>data/research/</code> (e.g., "von Neumann architecture", "Unix philosophy")</li>
          <li><strong>Session Queries:</strong> Targets <code>.claude/sessions/</code>, <code>.claude/state.json</code> (e.g., "last session", "previous work")</li>
          <li><strong>Agent Queries:</strong> Targets <code>.claude/agents/</code> (e.g., "research-synthesizer agent", "available agents")</li>
        </ul>

        <p><strong>Usage Examples:</strong></p>
        <pre><code>/HAL-context-find register architecture
/HAL-context-find HAL-session-end command
/HAL-context-find von Neumann architecture
/HAL-context-find last session
/HAL-context-find research-synthesizer agent</code></pre>

        <p><strong>Expected Output Structure:</strong></p>
        <pre><code>## Context Content
[Complete file contents with clear source headers]

### File: /mnt/d/~HAL8000-Assistant/data/architecture/hal8000-register-architecture.md
[Full file content...]

### File: /mnt/d/~HAL8000-Assistant/.claude/commands/HAL-register-dump.md
[Full file content...]

## File Locations
- /mnt/d/~HAL8000-Assistant/data/architecture/hal8000-register-architecture.md
- /mnt/d/~HAL8000-Assistant/.claude/commands/HAL-register-dump.md

## Summary
Found 2 relevant files for query "register architecture".
The register architecture specification defines all 21 CPU registers organized into 5 categories.
The HAL-register-dump command provides introspection capability to view register state.

## Related Context
- data/research/04-claude-code-runtime-constraints.md - Runtime limits affecting RAM registers
- CLAUDE.md - BIOS references to register usage</code></pre>

        <p><strong>Token Economics:</strong></p>
        <table>
          <tr>
            <th>Approach</th>
            <th>Main Session Cost</th>
            <th>Details</th>
          </tr>
          <tr>
            <td>Direct Loading</td>
            <td>~30K tokens</td>
            <td>Navigate dirs (+10K) + Read files (+15K) + Filter (+5K)</td>
          </tr>
          <tr>
            <td>Agent Delegation</td>
            <td>~5K tokens</td>
            <td>Launch (+1K) + Receive summary (+4K). Agent uses ~30K in isolated context (auto-collected)</td>
          </tr>
          <tr>
            <td><strong>Savings</strong></td>
            <td><strong>83%</strong></td>
            <td>25K tokens saved per invocation</td>
          </tr>
        </table>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>Query too broad: Agent returns top matches and suggests refining query</li>
          <li>No matches found: Agent reports search locations checked and suggests alternative queries</li>
          <li>Agent launch failure: Falls back to direct file system navigation with warning about RAM cost</li>
        </ul>

        <p><strong>When to Use:</strong></p>
        <p><strong>ALWAYS use for:</strong></p>
        <ul>
          <li>Loading architecture documentation</li>
          <li>Discovering command definitions</li>
          <li>Accessing research files</li>
          <li>Exploring session history</li>
          <li>Finding agent definitions</li>
          <li>Any context-heavy navigation task</li>
        </ul>
        <p><strong>DON'T use for:</strong></p>
        <ul>
          <li>Files with known exact paths (use Read directly)</li>
          <li>Single small files (under 2K tokens)</li>
          <li>Current session state (already in RAM)</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Von Neumann:</strong> Sub-agent as virtual memory extension (isolated address space); stored-program concept (agent definition is data that executes)</li>
          <li><strong>Unix Philosophy:</strong> Does one thing well (context discovery); delegates specialized work (to sub-agent); text-based I/O (structured markdown output)</li>
          <li><strong>Assembly Principles:</strong> Explicit control (manual invocation); low-level visibility (shows exact file paths); efficient resource usage</li>
          <li><strong>Sub-Agent Protocol:</strong> Extends total RAM capacity through process isolation; agent has fresh 200K context, returns only summary; input (query) >> output (summary)</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>.claude/agents/hal-context-finder.md</code> - Agent definition</li>
          <li><code>.claude/indexes/master.json</code> - System inventory for discovery</li>
          <li><code>CLAUDE.md</code> - Defines sub-agent protocol</li>
        </ul>
      </div>
    </div>

    <!-- HAL-index-update -->
    <div class="command-entry">
      <h3 id="hal-index-update">/HAL-index-update</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Update hierarchical file system indexes and library index with metadata for efficient discovery</p>
        <p><strong>Category:</strong> Maintenance</p>
        <p><strong>Syntax:</strong> <code>/HAL-index-update [path]</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>path</code> (optional) - Directory to index (default: entire system from root)</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command updates both the hierarchical file system indexes and the library index, enabling efficient discovery of relevant files and libraries without loading the entire file system into RAM.</p>

        <p>The indexing process operates in two parallel tracks:</p>

        <h4>Track 1: File System Indexing</h4>
        <ol>
          <li><strong>Identify Target Directories:</strong> Index all major directories (no path specified) or specific directory (path specified)</li>
          <li><strong>Discover Files per Directory:</strong> Use Glob to find all files (*.md, *.json, etc.)</li>
          <li><strong>Extract Metadata:</strong> For each file, extract type, category, topics (from name/headers), summary (first sentence), size estimate</li>
          <li><strong>Update Directory Index:</strong> Create/update <code>.claude/indexes/[directory-name].json</code> with file entries and directory statistics</li>
          <li><strong>Update Master Index:</strong> Update <code>.claude/indexes/master.json</code> with directory entry pointing to directory index</li>
        </ol>

        <h4>Track 2: Library Indexing</h4>
        <ol>
          <li><strong>Index Internal Libraries:</strong> Parse frontmatter from <code>.claude/libraries/internal/</code> files for metadata (title, description, keywords, category, dependencies)</li>
          <li><strong>Index External Libraries:</strong> Scan content from <code>.claude/libraries/external/</code> files to extract metadata (title from H1, description from first paragraph, keywords from headings)</li>
          <li><strong>Update Library Index:</strong> Create/update <code>.claude/libraries/index.json</code> with library entries, source tracking, statistics</li>
        </ol>

        <p><strong>Hierarchical Index Structure:</strong></p>
        <pre><code>.claude/indexes/
‚îú‚îÄ‚îÄ master.json           # Lightweight master index (~500 tokens for 100 dirs)
‚îú‚îÄ‚îÄ research.json         # data/research/ files
‚îú‚îÄ‚îÄ architecture.json     # data/architecture/ files
‚îú‚îÄ‚îÄ commands.json         # .claude/commands/ files
‚îú‚îÄ‚îÄ sessions.json         # .claude/sessions/ files
‚îî‚îÄ‚îÄ [project-name].json   # Future: per-project indexes</code></pre>

        <p><strong>Scalability:</strong></p>
        <ul>
          <li>Master index: ~10 tokens per directory (stays tiny)</li>
          <li>Directory index: ~2K tokens per directory</li>
          <li>1,000 directories = 10K master + 2K per dir loaded on-demand</li>
          <li><strong>Load master first, then only the directory indexes you need</strong></li>
        </ul>

        <p><strong>Master Index Format:</strong></p>
        <pre><code>{
  "version": "2.0-hierarchical",
  "last_updated": "2025-10-04T15:15:00Z",
  "directories": {
    "data/research/": {
      "index_file": ".claude/indexes/research.json",
      "file_count": 4,
      "total_tokens_estimate": 12300,
      "primary_topics": ["architecture", "unix", "assembly"]
    }
  },
  "statistics": {
    "total_directories": 5,
    "total_files": 15,
    "total_estimated_tokens": 39800
  }
}</code></pre>

        <p><strong>Directory Index Format:</strong></p>
        <pre><code>{
  "version": "2.0-hierarchical",
  "directory": "data/research/",
  "files": {
    "data/research/01-von-neumann-architecture.md": {
      "type": "research",
      "category": "architecture-theory",
      "topics": ["von neumann", "stored program"],
      "summary": "Von Neumann architecture principles",
      "size_estimate_tokens": 3200
    }
  },
  "statistics": {
    "total_files": 4,
    "total_tokens_estimate": 12300
  }
}</code></pre>

        <p><strong>Library Index Format:</strong></p>
        <pre><code>{
  "version": "1.0",
  "libraries": [
    {
      "path": ".claude/libraries/internal/development/code-review.md",
      "source": "internal",
      "title": "Code Review Workflow",
      "description": "...",
      "keywords": ["code-review", "quality"],
      "category": "development",
      "metadata_source": "frontmatter",
      "size_estimate_tokens": 1200
    },
    {
      "path": ".claude/libraries/external/lib-xyz/file.md",
      "source": "external:lib-xyz",
      "title": "Extracted from H1",
      "description": "...",
      "keywords": ["extracted"],
      "metadata_source": "content-scan",
      "size_estimate_tokens": 800
    }
  ],
  "sources": {
    "internal": { "file_count": 12 },
    "external:lib-xyz": { "file_count": 225, "last_updated": "2025-10-04" }
  },
  "statistics": {
    "total_libraries": 237,
    "total_estimated_tokens": 189400
  }
}</code></pre>

        <p><strong>Usage Examples:</strong></p>
        <pre><code>/HAL-index-update                    # Index entire system
/HAL-index-update data/research      # Index only research directory
/HAL-index-update .claude/commands   # Index only commands directory</code></pre>

        <p><strong>Output:</strong></p>
        <pre><code>Hierarchical index updated
- Directories indexed: 4
- Total files indexed: 25
- Directory indexes updated: architecture.json, research.json, commands.json, sessions.json
- Master index: updated
- Total estimated tokens: 39,800

Library index updated
- Internal libraries: 12
- External libraries: 225 (from 1 source)
- Total libraries indexed: 237
- Library index: .claude/libraries/index.json</code></pre>

        <p><strong>RAM Management:</strong></p>
        <ul>
          <li><strong>If indexing &gt;20 files OR &gt;50 libraries:</strong> Delegate to sub-agent (general-purpose or system-maintenance); returns summary only (~500 tokens)</li>
          <li><strong>If indexing ‚â§20 files AND ‚â§50 libraries:</strong> Process directly; use Glob (no content loading); extract metadata from file names/paths only</li>
        </ul>

        <p><strong>When to Run:</strong></p>
        <p><strong>Automatic Triggers:</strong></p>
        <ul>
          <li>After creating multiple new files (3+)</li>
          <li>After major refactoring</li>
          <li>Before starting context-heavy work</li>
        </ul>
        <p><strong>Manual Triggers:</strong></p>
        <ul>
          <li>User requests index update</li>
          <li>Switching to new project phase</li>
          <li>After session resume (if files changed externally)</li>
        </ul>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>Directory not found: Reports error and suggests checking path</li>
          <li>File read failure: Skips file, continues indexing, reports skipped files</li>
          <li>JSON write failure: Reports error and suggests manual verification</li>
        </ul>

        <p><strong>Integration with Discovery System:</strong></p>
        <p>The hierarchical index enables Layer 3: Metadata Discovery in the I/O System with infinite scalability:</p>
        <ol>
          <li>Load master index (~500 tokens for 100 directories)</li>
          <li>Identify relevant directories by primary topics</li>
          <li>Load directory index (~2K tokens per directory)</li>
          <li>Search directory index by topic/keyword (in RAM, no I/O)</li>
          <li>Identify relevant files with size estimates</li>
          <li>Calculate RAM cost before loading</li>
          <li>Load selectively based on RAM budget</li>
        </ol>
        <p><strong>Total RAM cost for discovery: ~2.5K tokens (master + one directory), regardless of total file system size</strong></p>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Hierarchical Design:</strong> Master index + directory indexes = infinite scalability</li>
          <li><strong>Dual Indexing:</strong> File system (hierarchical) + libraries (flat) for different use cases</li>
          <li><strong>Metadata Extraction:</strong> Two modes (frontmatter parsing for internal, content scanning for external libraries)</li>
          <li><strong>Unix Philosophy:</strong> Does one thing well (indexing); composable with discovery commands</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>.claude/indexes/master.json</code> - Master file system index</li>
          <li><code>.claude/indexes/*.json</code> - Per-directory indexes</li>
          <li><code>.claude/libraries/index.json</code> - Library index</li>
          <li><code>/HAL-context-find</code> - Uses indexes for discovery</li>
          <li><code>data/architecture/hal8000-io-system.md</code> - I/O system design</li>
        </ul>
      </div>
    </div>

    <!-- HAL-library-update -->
    <div class="command-entry">
      <h3 id="hal-library-update">/HAL-library-update</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Update external libraries from source repositories (package manager)</p>
        <p><strong>Category:</strong> Maintenance</p>
        <p><strong>Syntax:</strong> <code>/HAL-library-update library-name</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>library-name</code> (required) - Name of the external library to update (must exist in registry)</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command is the HAL8000-Assistant package manager‚Äîit manages the lifecycle of external library collections by checking for updates, downloading new versions, and maintaining the library registry.</p>

        <p>The update process executes in nine steps:</p>
        <ol>
          <li><strong>Validate Library Exists:</strong> Check if library exists in <code>.claude/libraries/external/README.md</code> registry; extract metadata (source URL, current version, last updated, file count)</li>
          <li><strong>Check Source for Updates:</strong> For GitHub libraries, clone repository to temp directory, get latest commit hash/date, compare to current version, count file changes</li>
          <li><strong>Report Update Status:</strong> If up-to-date, confirm current version; if updates available, show changes (+N files, -N files, ~N modified)</li>
          <li><strong>User Confirmation:</strong> If updates found, ask user to confirm update; if declined, exit gracefully</li>
          <li><strong>Backup Current Version:</strong> Create <code>.claude/libraries/external/.[library-name].backup/</code> with current library (rollback capability)</li>
          <li><strong>Download and Install New Version:</strong> Download new version to temp, remove old library directory, copy new version from temp, verify file count</li>
          <li><strong>Update Registry:</strong> Edit <code>.claude/libraries/external/README.md</code> with new version, file count, last updated date</li>
          <li><strong>Reindex Library:</strong> Automatically invoke <code>/HAL-index-update</code> to update <code>.claude/libraries/index.json</code></li>
          <li><strong>Report Results:</strong> Display before/after comparison, list new/removed/modified files, show new patterns discovered</li>
        </ol>

        <p><strong>Usage Examples:</strong></p>
        <pre><code>/HAL-library-update fabric-patterns    # Update Fabric patterns from GitHub
/HAL-library-update --list             # List all external libraries
/HAL-library-update --check-all        # Check all libraries for updates (no install)</code></pre>

        <p><strong>Update Status Output (Up-to-Date):</strong></p>
        <pre><code>‚úì fabric-patterns is up-to-date
  Current version: main-20251005
  Last updated: 2025-10-05
  Files: 292</code></pre>

        <p><strong>Update Status Output (Updates Available):</strong></p>
        <pre><code>‚ö° Updates available for fabric-patterns
  Current: main-20251005 (292 files)
  Latest:  main-20251206 (305 files)
  Changes: +15 files, -2 files, ~5 modified

  Proceed with update? (y/n)</code></pre>

        <p><strong>Completion Output:</strong></p>
        <pre><code>‚úÖ fabric-patterns updated successfully

Changes:
  Before: 292 files (284K tokens)
  After:  305 files (298K tokens)
  Added: 15 new patterns
  Removed: 2 deprecated patterns
  Modified: 5 patterns updated

New patterns discovered:
  - analyze_quantum_paper
  - create_research_proposal
  - extract_legal_arguments
  ...

Library reindexed. Use /HAL-context-find to discover new patterns.</code></pre>

        <p><strong>Supported Library Sources:</strong></p>
        <ul>
          <li><strong>GitHub Repositories:</strong> Public repos with stable directory structure; update detection via commit comparison; uses <code>git ls-remote</code> to check for updates without cloning</li>
          <li><strong>Future Sources:</strong> Direct URLs (ZIP files), local directories, Git repositories (non-GitHub), package registries</li>
        </ul>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li><strong>Library not in registry:</strong> Error message with suggestion to check <code>.claude/libraries/external/README.md</code> and list available libraries</li>
          <li><strong>Source unavailable:</strong> Error with connection warning, suggests trying later or checking URL in registry</li>
          <li><strong>Download failed:</strong> Automatic rollback from backup, report rollback success</li>
          <li><strong>Index update failed:</strong> Warning that library updated but index may be stale, suggests manual <code>/HAL-index-update</code></li>
        </ul>

        <p><strong>RAM Management:</strong></p>
        <p>This command delegates to sub-agent (general-purpose) to handle:</p>
        <ul>
          <li>All git operations</li>
          <li>All file comparisons</li>
          <li>All metadata extraction</li>
          <li>All error handling</li>
        </ul>
        <p><strong>Total RAM cost: ~5-10K tokens</strong> (sub-agent summary only, not full processing context)</p>

        <p><strong>Package Manager Operations:</strong></p>
        <p>This command is the <strong>update</strong> operation of HAL8000-Assistant's package manager. Future expansion:</p>
        <pre><code>/HAL-library-install [url] [name] [category]  # Install new external library
/HAL-library-remove [name]                    # Remove external library
/HAL-library-list                             # List all libraries with status
/HAL-library-info [name]                      # Show library details
/HAL-library-search [keyword]                 # Search across all libraries</code></pre>
        <p><strong>Current status:</strong> Only <strong>update</strong> operation implemented. Others can be added as system matures.</p>

        <p><strong>When to Run:</strong></p>
        <p><strong>Regular Schedule:</strong></p>
        <ul>
          <li>Monthly for active libraries (per registry Refresh Schedule)</li>
          <li>Before starting major research/work (ensure latest patterns)</li>
          <li>When source repository announces major updates</li>
        </ul>
        <p><strong>Triggered By:</strong></p>
        <ul>
          <li>User manual check</li>
          <li>System notices library is outdated (future: automatic check)</li>
          <li>User requests specific pattern not found (might be in new version)</li>
        </ul>

        <p><strong>Integration with Library System:</strong></p>
        <p>This command completes the library lifecycle:</p>
        <ol>
          <li>Library Architecture ‚Üí Design (documented)</li>
          <li>Library Storage ‚Üí <code>.claude/libraries/</code> (directories)</li>
          <li>Library Installation ‚Üí <code>HAL-library-update</code> (this command)</li>
          <li>Library Indexing ‚Üí <code>HAL-index-update</code> (existing command)</li>
          <li>Library Discovery ‚Üí <code>HAL-context-find</code> (existing agent)</li>
          <li>Library Usage ‚Üí Load via discovery</li>
        </ol>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Package Manager Core:</strong> Update operation (install/remove planned for future)</li>
          <li><strong>Unix Philosophy:</strong> Does one thing well (library updates); composes with indexing and discovery</li>
          <li><strong>Delegation Pattern:</strong> Sub-agent handles context-heavy operations (git, comparisons, metadata)</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>data/architecture/hal8000-library-architecture.md</code> - Library architecture spec</li>
          <li><code>.claude/libraries/external/README.md</code> - Library registry</li>
          <li><code>.claude/libraries/index.json</code> - Library index</li>
          <li><code>/HAL-index-update</code> - Indexing command (auto-invoked)</li>
          <li><code>/HAL-context-find</code> - Discovery agent</li>
        </ul>
      </div>
    </div>

    <!-- HAL-knowledge-ingest -->
    <div class="command-entry">
      <h3 id="hal-knowledge-ingest">/HAL-knowledge-ingest</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Intelligently ingest and file knowledge in appropriate locations with automatic classification</p>
        <p><strong>Category:</strong> Maintenance</p>
        <p><strong>Syntax:</strong> <code>/HAL-knowledge-ingest "source" [category_hint]</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>source</code> (required) - Content source: direct text (in quotes), file path, or URL</li>
          <li><code>category_hint</code> (optional) - Force specific category: research | architecture | library | project | tools | reference</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command automates knowledge organization‚Äîit analyzes content, determines the appropriate filing location, applies consistent naming conventions, adds metadata, and updates indexes.</p>

        <p>The ingestion process executes in eight steps:</p>
        <ol>
          <li><strong>Content Acquisition:</strong> Load content based on source type (direct text, file via Read tool, URL via WebFetch tool)</li>
          <li><strong>Content Analysis:</strong> Extract title, detect content type, identify topics/keywords, classify into target category using classification logic</li>
          <li><strong>Deduplication Check:</strong> Search for similar existing content using Grep across relevant directories, report any matches to user</li>
          <li><strong>Determine Location:</strong> Based on classified category, determine target directory and filename using category-specific naming conventions</li>
          <li><strong>Format with Metadata:</strong> Add YAML frontmatter (title, date, source, category, tags) and metadata footer</li>
          <li><strong>Write File:</strong> Write formatted content to determined location using Write tool, create directories if needed with <code>mkdir -p</code>, verify file written correctly</li>
          <li><strong>Update Indexes:</strong> Invoke <code>/HAL-index-update</code> for the target directory to update file system indexes</li>
          <li><strong>Report Results:</strong> Display structured output with file path, category, tags, size, related content, and next actions</li>
        </ol>

        <p><strong>Classification Logic:</strong></p>
        <p>Content is automatically classified into one of six categories:</p>
        <ul>
          <li><strong>Research</strong> (<code>data/research/</code>) - Deep dives, academic concepts, theoretical explanations; numbered files (01-, 02-)</li>
          <li><strong>Architecture</strong> (<code>data/architecture/</code>) - System design, technical specs, ADRs; dated files (slug-YYYY-MM-DD.md)</li>
          <li><strong>Library</strong> (<code>.claude/libraries/internal/</code>) - Reusable patterns, templates, utilities; subcategorized</li>
          <li><strong>Tools</strong> (<code>data/tools/</code>) - Tool documentation, installation guides, command references</li>
          <li><strong>Reference</strong> (<code>data/reference/</code>) - Quick references, cheat sheets, lookup guides</li>
          <li><strong>Project</strong> (<code>data/projects/</code>) - Project-specific documentation, implementation notes</li>
        </ul>

        <p><strong>Usage Examples:</strong></p>
        <pre><code>/HAL-knowledge-ingest "https://example.com/article-on-caching"
/HAL-knowledge-ingest "/tmp/research-notes.md"
/HAL-knowledge-ingest "# Docker Best Practices..." architecture</code></pre>

        <p><strong>Success Output:</strong></p>
        <pre><code>‚úÖ Knowledge Ingested Successfully

üìÅ Filed as: data/architecture/fork-and-rebrand-protocol.md
üìÇ Category: architecture
üè∑Ô∏è  Tags: fork, clone, rebrand, github, migration, setup, procedure
üìä Size: 45 KB

üîó Related Content:
  - data/architecture/hal8000-versioning-guide.md
  - data/operations/GITHUB_SETUP.md

üí° Next Actions:
  - Review: Read the filed document
  - Find related: /HAL-context-find "fork rebrand"</code></pre>

        <p><strong>Classification Uncertainty Output:</strong></p>
        <pre><code>‚ö†Ô∏è  Classification Uncertain

Analyzed content could fit multiple categories:
1. research (confidence: 40%) - Contains theoretical explanations
2. architecture (confidence: 35%) - Has design patterns
3. library (confidence: 25%) - Includes code examples

Please specify category:
/HAL-knowledge-ingest "source" [research|architecture|library]</code></pre>

        <p><strong>Deduplication Output:</strong></p>
        <pre><code>‚ö†Ô∏è  Similar Content Detected

Found existing files:
  - data/research/05-caching-strategies.md (similarity: high)
  - data/architecture/cache-design-2025-09-15.md (similarity: medium)

Options:
1. File as new document (recommended if content is distinct)
2. Review existing files first
3. Cancel ingestion

Proceed? [y/n]</code></pre>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li><strong>Invalid source:</strong> Error if file doesn't exist, URL can't be fetched, or content is empty; ask user to verify</li>
          <li><strong>Classification uncertainty:</strong> If confidence is low, report ambiguity with suggested categories and ask for category_hint</li>
          <li><strong>Duplicate content:</strong> If similar content found, show existing files and ask whether to proceed, merge, or cancel</li>
          <li><strong>Write failures:</strong> Report error if directory creation or file write fails, suggest alternative location</li>
        </ul>

        <p><strong>Naming Conventions by Category:</strong></p>
        <ul>
          <li><strong>Research:</strong> <code>[NN]-[slug].md</code> (e.g., 07-redis-internals.md) - uses Glob to find next number</li>
          <li><strong>Architecture:</strong> <code>[slug]-[YYYY-MM-DD].md</code> (e.g., session-continuity-design-2025-10-16.md)</li>
          <li><strong>Library:</strong> <code>[subcategory]/[slug].md</code> (e.g., patterns/error-handling.md)</li>
          <li><strong>Tools:</strong> <code>[tool-name]-[topic].md</code> (e.g., docker-best-practices.md)</li>
          <li><strong>Reference:</strong> <code>[topic]-reference.md</code> (e.g., bash-reference.md)</li>
          <li><strong>Project:</strong> <code>[project-name]/[topic].md</code> (e.g., implementation-notes.md)</li>
        </ul>

        <p><strong>Metadata Format:</strong></p>
        <p>All ingested files receive standardized frontmatter:</p>
        <pre><code>---
title: [Extracted Title]
date_ingested: [YYYY-MM-DD]
source: [original source - URL, file path, or "direct input"]
category: [assigned category]
tags: [comma-separated keywords]
---

# [Title]

[Original content]

---

**Metadata:**
- Ingested: [YYYY-MM-DD HH:MM:SS]
- Source: [source]
- Classification: [category] (confidence: high/medium)
- Related: [related file paths if found]</code></pre>

        <p><strong>Benefits:</strong></p>
        <ul>
          <li><strong>No Manual Organization:</strong> Automatic classification eliminates filing decisions</li>
          <li><strong>Consistent Structure:</strong> Uniform naming conventions across all categories</li>
          <li><strong>Searchable Metadata:</strong> Tags and frontmatter enable content discovery</li>
          <li><strong>Deduplication:</strong> Prevents redundant content filing</li>
          <li><strong>Index Integration:</strong> Automatic index updates maintain discoverability</li>
        </ul>

        <p><strong>When to Use:</strong></p>
        <ul>
          <li>Found useful article/documentation online (use URL source)</li>
          <li>Created notes in temp file (use file path source)</li>
          <li>Have knowledge to preserve (use direct text source)</li>
          <li>Unsure where to file something (let classification decide)</li>
          <li>Want consistent organization (automatic naming and structure)</li>
        </ul>

        <p><strong>Tool Usage:</strong></p>
        <ul>
          <li><strong>Read:</strong> Load file path sources</li>
          <li><strong>Write:</strong> Create formatted files at target location</li>
          <li><strong>Glob:</strong> Find existing numbered files (research category)</li>
          <li><strong>Grep:</strong> Search for similar content (deduplication)</li>
          <li><strong>Bash:</strong> Create directories (<code>mkdir -p</code>), get timestamps</li>
          <li><strong>WebFetch:</strong> Fetch URL sources</li>
          <li><strong>SlashCommand:</strong> Invoke <code>/HAL-index-update</code></li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Unix Philosophy:</strong> Does one thing well (knowledge ingestion); composes with indexing and discovery</li>
          <li><strong>Level 2 Workflow:</strong> Sequential multi-step process with clear phases</li>
          <li><strong>Optimized for Claude Code:</strong> Uses Glob instead of bash commands for file discovery (v1.0.1 optimization)</li>
          <li><strong>Memory Efficiency:</strong> Processes content inline without sub-agent delegation (suitable for moderate content sizes)</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>/HAL-index-update</code> - Indexing command (auto-invoked after ingestion)</li>
          <li><code>/HAL-context-find</code> - Discovery agent (find related content)</li>
          <li><code>.claude/libraries/internal/templates/level-2-workflow.md</code> - Template used for command creation</li>
          <li><code>data/architecture/</code> - Architecture documentation (ingestion target)</li>
          <li><code>data/research/</code> - Research documentation (ingestion target)</li>
          <li><code>.claude/libraries/internal/</code> - Library content (ingestion target)</li>
        </ul>

        <p><strong>Version History:</strong></p>
        <ul>
          <li><strong>v1.0.1</strong> (2025-10-16) - Optimized for Claude Code best practices (Glob instead of bash)</li>
          <li><strong>v1.0</strong> (2025-10-16) - Initial implementation</li>
        </ul>
      </div>
    </div>

    <!-- HAL-mcp-control -->
    <div class="command-entry">
      <h3 id="hal-mcp-control">/HAL-mcp-control</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Selectively enable/disable MCP servers for RAM optimization</p>
        <p><strong>Category:</strong> Integration</p>
        <p><strong>Syntax:</strong> <code>/HAL-mcp-control [status|enable|disable] [server_name]</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>status</code> - Show all available MCP servers and their current state</li>
          <li><code>enable [server_name]</code> - Enable specified MCP server</li>
          <li><code>disable [server_name]</code> - Disable specified MCP server</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>MCP servers are Extended I/O interfaces (tools). Each enabled server costs ~500-1000 tokens on session boot. This command provides dynamic control by executing the Python script <code>.claude/tools/mcp/control.py</code> with provided arguments.</p>

        <p><strong>Execution:</strong></p>
        <pre><code>python3 ".claude/tools/mcp/control.py" $1 $2</code></pre>

        <h4>Status Operation</h4>
        <p><strong>Syntax:</strong> <code>/HAL-mcp-control status</code></p>
        <p>Shows all available MCP servers, their current state (enabled/disabled), dependencies, and RAM cost.</p>

        <h4>Enable Operation</h4>
        <p><strong>Syntax:</strong> <code>/HAL-mcp-control enable &lt;server_name&gt;</code></p>
        <p>What happens when enabling a server:</p>
        <ol>
          <li>Validates server exists in registry</li>
          <li>Checks required API keys in .env files</li>
          <li>Adds server to <code>.claude/settings.local.json</code> (enabledMcpjsonServers)</li>
          <li>Adds server definition to <code>.mcp.json</code></li>
          <li>Sets <code>enableAllProjectMcpServers: false</code> for selective control</li>
          <li>Prompts for session restart</li>
        </ol>

        <h4>Disable Operation</h4>
        <p><strong>Syntax:</strong> <code>/HAL-mcp-control disable &lt;server_name&gt;</code></p>
        <p>What happens when disabling a server:</p>
        <ol>
          <li>Warns if disabling required server</li>
          <li>Removes from enabledMcpjsonServers array</li>
          <li>Removes definition from .mcp.json</li>
          <li>Prompts for session restart</li>
        </ol>
        <p><strong>Note:</strong> Disabling required servers (like <code>omnisearch</code>) may break agents that depend on them.</p>

        <p><strong>Available Servers:</strong></p>
        <p>Server registry maintained in <code>.claude/tools/mcp/registry.json</code>. Current servers:</p>

        <ul>
          <li>
            <strong>omnisearch (Required)</strong>
            <ul>
              <li>Purpose: Multi-provider web search + content extraction</li>
              <li>API Keys: BRAVE_API_KEY, FIRECRAWL_API_KEY (in <code>.env</code>)</li>
              <li>Used By: research-synthesizer, claude-code-validator agents</li>
              <li>Tools: mcp__omnisearch__web_search, mcp__omnisearch__firecrawl_process</li>
            </ul>
          </li>
          <li>
            <strong>filesystem (Optional)</strong>
            <ul>
              <li>Purpose: Enhanced file operations</li>
              <li>API Keys: None</li>
              <li>Used By: hal-context-finder, system-maintenance (graceful fallback)</li>
              <li>Fallback: Read, Grep, Glob work at 100% functionality</li>
            </ul>
          </li>
          <li>
            <strong>replicate (Optional)</strong>
            <ul>
              <li>Purpose: AI/ML model access</li>
              <li>API Keys: REPLICATE_API_TOKEN (in <code>.env</code>)</li>
              <li>Use Cases: Image generation, ML inference, model testing</li>
            </ul>
          </li>
          <li>
            <strong>context7 (Optional)</strong>
            <ul>
              <li>Purpose: Vector database for semantic context</li>
              <li>API Keys: CONTEXT7_API_KEY (in <code>.env</code>)</li>
              <li>Use Cases: Embeddings, semantic search, context storage</li>
            </ul>
          </li>
        </ul>

        <p><strong>Usage Examples:</strong></p>
        <pre><code>/HAL-mcp-control status
/HAL-mcp-control enable replicate
/HAL-mcp-control disable filesystem</code></pre>

        <p><strong>Configuration Files:</strong></p>
        <ul>
          <li><strong>Server Registry:</strong> <code>.claude/tools/mcp/registry.json</code> - Defines all available MCP servers</li>
          <li><strong>Settings:</strong> <code>.claude/settings.local.json</code> - Managed keys: enableAllProjectMcpServers (false), enabledMcpjsonServers (array)</li>
          <li><strong>MCP Configuration:</strong> <code>.mcp.json</code> - Server definitions for enabled servers</li>
          <li><strong>Environment Files:</strong> <code>.env.&lt;server_name&gt;</code> - API keys and configuration (not checked into git)</li>
        </ul>

        <p><strong>RAM Optimization Strategy:</strong></p>
        <p><strong>Default Configuration:</strong></p>
        <ul>
          <li>omnisearch: ‚úì ENABLED (required)</li>
          <li>filesystem: ‚úì ENABLED (useful, low cost)</li>
          <li>replicate: ‚úó DISABLED (enable when needed)</li>
          <li>context7: ‚úó DISABLED (enable when needed)</li>
        </ul>
        <p><strong>Estimated Boot Cost:</strong></p>
        <ul>
          <li>2 servers enabled: ~1000-2000 tokens</li>
          <li>4 servers enabled: ~2000-4000 tokens</li>
        </ul>
        <p><strong>Best Practice:</strong></p>
        <ol>
          <li>Keep required servers enabled (omnisearch)</li>
          <li>Keep low-cost optional servers enabled (filesystem)</li>
          <li>Enable/disable specialized servers per session (replicate, context7)</li>
          <li>Check status before major work: <code>/HAL-mcp-control status</code></li>
        </ol>

        <p><strong>Workflow Examples:</strong></p>
        <pre><code># Research Session
/HAL-mcp-control enable omnisearch
# Restart session, do research work

# AI/ML Session
/HAL-mcp-control enable replicate
# Restart session, work with AI models
/HAL-mcp-control disable replicate
# Restart session

# Vector Database Work
/HAL-mcp-control enable context7
# Restart session, work with embeddings
/HAL-mcp-control disable context7</code></pre>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li><strong>Server won't enable:</strong> Missing API keys - check <code>.env.&lt;server_name&gt;</code> file, add required keys</li>
          <li><strong>Changes not applying:</strong> Session restart needed - restart Claude Code session after enable/disable</li>
          <li><strong>Required server disabled:</strong> Accidentally disabled omnisearch - re-enable and restart</li>
          <li><strong>Invalid server name:</strong> Typo or server not in registry - run <code>/HAL-mcp-control status</code> to see available servers</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Unix Philosophy:</strong> Does one thing well (manages MCP loading); separation of concerns (command modifies config, agents specify MCP needs)</li>
          <li><strong>MCPs as Extended I/O:</strong> MCPs are tools in the I/O system architecture</li>
          <li><strong>Clean Configuration:</strong> Transparent, controllable, file-based</li>
        </ul>

        <p><strong>Related Documentation:</strong></p>
        <ul>
          <li><code>.claude/tools/mcp/requirements.md</code> - Installation, configuration, troubleshooting</li>
          <li><code>.claude/tools/mcp/registry.json</code> - Server definitions</li>
          <li><code>data/architecture/hal8000-io-system.md</code> - MCP as Extended I/O layer</li>
        </ul>
      </div>
    </div>

    <!-- HAL-refman -->
    <div class="command-entry">
      <h3 id="hal-refman">/HAL-refman</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Manage HAL8000-Assistant Reference Manual development across multiple sessions with intelligent context loading</p>
        <p><strong>Category:</strong> Documentation</p>
        <p><strong>Syntax:</strong> <code>/HAL-refman [section-id|next|status|export|diagrams|complete &lt;section-id&gt;]</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li><code>section-id</code> - Specific section to work on</li>
          <li><code>next</code> - Auto-select next priority section</li>
          <li><code>status</code> - Display progress dashboard (default if no arguments)</li>
          <li><code>export</code> - Export final document (all sections must be complete)</li>
          <li><code>diagrams</code> - List all visual placeholders</li>
          <li><code>complete &lt;section-id&gt;</code> - Mark section as complete</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command manages the HAL8000-Assistant Reference Manual development workflow across multiple sessions, enabling intelligent context loading and progress tracking.</p>

        <h4>Mode 1: Status Dashboard (No Arguments)</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman</code> or <code>/HAL-refman status</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Load <code>data/reference-manual/index.html</code></li>
          <li>Parse all section metadata attributes</li>
          <li>Display progress dashboard</li>
          <li>Suggest next priority section</li>
        </ol>
        <p><strong>Output:</strong></p>
        <pre><code>üìñ HAL8000-Assistant Reference Manual - Development Status

Progress:
‚îú‚îÄ Total Sections: 31
‚îú‚îÄ Complete: 8 ‚úÖ
‚îú‚îÄ In Progress: 1 üîÑ
‚îú‚îÄ Draft: 22 üìù
‚îî‚îÄ Estimated Completion: 26%

Current Section: architecture-overview
Last Updated: 2025-10-08T12:00:00Z

Next Priority Sections:
1. memory-architecture - Memory Architecture (Priority: 1, Est: 8K tokens)
2. bus-system - Bus System (Priority: 2, Est: 6K tokens)

üí° Recommended: /HAL-refman next
    or: /HAL-refman memory-architecture</code></pre>

        <h4>Mode 2: Section Development (With Section ID)</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman [section-id]</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Load <code>data/reference-manual/index.html</code> (parse metadata only, minimal RAM)</li>
          <li>Locate section by ID attribute</li>
          <li>Parse section metadata: data-status, data-sources, data-estimated-tokens, data-dependencies</li>
          <li>Check dependencies (warn if incomplete)</li>
          <li>Extract hidden writing guidelines from <code>.meta-guidance</code> div</li>
          <li><strong>Launch documentation-writer sub-agent</strong> via Task tool</li>
          <li>Receive complete section HTML from agent</li>
          <li>Replace section in index.html with returned HTML</li>
          <li>Update state.json: increment completed counter, clear in_progress</li>
          <li>Display completion status</li>
        </ol>

        <p><strong>Context Loading Strategy (Reduce and Delegate):</strong></p>
        <ul>
          <li>Main session: Only load <code>data/reference-manual/index.html</code> for metadata parsing (~2K tokens)</li>
          <li>Sub-agent: Loads all source files in isolated 200K context</li>
          <li>Integration: Replace section HTML with agent output (~1K tokens)</li>
          <li><strong>Total main session cost: ~3K tokens per section</strong> (vs. ~10K direct approach)</li>
          <li><strong>RAM savings: ~70% per section, enables completing all 31 sections in one session</strong></li>
        </ul>

        <p><strong>Output:</strong></p>
        <pre><code>üìù HAL-refman: Working on Memory Architecture

Section ID: memory-architecture
Status: DRAFT ‚Üí IN_PROGRESS
Priority: 1

Context Strategy:
‚îú‚îÄ Main session: Lightweight (parse metadata only)
‚îú‚îÄ Sub-agent: documentation-writer (isolated 200K context)
‚îî‚îÄ RAM optimization: ~95% savings vs. direct approach

Writing Guidelines:
‚îú‚îÄ Target: Explain memory hierarchy and organization
‚îú‚îÄ Audience: All three levels
‚îú‚îÄ Key Points: BIOS, RAM, Storage, Indexes
‚îú‚îÄ Tone: Educational, layered complexity
‚îî‚îÄ Visuals: memory-hierarchy-diagram, storage-organization

Dependencies:
‚îú‚îÄ system-architecture ‚úÖ Complete
‚îî‚îÄ architecture-overview ‚úÖ Complete

üöÄ Launching documentation-writer agent...
   (This will take a moment - agent has isolated 200K context)

[Agent completes work]

‚úÖ Section complete and integrated!
   Progress: 9/31 sections (29%)

üí° Next: /HAL-refman next</code></pre>

        <h4>Mode 3: Auto-Select Next (Keyword: "next")</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman next</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Parse all sections</li>
          <li>Filter: status="draft" AND priority is lowest number</li>
          <li>Select first match</li>
          <li>Execute Mode 2 with that section-id</li>
        </ol>
        <p><strong>Fallback:</strong></p>
        <ul>
          <li>If no draft sections: Check for "in_progress" sections, offer to resume</li>
          <li>If all complete: Display congratulations, suggest "export"</li>
        </ul>

        <h4>Mode 4: Export Final Document (Keyword: "export")</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman export</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Load <code>data/reference-manual/index.html</code></li>
          <li>Check: All sections status="complete"?</li>
          <li>If incomplete: Display list of remaining sections, abort</li>
          <li>If complete: Strip all <code>data-*</code> attributes, remove all <code>.meta-guidance</code> divs, validate internal links, generate <code>data/reference-manual/HAL8000-Assistant-Reference-Manual-v[version].html</code></li>
          <li>Update state.json: <code>reference_manual.status = "complete"</code></li>
        </ol>
        <p><strong>Output:</strong></p>
        <pre><code>üì¶ Exporting HAL8000-Assistant Reference Manual

Validation:
‚îú‚îÄ All sections complete: ‚úÖ
‚îú‚îÄ Internal links valid: ‚úÖ
‚îú‚îÄ Diagrams integrated: 15/15 ‚úÖ
‚îî‚îÄ Metadata stripped: ‚úÖ

Generated: data/reference-manual/HAL8000-Assistant-Reference-Manual-v1.0.0.html
Size: 847KB

üéâ Reference manual export complete!</code></pre>

        <h4>Mode 5: List Visual Placeholders (Keyword: "diagrams")</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman diagrams</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Load <code>data/reference-manual/index.html</code></li>
          <li>Extract all elements with class="diagram-placeholder"</li>
          <li>Parse <code>data-diagram-id</code> attributes</li>
          <li>List all placeholders with descriptions</li>
        </ol>
        <p><strong>Output:</strong></p>
        <pre><code>üé® Visual Placeholders in Reference Manual

Total: 15 diagrams pending

[Section: System Architecture]
‚îú‚îÄ arch-overview: Architecture Overview
‚îÇ   ‚îî‚îÄ Block diagram showing CPU/RAM/Storage
‚îú‚îÄ data-flow: Data Flow Diagram
‚îÇ   ‚îî‚îÄ Sequence diagram of fetch-decode-execute

[Section: Memory Architecture]
‚îú‚îÄ memory-hierarchy: Memory Hierarchy
‚îÇ   ‚îî‚îÄ Layered diagram of BIOS/RAM/Storage

üí° Develop diagrams separately, then integrate with:
   - SVG inline or <img> tag
   - Replace placeholder <figure> elements</code></pre>

        <h4>Mode 6: Mark Section Complete (Keyword: "complete")</h4>
        <p><strong>Syntax:</strong> <code>/HAL-refman complete [section-id]</code></p>
        <p><strong>Action:</strong></p>
        <ol>
          <li>Load <code>data/reference-manual/index.html</code></li>
          <li>Locate section by ID</li>
          <li>Update <code>data-status="complete"</code></li>
          <li>Update state.json: clear in_progress, increment completed counter</li>
          <li>Save document</li>
          <li>Display status dashboard</li>
        </ol>

        <p><strong>Section Metadata Schema:</strong></p>
        <p>Each section in the reference manual must have:</p>
        <pre><code>&lt;section id="unique-section-id"
         data-status="draft|in_progress|complete"
         data-priority="1-5"
         data-sources="file1.md,file2.md:Section Title"
         data-estimated-tokens="8000"
         data-dependencies="other-section-id,another-section-id"&gt;

  &lt;h2&gt;Section Title&lt;/h2&gt;

  &lt;!-- Hidden metadata for command --&gt;
  &lt;div class="meta-guidance" style="display:none;"&gt;
    TARGET: [What this section explains]
    AUDIENCE: [All three / Specific audiences]
    KEY_POINTS: [Comma-separated key points]
    TONE: [Writing style guidance]
    VISUALS: [List of diagram placeholders]
  &lt;/div&gt;

  &lt;div class="content"&gt;
    &lt;!-- Actual section content --&gt;
  &lt;/div&gt;
&lt;/section&gt;</code></pre>

        <p><strong>State Tracking:</strong></p>
        <p>The command updates <code>.claude/state.json</code>:</p>
        <pre><code>{
  "reference_manual": {
    "version": "1.0.0",
    "file": "data/reference-manual/index.html",
    "total_sections": 31,
    "completed": 8,
    "in_progress": "architecture-overview",
    "last_updated": "2025-10-08T12:00:00Z",
    "status": "in_development|complete"
  }
}</code></pre>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li><strong>Missing reference-manual.html:</strong> Error message with instructions to create skeleton first</li>
          <li><strong>Invalid section ID:</strong> Error with list of available sections</li>
          <li><strong>Dependency not met:</strong> Warning (doesn't block) with recommendation to complete dependencies first</li>
        </ul>

        <p><strong>Content Development Guidelines:</strong></p>
        <p>When writing section content:</p>
        <ul>
          <li><strong>Visuals:</strong> Use placeholder format for all diagrams/images (never attempt to generate actual images)</li>
          <li><strong>Placeholder Format:</strong>
            <pre><code>&lt;figure class="diagram-placeholder" data-diagram-id="unique-id"&gt;
    &lt;div class="placeholder-box"&gt;
        [DIAGRAM: Description]
        Description: Detailed explanation
        Type: Block diagram / Flowchart / Sequence diagram
        Tools: Draw.io or SVG
    &lt;/div&gt;
&lt;/figure&gt;</code></pre>
          </li>
          <li>Check <code>.meta-guidance</code> VISUALS field for list of required placeholders</li>
          <li>Create one placeholder per visual mentioned</li>
          <li>Diagrams developed separately and integrated later</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Unix Philosophy:</strong> Single command, one purpose (manage reference manual); smart defaults; composable; text-based</li>
          <li><strong>Context Optimization:</strong> Load only what's needed for current section; respect token budgets; offload completed work to storage</li>
          <li><strong>Session Independence:</strong> Any fresh Claude instance can run command; all state in files (HTML + state.json); no hidden assumptions</li>
          <li><strong>Delegation Pattern:</strong> Sub-agent (documentation-writer) handles context-heavy content generation in isolated 200K context</li>
        </ul>

        <p><strong>Related Components:</strong></p>
        <ul>
          <li><code>data/reference-manual/index.html</code> - Master reference manual file</li>
          <li><code>.claude/state.json</code> - Progress tracking</li>
          <li><code>.claude/agents/documentation-writer.md</code> - Sub-agent for content generation (if exists)</li>
        </ul>
      </div>
    </div>

    <!-- HAL-CC-check -->
    <div class="command-entry">
      <h3 id="hal-cc-check">/HAL-CC-check</h3>
      <div class="command-spec">
        <p><strong>Purpose:</strong> Validate HAL8000-Assistant commands and agents for Claude Code compatibility</p>
        <p><strong>Category:</strong> System Health</p>
        <p><strong>Syntax:</strong> <code>/HAL-CC-check</code></p>

        <p><strong>Arguments:</strong></p>
        <ul>
          <li>None required</li>
        </ul>

        <p><strong>Implementation:</strong></p>
        <p>This command verifies that all HAL8000-Assistant CPU-level components (commands and agents) are compatible with the external Claude Code architecture by invoking the <code>claude-code-validator</code> specialized agent.</p>

        <p>The validation process executes in four steps:</p>
        <ol>
          <li><strong>Announce Check:</strong> Inform user that Claude Code compatibility check is starting</li>
          <li><strong>Invoke Validator Agent:</strong> Use Task tool to launch claude-code-validator agent with prompt to:
            <ul>
              <li>Fetch current Claude Code documentation from docs.claude.com (start with claude_code_docs_map.md)</li>
              <li>Extract available tools, deprecated features, and API changes</li>
              <li>Read and analyze all files in <code>.claude/commands/</code></li>
              <li>Read and analyze all files in <code>.claude/agents/</code></li>
              <li>Identify tool usage issues (deprecated, invalid, changed APIs)</li>
              <li>Generate structured compatibility report</li>
            </ul>
          </li>
          <li><strong>Present Results:</strong> Display the agent's compatibility report to the user</li>
          <li><strong>Summarize Status:</strong> Provide concise summary (overall compatibility status, critical issues, recommended actions)</li>
        </ol>

        <p><strong>Detection Targets:</strong></p>
        <ul>
          <li>Deprecated tools that need replacement</li>
          <li>Invalid tool references</li>
          <li>API changes requiring updates</li>
          <li>New capabilities available for optimization</li>
        </ul>

        <p><strong>Usage Example:</strong></p>
        <pre><code>/HAL-CC-check</code></pre>

        <p><strong>Expected Output:</strong></p>
        <pre><code>üîç Claude Code Compatibility Check

Overall Status: COMPATIBLE ‚úÖ

Summary:
- Total components checked: 14 (9 commands + 5 agents)
- Issues found: 2 warnings
- Critical issues: 0

Tool Availability Inventory:
‚úì Read - Available
‚úì Write - Available
‚úì Edit - Available
‚úì Bash - Available
‚úì Glob - Available
‚úì Grep - Available
‚ö† WebSearch - Deprecated (use mcp__omnisearch__web_search instead)
‚úì Task - Available
‚úì SlashCommand - Available

Component Analysis:

[Commands: 9 checked]
‚úì HAL-session-end - Compatible
‚úì HAL-register-dump - Compatible
‚úì HAL-system-check - Compatible
‚úì HAL-context-find - Compatible
‚úì HAL-index-update - Compatible
‚úì HAL-library-update - Compatible
‚úì HAL-mcp-control - Compatible
‚úì HAL-refman - Compatible
‚úì HAL-CC-check - Compatible (self-check)

[Agents: 5 checked]
‚úì hal-context-finder - Compatible
‚úì system-maintenance - Compatible
‚ö† research-synthesizer - Uses WebSearch (recommend migrating to mcp__omnisearch__web_search)
‚úì claude-code-validator - Compatible
‚úì documentation-writer - Compatible

Prioritized Recommendations:
1. [Medium Priority] Update research-synthesizer agent to use mcp__omnisearch__web_search instead of WebSearch
2. [Low Priority] Consider using new NotebookEdit tool for any future Jupyter notebook operations

Documentation References:
- Claude Code Tools: https://docs.claude.com/claude-code/tools
- MCP Integration: https://docs.claude.com/claude-code/mcp

Overall: HAL8000-Assistant is compatible with current Claude Code environment.
Minor updates recommended for future-proofing.</code></pre>

        <p><strong>Use Cases:</strong></p>
        <ul>
          <li>After Anthropic releases Claude Code updates</li>
          <li>Before major HAL8000-Assistant development sessions</li>
          <li>When commands/agents behave unexpectedly</li>
          <li>Periodic maintenance (quarterly recommended)</li>
        </ul>

        <p><strong>Error Handling:</strong></p>
        <ul>
          <li>If validator agent fails: Report failure to user, suggest manual verification at docs.claude.com, note that validation couldn't be completed</li>
          <li>If documentation fetch fails: Agent reports inability to access docs, suggests checking connection or trying later</li>
          <li>If critical incompatibilities found: Marks status as INCOMPATIBLE and lists required immediate actions</li>
        </ul>

        <p><strong>Execution Pattern:</strong></p>
        <pre><code>/HAL-CC-check
‚Üì
Task tool ‚Üí claude-code-validator agent
‚Üì (isolated 200K context)
Agent fetches docs, validates components
‚Üì
Returns compatibility report
‚Üì
Display results to user</code></pre>

        <p><strong>Token Efficiency:</strong></p>
        <ul>
          <li><strong>Direct implementation:</strong> ~50K tokens (fetch docs, load all commands/agents)</li>
          <li><strong>Agent delegation:</strong> ~5K tokens (report only)</li>
          <li><strong>Savings:</strong> ~90% RAM reduction</li>
        </ul>

        <p><strong>Design Notes:</strong></p>
        <p><strong>Why Separate from HAL-system-check:</strong></p>
        <ul>
          <li>Different validation target: External interface vs internal structure</li>
          <li>Different data source: Web documentation vs local filesystem</li>
          <li>Different failure response: Update our code vs fix our structure</li>
          <li>Composable: Can run independently or together</li>
        </ul>

        <p><strong>Agent Delegation Benefits:</strong></p>
        <ul>
          <li>Documentation fetching is context-heavy (10-50K tokens)</li>
          <li>Validation logic complex (parsing, cross-referencing)</li>
          <li>Isolated execution keeps main session RAM clean</li>
          <li>Agent returns only final report (~2-5K tokens)</li>
        </ul>

        <p><strong>Architecture Notes:</strong></p>
        <ul>
          <li><strong>Von Neumann:</strong> CPU instruction validation against external architecture</li>
          <li><strong>Unix:</strong> Does one thing well (external compatibility only)</li>
          <li><strong>Assembly:</strong> Verify opcodes match CPU capabilities</li>
          <li><strong>Delegation Pattern:</strong> Context-heavy validation offloaded to sub-agent</li>
        </ul>

        <p><strong>Related Commands:</strong></p>
        <ul>
          <li><code>/HAL-system-check</code> - Validates internal HAL8000-Assistant structure and principles</li>
          <li><code>/HAL-register-dump</code> - Shows current CPU state</li>
          <li><code>/HAL-session-end</code> - Saves state before RAM wipe</li>
        </ul>

        <p><strong>Related Agents:</strong></p>
        <ul>
          <li><code>claude-code-validator</code> - Performs the validation (invoked by this command)</li>
          <li><code>system-maintenance</code> - Validates internal structure</li>
        </ul>
      </div>
    </div>

    <!-- Command Development Guide -->
    <h3>Creating Custom Commands</h3>
    <p>
      HAL8000-Assistant's self-modifying code capability allows commands to create and modify other commands at runtime. This section explains how to develop custom commands that integrate seamlessly with the architecture.
    </p>

    <h4>Command File Structure</h4>
    <p>Commands are stored as markdown files in <code>.claude/commands/</code> with the naming convention:</p>
    <pre><code>HAL-command-name.md</code></pre>

    <h4>Required Frontmatter</h4>
    <p>Each command file should begin with YAML frontmatter containing metadata:</p>
    <pre><code>---
name: HAL-command-name
description: Brief description of what the command does
arguments: "[arg1] [arg2]" (optional)
allowed-tools: Bash, Read, Write, Edit (optional - list of tools command can use)
---</code></pre>

    <h4>Standard Sections</h4>
    <p>A well-structured command file includes:</p>
    <ol>
      <li><strong>Purpose:</strong> Clear one-sentence statement of the command's function</li>
      <li><strong>Category:</strong> Classification (Session Management, System Health, Context Discovery, Maintenance, Integration)</li>
      <li><strong>Usage:</strong> Syntax examples and argument descriptions</li>
      <li><strong>Implementation:</strong> Step-by-step execution logic (what the CPU should do when the command is invoked)</li>
      <li><strong>Error Handling:</strong> Expected failure modes and recovery procedures</li>
      <li><strong>Architecture Alignment:</strong> How the command embodies HAL8000-Assistant principles (Von Neumann, Unix, Assembly)</li>
      <li><strong>Related Components:</strong> Files, commands, agents that interact with this command</li>
    </ol>

    <h4>Implementation Section Guidelines</h4>
    <p>The Implementation section should provide clear, executable instructions for the CPU:</p>
    <ul>
      <li>Use numbered steps for sequential operations</li>
      <li>Include code examples where appropriate (bash scripts, JSON structures, etc.)</li>
      <li>Specify exact file paths and data structures</li>
      <li>Define expected outputs and state changes</li>
      <li>Consider RAM management (when to delegate to sub-agents)</li>
    </ul>

    <h4>Naming Conventions</h4>
    <ul>
      <li><strong>Command names:</strong> HAL-kebab-case (e.g., HAL-session-end, HAL-context-find)</li>
      <li><strong>Arguments:</strong> Use clear, descriptive names (e.g., session-description, library-name)</li>
      <li><strong>File references:</strong> Always use absolute paths in examples</li>
    </ul>

    <h4>RAM Management Guidelines</h4>
    <p>Commands should be RAM-conscious:</p>
    <ul>
      <li><strong>Lightweight commands (&lt;20 file operations):</strong> Execute directly in main session</li>
      <li><strong>Context-heavy commands (&gt;20 file operations):</strong> Delegate to sub-agent, return summary only</li>
      <li><strong>Always estimate:</strong> Document estimated RAM cost in implementation notes</li>
      <li><strong>Follow "Reduce and Delegate":</strong> Prefer sub-agent delegation for operations that load significant context</li>
    </ul>

    <h4>Integration with System</h4>
    <p>After creating a command:</p>
    <ol>
      <li>Save file to <code>.claude/commands/HAL-command-name.md</code></li>
      <li>Run <code>/HAL-index-update .claude/commands</code> to update command index</li>
      <li>Update <code>.claude/state.json</code> to increment commands_count (or let HAL-session-end do it automatically)</li>
      <li>Test command invocation via slash notation: <code>/HAL-command-name</code></li>
      <li>Document command in relevant architecture files if it introduces new patterns</li>
    </ol>

    <h4>Example Command Template</h4>
    <pre><code>---
name: HAL-example-command
description: Example command demonstrating standard structure
arguments: "[required-arg] [optional-arg]"
allowed-tools: Read, Write, Bash
---

# HAL Example Command

**Purpose:** Brief one-sentence description

**Category:** [Category Name]

## Usage

```bash
/HAL-example-command required-arg [optional-arg]
```

**Arguments:**
- `required-arg` (required) - Description
- `optional-arg` (optional) - Description, default: value

## What This Command Does

1. Step 1 description
2. Step 2 description
3. Step 3 description

## Implementation

### Step 1: [Action Name]

[Detailed instructions, code examples, file paths]

### Step 2: [Action Name]

[Detailed instructions]

### Step 3: [Action Name]

[Detailed instructions]

## Usage Examples

```bash
/HAL-example-command value1
/HAL-example-command value1 value2
```

## Expected Output

```
[Sample output format]
```

## Error Handling

- **Error case 1:** Description and recovery
- **Error case 2:** Description and recovery

## Architecture Alignment

- **Von Neumann:** How this embodies stored-program, self-modification, etc.
- **Unix Philosophy:** Single responsibility, composability, text-based
- **Assembly Principles:** Explicit control, low-level visibility

## Related Components

- Related file 1
- Related file 2
- Related command

## Notes

- Additional considerations
- Performance characteristics
- Future improvements
</code></pre>

    <!-- Best Practices -->
    <h3>Command Usage Best Practices</h3>

    <h4>When to Invoke Commands</h4>
    <ul>
      <li><strong>Session boundaries:</strong> Always run <code>/HAL-session-end</code> before RAM wipe to ensure continuity</li>
      <li><strong>System validation:</strong> Run <code>/HAL-system-check</code> after major architectural changes or before new project phases</li>
      <li><strong>Context discovery:</strong> Use <code>/HAL-context-find</code> instead of manual file navigation to save 60-85% RAM</li>
      <li><strong>Maintenance windows:</strong> Run <code>/HAL-index-update</code> after creating 3+ new files or changing file organization</li>
      <li><strong>Library updates:</strong> Check <code>/HAL-library-update</code> monthly for active libraries or before major research work</li>
      <li><strong>Debugging:</strong> Use <code>/HAL-register-dump</code> to inspect system state when troubleshooting</li>
    </ul>

    <h4>Command Composition Patterns</h4>
    <p>Commands are designed to compose with each other:</p>
    <pre><code># After updating libraries, reindex them
/HAL-library-update fabric-patterns
# (HAL-index-update is invoked automatically)

# After major file changes, validate system health
/HAL-index-update
/HAL-system-check

# Before session end, check system state
/HAL-register-dump
/HAL-session-end architecture-work

# Periodic maintenance sequence
/HAL-CC-check          # Validate external compatibility
/HAL-system-check      # Validate internal structure
/HAL-index-update      # Refresh all indexes</code></pre>

    <h4>RAM Optimization Tips</h4>
    <ul>
      <li><strong>Monitor RAM_ZONE:</strong> Use <code>/HAL-register-dump</code> to check RAM usage; checkpoint when entering CAUTION zone (80%+)</li>
      <li><strong>Prefer delegation:</strong> Commands that delegate to sub-agents (like <code>/HAL-context-find</code>) save significant RAM</li>
      <li><strong>MCP control:</strong> Use <code>/HAL-mcp-control</code> to enable only needed servers, saving 500-1000 tokens per disabled server at boot</li>
      <li><strong>Selective indexing:</strong> Update specific directories (<code>/HAL-index-update data/research</code>) instead of entire system when possible</li>
    </ul>

    <h4>Error Recovery Strategies</h4>
    <ul>
      <li><strong>Command failure:</strong> Check <code>/HAL-register-dump</code> for ERROR_FLAG and ERROR_CODE to diagnose</li>
      <li><strong>Corrupted state:</strong> Run <code>/HAL-system-check</code> to identify structural issues</li>
      <li><strong>Compatibility issues:</strong> Run <code>/HAL-CC-check</code> to verify external Claude Code compatibility</li>
      <li><strong>Session continuity broken:</strong> Check <code>.claude/state.json</code> and <code>.claude/sessions/</code> for last checkpoint</li>
    </ul>

    <h4>Documentation Workflow</h4>
    <p>For reference manual development:</p>
    <pre><code># Check progress
/HAL-refman status

# Work on next priority section
/HAL-refman next

# Work on specific section
/HAL-refman memory-architecture

# List all diagram placeholders
/HAL-refman diagrams

# Export final document (when all sections complete)
/HAL-refman export</code></pre>

    <h4>Command Chaining Considerations</h4>
    <p>While commands can be invoked sequentially, be aware of:</p>
    <ul>
      <li><strong>Session restart requirements:</strong> <code>/HAL-mcp-control</code> changes require session restart to take effect</li>
      <li><strong>Auto-invocation:</strong> Some commands auto-invoke others (e.g., <code>/HAL-library-update</code> calls <code>/HAL-index-update</code>)</li>
      <li><strong>State dependencies:</strong> Some commands depend on state established by others (e.g., <code>/HAL-refman export</code> requires all sections complete)</li>
      <li><strong>RAM accumulation:</strong> Each command adds to RAM; monitor with <code>/HAL-register-dump</code> and checkpoint as needed</li>
    </ul>

    <h4>Integration with Boot Sequence</h4>
    <p>Commands integrate with the BIOS boot sequence defined in <code>CLAUDE.md</code>:</p>
    <ul>
      <li><strong>Boot loads:</strong> BIOS (CLAUDE.md) and state.json automatically</li>
      <li><strong>Session resume:</strong> User says "resume" to load active_session file noted in state.json</li>
      <li><strong>Command discovery:</strong> Use <code>/HAL-context-find</code> to load command definitions on-demand</li>
      <li><strong>State persistence:</strong> <code>/HAL-session-end</code> ensures next boot has continuity</li>
    </ul>

</section>

            <!-- Section 16: Agent Reference -->
            <section id="agent-reference" data-status="complete" data-priority="2" 
         data-sources=".claude/agents/" data-estimated-tokens="15000" 
         data-dependencies="">
  
  <div class="meta-guidance" style="display:none;">
    This section documents all HAL8000-Assistant sub-agents as architectural components extending effective RAM capacity.
    Agents are virtual memory - isolated 200K contexts that process heavy tasks and return summaries.
    Maintenance: Update when new agents added to .claude/agents/, verify RAM savings metrics remain accurate.
    Each agent entry must include: purpose, tools, I/O specification, RAM savings, invocation examples.
  </div>

  <h2>16. Agent Reference</h2>

  <h3>16.1 Overview</h3>
  
  <p>
    In the HAL8000-Assistant architecture, <strong>sub-agents are virtual memory</strong>. They extend the system's 
    effective RAM capacity by processing context-heavy operations in isolated 200,000-token contexts, 
    then returning only essential summaries to the main session.
  </p>

  <p>
    Traditional approach: Load raw data ‚Üí Process in main RAM ‚Üí Main RAM bloated with intermediate results<br>
    Agent approach: Delegate to sub-agent ‚Üí Agent processes in isolated context ‚Üí Returns clean summary ‚Üí Main RAM += summary only
  </p>

  <div class="insight-box">
    <strong>RAM Savings:</strong> Sub-agents typically save 60-90% of context consumption compared to 
    direct operations. A web research task that would consume 150K tokens of main RAM instead consumes 
    only 5-15K tokens when delegated to the research-synthesizer agent.
  </div>

  <h3>16.2 Agent Architecture</h3>

  <h4>16.2.1 The Sub-Agent Pattern</h4>

  <p>Sub-agents implement a process isolation pattern analogous to virtual memory paging:</p>

  <div class="diagram-container">
    <img src="assets/diagrams/agent-workflow.png" alt="Sub-Agent Workflow" style="max-width: 100%; height: auto;">
    <p class="diagram-caption">
      <strong>Sub-Agent Pattern:</strong> Process isolation for RAM efficiency - sub-agents handle heavy work in isolated context and return only concise summaries
    </p>
  </div>

  <h4>16.2.2 Delegation Workflow</h4>

  <ol>
    <li><strong>Detection:</strong> CPU recognizes context-heavy operation</li>
    <li><strong>Selection:</strong> Choose appropriate agent for task type</li>
    <li><strong>Invocation:</strong> Launch agent via slash command or Task tool</li>
    <li><strong>Execution:</strong> Agent operates in isolated 200K context</li>
    <li><strong>Return:</strong> Agent provides structured summary</li>
    <li><strong>Integration:</strong> Main session incorporates summary (minimal RAM cost)</li>
    <li><strong>Cleanup:</strong> Agent context automatically discarded</li>
  </ol>

  <h4>16.2.3 Core Principle: Return Summaries, Not Raw Data</h4>

  <p>Agents MUST follow this protocol:</p>

  <table>
    <thead>
      <tr>
        <th>Anti-Pattern (Wrong)</th>
        <th>Correct Pattern</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Return all search results</td>
        <td>Return structured synthesis</td>
      </tr>
      <tr>
        <td>Return full file contents</td>
        <td>Return file + concise summary</td>
      </tr>
      <tr>
        <td>Return intermediate calculations</td>
        <td>Return final conclusions</td>
      </tr>
      <tr>
        <td>Return verbose explanations</td>
        <td>Return actionable insights</td>
      </tr>
    </tbody>
  </table>

  <h4>16.2.4 Output Volatility Constraint</h4>

  <div class="warning-box">
    <strong>‚ö†Ô∏è Critical Architectural Constraint:</strong> Sub-agent outputs are returned to main session RAM and are <strong>volatile</strong>.
  </div>

  <p>Understanding output volatility is essential for correct sub-agent usage:</p>

  <h5>Volatility Lifecycle</h5>
  <ol>
    <li><strong>Sub-agent completes</strong> ‚Üí Returns results to main session</li>
    <li><strong>Results exist in current session RAM only</strong> ‚Üí Not persisted automatically</li>
    <li><strong>Session boundary (RAM wipe)</strong> ‚Üí <strong>All sub-agent output permanently lost</strong></li>
    <li><strong>Results must be fully processed and persisted to files BEFORE session-end</strong></li>
  </ol>

  <div class="insight-box">
    <strong>This is not a bug - it's architectural:</strong> RAM is volatile by design. Session boundaries
    are garbage collection events that wipe all non-persisted data, including sub-agent results.
  </div>

  <h5>Operational Implications</h5>
  <ul>
    <li><strong>Complete sub-agent work fully within session</strong> - Process output, extract data, persist to files before session ends</li>
    <li><strong>Don't session-end with unprocessed results</strong> - If sub-agent returned data you still need, persist it first</li>
    <li><strong>Plan sub-agent work as atomic units</strong> - Each sub-agent task should complete (including persistence) before session boundary</li>
  </ul>

  <h5>Example Workflow</h5>
  <pre><code>‚úì CORRECT:
1. Launch research-synthesizer for topic X
2. Agent returns structured research report
3. Extract key findings, write to data/research/topic-x.md
4. Use findings in current work
5. Session-end when ready ‚Üí Data safe in file system

‚úó WRONG:
1. Launch research-synthesizer for topic X
2. Agent returns structured research report
3. Read report, understand findings
4. Session-end without persisting report
5. Next session: Report lost forever, must re-research</code></pre>

  <h3>16.3 Available Agents</h3>

  <h4>16.3.1 research-synthesizer</h4>

  <p><strong>Location:</strong> <code>.claude/agents/research-synthesizer.md</code></p>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Conduct comprehensive web research and return structured summaries</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>mcp__omnisearch (web_search, firecrawl_process), WebSearch, WebFetch, file operations</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>Research query (topic, question, investigation request)</td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>
          <strong>Summary:</strong> 2-3 paragraph overview<br>
          <strong>Key Findings:</strong> Bulleted essential discoveries<br>
          <strong>Detailed Analysis:</strong> In-depth exploration by theme<br>
          <strong>Sources:</strong> Referenced URLs with relevance notes
        </td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>70-90% vs loading raw search results</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>Any web research task, competitive analysis, technology investigation, best practices research</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>User: "Research the latest developments in vector databases"
CPU: [Launches research-synthesizer agent]
Agent: [Searches web, analyzes sources, synthesizes findings]
Agent Returns: 8K token structured report
Main RAM: +8K (not +120K of raw search results)</code></pre>

  <pre><code>User: "What are best practices for context window management in LLM applications?"
CPU: [Launches research-synthesizer agent]
Agent: [Multi-source research across documentation, papers, blogs]
Agent Returns: Structured analysis with actionable recommendations
Main RAM: Minimal increase, maximum insight</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Task tool:
  task: "Research [topic]"
  agent: "research-synthesizer"

Or via custom slash command if defined.</code></pre>

  <h4>16.3.2 hal-context-finder</h4>

  <p><strong>Location:</strong> <code>.claude/agents/hal-context-finder.md</code></p>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Discover and load system files without consuming main session RAM</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>File system navigation (ls, find), Grep, Read, file operations</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>Search query: file name pattern, content keyword, architectural concept</td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>
          <strong>Complete file contents</strong> (requested files loaded in full)<br>
          <strong>Context:</strong> What was requested<br>
          <strong>Locations:</strong> File paths and roles<br>
          <strong>Summary:</strong> Key points from each file<br>
          <strong>Related:</strong> Other potentially relevant files
        </td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>60-85% vs manual navigation and loading</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>Finding system files, architecture discovery, context acquisition, "where is X?" questions</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>/HAL-context-find "session handling implementation"

Agent:
- Searches for session-related files
- Identifies .claude/commands/HAL-session-end.md
- Loads complete file contents
- Returns file + structured summary
Main RAM: File contents + 2K summary (vs 15K+ if manual navigation)</code></pre>

  <pre><code>/HAL-context-find "register architecture"

Agent:
- Searches architecture docs and command files
- Locates relevant sections in CLAUDE.md, system-design.md
- Returns complete sections + synthesis
Main RAM: Essential content only, not entire discovery process</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Slash command (preferred):
/HAL-context-find "search query"

Task tool:
  task: "Find files related to [topic]"
  agent: "hal-context-finder"</code></pre>

  <h4>16.3.3 general-purpose (Built-in Claude Code Agent)</h4>

  <p><strong>Type:</strong> Built-in Claude Code agent type (not a HAL8000-Assistant file)</p>
  <p><strong>Location:</strong> Provided by Claude Code platform, not stored in <code>.claude/agents/</code></p>

  <div class="insight-box">
    <strong>Note:</strong> Unlike HAL8000-Assistant's custom agents, <code>general-purpose</code> is a built-in agent type
    provided by the Claude Code platform. HAL8000-Assistant uses it as a base for custom behaviors (like documentation-writer)
    by providing specialized instructions in the Task tool prompt.
  </div>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Handle custom context-heavy tasks not covered by specialized agents</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>All available tools (file operations, web access, code execution, etc.)</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>Task description with specific goals and constraints (embedded in prompt)</td>
      </tr>
      <tr>
        <td><strong>Output</strong></td>
        <td>Task-specific results (format varies by task)</td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>50-80% depending on task complexity</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>Multi-step analysis, large file processing, custom workflows, one-off complex tasks</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>User: "Analyze all markdown files in data/ and create a topic index"
CPU: [Launches general-purpose agent]
Agent: [Reads files, extracts topics, builds index]
Agent Returns: Completed index file + summary of findings
Main RAM: Result only, not all intermediate processing</code></pre>

  <pre><code>User: "Compare the architecture documentation with actual implementation to find inconsistencies"
CPU: [Launches general-purpose agent]
Agent: [Loads docs, loads code, performs comparison]
Agent Returns: Inconsistency report with specific examples
Main RAM: Report only, not all source materials</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Task tool:
  task: "[detailed task description]"
  agent: "general-purpose"</code></pre>

  <h4>16.3.4 system-maintenance</h4>

  <p><strong>Location:</strong> <code>.claude/agents/system-maintenance.md</code></p>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Audit HAL8000-Assistant system integrity, validate structure, identify issues</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>File system operations, Grep, validation tools, Read</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>System check request (optional: specific subsystem focus)</td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>
          <strong>System Health Report:</strong><br>
          - Core files status<br>
          - Structural integrity<br>
          - Missing components<br>
          - Recommendations
        </td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>70-85% vs manual system traversal</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>System health checks, post-modification validation, troubleshooting, periodic audits</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>User: "Run a system health check"
CPU: [Launches system-maintenance agent]
Agent: [Validates BIOS, state.json, commands, indexes, structure]
Agent Returns: Health report with any issues flagged
Main RAM: Report only, not all checked files</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Task tool:
  task: "Perform system health check"
  agent: "system-maintenance"</code></pre>

  <h4>16.3.5 claude-code-validator</h4>

  <p><strong>Location:</strong> <code>.claude/agents/claude-code-validator.md</code></p>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Validate HAL8000-Assistant commands and agents against official Claude Code documentation</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>WebFetch (Claude Code docs), WebSearch, file operations</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>Command/agent file to validate, or "validate all"</td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>
          <strong>Compatibility Report:</strong><br>
          - Deprecated tools detected<br>
          - API changes required<br>
          - Recommended updates<br>
          - Compatibility score
        </td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>65-80% vs loading full documentation</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>Detecting deprecated tools, validating new commands, system updates, compatibility audits</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>User: "Check if any of our commands use deprecated tools"
CPU: [Launches claude-code-validator agent]
Agent: [Fetches latest Claude Code docs, compares against our commands]
Agent Returns: Report listing deprecated usage with migration paths
Main RAM: Report only, not full documentation</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Task tool:
  task: "Validate [command/agent name] against Claude Code documentation"
  agent: "claude-code-validator"</code></pre>

  <h4>16.3.6 documentation-writer</h4>

  <p><strong>Location:</strong> <code>.claude/agents/documentation-writer.md</code></p>

  <table>
    <tbody>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Write high-quality technical documentation with accuracy, structure, and completeness</td>
      </tr>
      <tr>
        <td><strong>Tools</strong></td>
        <td>Read, Grep, Glob (source file access only, read-only operation)</td>
      </tr>
      <tr>
        <td><strong>Input</strong></td>
        <td>
          <strong>Sources:</strong> Files to analyze<br>
          <strong>Format:</strong> html, markdown, or text<br>
          <strong>Doc Type:</strong> reference, guide, specification, tutorial, or overview<br>
          <strong>Guidelines:</strong> TARGET, AUDIENCE, KEY_POINTS, TONE, STRUCTURE, VISUALS
        </td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>
          <strong>Complete formatted documentation</strong> (HTML/Markdown) with:<br>
          - Layered structure (multiple audiences)<br>
          - Visual placeholders (never actual images)<br>
          - Cross-references and navigation<br>
          - Technical precision and accuracy
        </td>
      </tr>
      <tr>
        <td><strong>RAM Savings</strong></td>
        <td>70-85% vs loading sources and writing in main session</td>
      </tr>
      <tr>
        <td><strong>When to Use</strong></td>
        <td>Writing reference manual sections, command docs, API docs, architecture specs, user guides, tutorials</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Example Invocations:</strong></p>

  <pre><code>User: "Write the RAM management section for the reference manual"
CPU: [Launches documentation-writer agent with HAL-refman command]
Agent: [Reads CLAUDE.md Resource Management Protocol, writes structured HTML]
Agent Returns: Complete section HTML (15K tokens)
Main RAM: Section content only, not source files + drafting process</code></pre>

  <pre><code>User: "Document the HAL-system-check command"
CPU: [Launches documentation-writer agent]
Agent: [Reads .claude/commands/HAL-system-check.md, creates reference doc]
Agent Returns: Formatted command reference
Main RAM: Final doc only</code></pre>

  <p><strong>Invocation Pattern:</strong></p>

  <pre><code>Task tool:
  task: "Write [doc_type] documentation for [target]"
  agent: "general-purpose" (with documentation-writer instructions)

Or via /HAL-refman command for reference manual sections</code></pre>

  <div class="insight-box">
    <strong>Documentation Quality Standards:</strong> The documentation-writer agent follows HAL8000-Assistant's
    technical documentation principles: accuracy over engagement, structure over narrative, completeness
    over brevity. It supports multiple audience layers, creates visual placeholders (never generates actual
    images), and ensures cross-references and proper navigation structure.
  </div>

  <h3>16.4 Agent Invocation Patterns</h3>

  <h4>16.4.1 Via Slash Commands</h4>

  <p>Some agents have dedicated slash commands for convenience:</p>

  <pre><code>/HAL-context-find "search query"
# Invokes hal-context-finder agent</code></pre>

  <p>Slash commands provide ergonomic interfaces to commonly-used agents.</p>

  <h4>16.4.2 Via Task Tool</h4>

  <p>All agents can be invoked via the Task tool:</p>

  <pre><code>Task tool parameters:
  task: "Detailed description of what needs to be done"
  agent: "agent-name"  # From .claude/agents/[agent-name].md</code></pre>

  <p><strong>Example:</strong></p>

  <pre><code>Task:
  task: "Research best practices for prompt engineering in 2025"
  agent: "research-synthesizer"</code></pre>

  <h4>16.4.3 Parallel Agent Launches</h4>

  <p>Independent research tasks can run in parallel:</p>

  <pre><code>User: "Research vector databases AND research graph databases"

CPU launches two research-synthesizer agents in parallel:
  Agent 1: Researching vector databases
  Agent 2: Researching graph databases

Both return summaries ‚Üí Main session combines results
RAM savings: Massive vs sequential loading and processing</code></pre>

  <h4>16.4.4 Error Handling</h4>

  <p>Agent invocation errors:</p>

  <ul>
    <li><strong>Agent not found:</strong> Verify agent exists in <code>.claude/agents/</code></li>
    <li><strong>Insufficient task description:</strong> Provide more specific instructions</li>
    <li><strong>Agent timeout:</strong> Task may be too complex, consider breaking into subtasks</li>
    <li><strong>Empty results:</strong> Agent found no relevant information, refine search query</li>
  </ul>

  <p>Agents should report errors clearly and suggest recovery actions.</p>

  <h3>16.5 Agent Development</h3>

  <h4>16.5.1 Agent File Structure</h4>

  <div class="warning-box">
    <strong>‚ö†Ô∏è No Official Claude Code Specification Available</strong>
    <p>As of 2025-10, Anthropic has not published official documentation for Claude Code custom agent file formats. The structure described here is the <strong>HAL8000-Assistant working pattern</strong> - a convention that successfully operates in production. This represents emergent best practices rather than official requirements.</p>
  </div>

  <p><strong>HAL8000-Assistant Agent File Pattern:</strong></p>
  <p>Agents are markdown files stored in <code>.claude/agents/[agent-name].md</code> following this proven structure:</p>

  <h5>Basic Structure</h5>

  <pre><code># [Agent Name] Agent

**Purpose:** [Single clear sentence describing what this agent does]

**Agent Type:** Specialized sub-agent for [category] (e.g., context-isolated research, system maintenance)

**Context Window:** Isolated context (separate from main session)

---

## Capabilities

### What This Agent Does
[List of specific capabilities]

### What This Agent Does NOT Do
[Explicit boundaries - prevents scope creep]

---

## Input Parameters

[If agent expects structured input, define parameters clearly]

Example:
- query (required): Search query or task description
- format (optional): Output format preference
- constraints (optional): Specific limitations

---

## Output Format

[CRITICAL: Define structured output specification]

The agent MUST return:
- Summary: [Brief overview]
- Key Points: [Actionable insights]
- [Additional structured sections as needed]

The agent MUST NOT return:
- Raw search results
- Unprocessed file contents
- Verbose explanations without synthesis

---

## Processing Workflow

### Step 1: [Phase Name]
[Detailed instructions for first phase]

### Step 2: [Phase Name]
[Detailed instructions for second phase]

### Step N: Quality Checks
[Verification steps before returning output]

---

## Usage Examples

[Concrete examples of agent invocation and expected output]

---

## Integration with HAL8000-Assistant

[How this agent fits into the system architecture]

---

## Design Principles

[Architectural alignment - Unix philosophy, RAM management, etc.]

---

## Agent Metadata

**Version:** [version number]
**Created:** [date]
**Status:** [Active|Beta|Deprecated]
**Category:** [Content Generation|Research|Maintenance|etc.]
**RAM Impact:** [Zero|Low|Medium - with explanation]
**Dependencies:** [Required tools or files]

---

## Tools Available

[List of tools the agent can use, with justification for each]

**NOT Available (Sub-Agent Restrictions):**
- Task: Sub-agents cannot spawn nested sub-agents
- Tools that require interactive input
- [Other limitations]

---

## Execution Notes

[Operational details about how this agent runs]</code></pre>

  <h5>Key Sections Explained</h5>

  <table>
    <thead>
      <tr>
        <th>Section</th>
        <th>Purpose</th>
        <th>Required?</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Title & Purpose</strong></td>
        <td>Clear identity statement at the top</td>
        <td>‚úÖ Required</td>
      </tr>
      <tr>
        <td><strong>Capabilities (Do/Don't)</strong></td>
        <td>Define scope and boundaries explicitly</td>
        <td>‚úÖ Required</td>
      </tr>
      <tr>
        <td><strong>Input Parameters</strong></td>
        <td>Structured input specification if needed</td>
        <td>Conditional</td>
      </tr>
      <tr>
        <td><strong>Output Format</strong></td>
        <td>CRITICAL: Defines return structure</td>
        <td>‚úÖ Required</td>
      </tr>
      <tr>
        <td><strong>Processing Workflow</strong></td>
        <td>Step-by-step operating instructions</td>
        <td>‚úÖ Required</td>
      </tr>
      <tr>
        <td><strong>Usage Examples</strong></td>
        <td>Demonstrates invocation patterns</td>
        <td>‚úÖ Recommended</td>
      </tr>
      <tr>
        <td><strong>HAL8000-Assistant Integration</strong></td>
        <td>How agent fits system architecture</td>
        <td>‚úÖ Recommended</td>
      </tr>
      <tr>
        <td><strong>Agent Metadata</strong></td>
        <td>Tracking and categorization info</td>
        <td>Optional</td>
      </tr>
      <tr>
        <td><strong>Tools Available</strong></td>
        <td>Clarifies agent's tool access</td>
        <td>‚úÖ Recommended</td>
      </tr>
    </tbody>
  </table>

  <h5>File Format Notes</h5>

  <ul>
    <li><strong>Pure Markdown:</strong> No YAML frontmatter required (HAL8000-Assistant pattern)</li>
    <li><strong>Human-Readable:</strong> Files are documentation AND specification</li>
    <li><strong>Self-Contained:</strong> Complete instructions within single file</li>
    <li><strong>Naming Convention:</strong> Descriptive kebab-case names (e.g., <code>research-synthesizer.md</code>, <code>hal-context-finder.md</code>)</li>
    <li><strong>No Special Parsing:</strong> Agent content read as natural language instructions</li>
  </ul>

  <h5>How Agents Are Invoked</h5>

  <p>Agent files are loaded and interpreted by Claude Code when invoked via the Task tool:</p>

  <pre><code>Task(
  subagent_type="general-purpose",  # Built-in agent type
  description="[task description]",
  prompt="""[Agent instructions from file OR embedded instructions]"""
)</code></pre>

  <p><strong>Two invocation patterns observed:</strong></p>

  <ol>
    <li><strong>File-based:</strong> Agent file loaded by reference (name matches file in <code>.claude/agents/</code>)</li>
    <li><strong>Prompt-embedded:</strong> Agent instructions provided directly in Task prompt (used for documentation-writer)</li>
  </ol>

  <div class="insight-box">
    <strong>Reality Check:</strong> Since Claude Code lacks official documentation, HAL8000-Assistant's agent structure
    represents a working implementation validated through production use. The pattern emphasizes clarity,
    explicit boundaries, structured outputs, and architectural alignment. If official specifications emerge,
    this section will be updated to reflect Anthropic's guidance.
  </div>

  <h4>16.5.2 Tool Selection</h4>

  <p>Choose tools based on agent's purpose:</p>

  <table>
    <thead>
      <tr>
        <th>Agent Type</th>
        <th>Essential Tools</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Research agents</td>
        <td>WebSearch, WebFetch, mcp__omnisearch, file write</td>
      </tr>
      <tr>
        <td>Context discovery</td>
        <td>Glob, Grep, Read, Bash (find, ls)</td>
      </tr>
      <tr>
        <td>Code analysis</td>
        <td>Read, Grep, mcp__ide (diagnostics), Bash</td>
      </tr>
      <tr>
        <td>System maintenance</td>
        <td>File operations, Grep, Bash, validation tools</td>
      </tr>
    </tbody>
  </table>

  <h4>16.5.3 Prompt Engineering for Agents</h4>

  <p>Agent prompts must be precise and constrained:</p>

  <ul>
    <li><strong>Single responsibility:</strong> One clear purpose per agent</li>
    <li><strong>Explicit output format:</strong> Structured summary specification</li>
    <li><strong>Anti-pattern warnings:</strong> "Do NOT return raw data, ALWAYS synthesize"</li>
    <li><strong>Step-by-step process:</strong> Clear operating instructions</li>
    <li><strong>Success criteria:</strong> What constitutes good output</li>
  </ul>

  <p><strong>Example instruction pattern:</strong></p>

  <pre><code>CRITICAL: Your output MUST be a structured summary, not raw data.

Steps:
1. [Gather information using tools]
2. [Analyze and synthesize findings]
3. [Return ONLY this structure:]
   - Summary: [2-3 paragraphs]
   - Key Points: [Bulleted insights]
   - [Additional structured sections]

DO NOT return:
- Raw search results
- Unprocessed file contents
- Verbose explanations</code></pre>

  <h4>16.5.4 Testing Patterns</h4>

  <p>Test new agents before integration:</p>

  <ol>
    <li><strong>Unit test:</strong> Invoke agent with specific task, verify output format</li>
    <li><strong>RAM measurement:</strong> Compare context consumption vs direct operation</li>
    <li><strong>Output quality:</strong> Verify summaries are actionable and complete</li>
    <li><strong>Error handling:</strong> Test with malformed inputs, missing resources</li>
    <li><strong>Integration test:</strong> Use in real workflow, validate RAM savings</li>
  </ol>

  <h3>16.6 Best Practices</h3>

  <h4>16.6.1 When to Delegate vs Do Directly</h4>

  <table>
    <thead>
      <tr>
        <th>Delegate to Agent</th>
        <th>Do Directly</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Web research (any scope)</td>
        <td>Reading single known file</td>
      </tr>
      <tr>
        <td>System file discovery</td>
        <td>Simple grep for known pattern</td>
      </tr>
      <tr>
        <td>Multi-file analysis</td>
        <td>Single file edit</td>
      </tr>
      <tr>
        <td>Large dataset processing</td>
        <td>Quick calculation</td>
      </tr>
      <tr>
        <td>Context-heavy investigation</td>
        <td>Answering from current context</td>
      </tr>
      <tr>
        <td>Input >> Output scenarios</td>
        <td>Input ‚âà Output scenarios</td>
      </tr>
    </tbody>
  </table>

  <div class="insight-box">
    <strong>Rule of thumb:</strong> If the operation would consume &gt;20K tokens of intermediate context 
    that won't be needed after results are obtained, delegate to an agent.
  </div>

  <h4>16.6.2 Parallel vs Sequential Agent Usage</h4>

  <p><strong>Use parallel agents when:</strong></p>
  <ul>
    <li>Tasks are independent (no shared dependencies)</li>
    <li>Results don't influence each other</li>
    <li>Time savings are valuable</li>
  </ul>

  <p><strong>Example:</strong></p>
  <pre><code>User: "Research Docker best practices and Kubernetes best practices"
Launch 2 research-synthesizer agents in parallel
Combine results when both complete</code></pre>

  <p><strong>Use sequential agents when:</strong></p>
  <ul>
    <li>Second task depends on first task's results</li>
    <li>Results need to be integrated progressively</li>
    <li>Resource constraints require staggered execution</li>
  </ul>

  <p><strong>Example:</strong></p>
  <pre><code>User: "Find session handling files, then validate them against Claude Code docs"
Step 1: hal-context-finder (locate files)
Step 2: claude-code-validator (validate found files)</code></pre>

  <h4>16.6.3 Result Validation</h4>

  <p>Always validate agent outputs:</p>

  <ul>
    <li><strong>Completeness:</strong> Did agent answer the full question?</li>
    <li><strong>Accuracy:</strong> Are facts and sources credible?</li>
    <li><strong>Format adherence:</strong> Is output properly structured?</li>
    <li><strong>Actionability:</strong> Can you use results without further research?</li>
  </ul>

  <p>If agent output is insufficient, relaunch with refined instructions.</p>

  <h4>16.6.4 Agent Composition</h4>

  <p>Combine agents for complex workflows:</p>

  <pre><code>Workflow: "Create comprehensive documentation for new feature"

Step 1: hal-context-finder
  Task: Find all related implementation files

Step 2: general-purpose
  Task: Analyze implementation, extract key concepts

Step 3: research-synthesizer
  Task: Research best practices for similar features

Step 4: Main session
  Task: Synthesize findings into documentation
  RAM: Contains only summaries from all agents (not raw data)</code></pre>

  <h4>16.6.5 Monitoring RAM Savings</h4>

  <p>Track effectiveness of agent delegation:</p>

  <table>
    <thead>
      <tr>
        <th>Metric</th>
        <th>How to Measure</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Tokens saved</td>
        <td>Estimate direct cost vs agent summary cost</td>
      </tr>
      <tr>
        <td>RAM zone impact</td>
        <td>Check RAM_ZONE before/after agent use</td>
      </tr>
      <tr>
        <td>Session longevity</td>
        <td>More agents = longer useful session time</td>
      </tr>
      <tr>
        <td>Task completion</td>
        <td>Can answer user without loading more context?</td>
      </tr>
    </tbody>
  </table>

  <div class="insight-box">
    <strong>Success indicator:</strong> If you remain in SAFE zone (0-80% RAM) while completing 
    context-heavy tasks, agent delegation is working effectively.
  </div>

</section>
            <!-- Section 17: Skills Reference -->
            <section id="skills-reference" data-status="complete" data-priority="2"
         data-sources=".claude/skills/*/SKILL.md,CLAUDE.md:Agent Skills"
         data-estimated-tokens="15000"
         data-dependencies="agent-reference">

  <div class="meta-guidance" style="display:none;">
    <!-- Meta-Guidance for AI Assistants -->
    This section documents HAL8000-Assistant's Agent Skills system - proactive, model-invoked capabilities.
    When updating:
    - Document all Skills with triggers, tools, and behaviors
    - Explain three-layer intelligence model (Skills ‚Üí Commands ‚Üí Agents)
    - Provide clear comparison table
    - Include activation examples
    - Note: Skills are NEW in v1.5.0, complement Commands/Agents
    TARGET: Comprehensive Skills reference for users and developers
    AUDIENCE: All three (users need to know when Skills activate, developers need details)
    KEY_POINTS: Model-invoked activation, four Skills catalog, triggers, tool permissions, integration
    TONE: Clear and practical, emphasize proactive collaboration
    VISUALS: three-layer-model diagram, skills-activation-flowchart
  </div>

  <h2>17. Skills Reference</h2>

  <div class="overview">
    <p><strong>Agent Skills</strong> are proactive capabilities that activate automatically based on context. Unlike Commands (user-invoked) or Agents (CPU-delegated), Skills are <strong>model-invoked</strong>‚Äîthe CPU autonomously detects when to use them and activates them without requiring permission.</p>

    <p>Skills implement collaborative intelligence: the CPU watches for patterns and suggests actions, while you maintain control through explicit Commands for critical operations.</p>
  </div>

  <h3>Three-Layer Intelligence Model</h3>

  <p>HAL8000-Assistant's intelligence operates in three complementary layers:</p>

  <figure class="diagram-placeholder" data-diagram-id="three-layer-model">
    <div class="placeholder-box">
      [DIAGRAM: Three-Layer Intelligence Model]
      Description: Vertical flowchart showing Skills (Proactive) ‚Üí Commands (Explicit) ‚Üí Agents (Delegated) with examples of each layer
      Type: Layered block diagram with arrows
      Details:
      - Layer 1 (top): Skills - "I detect patterns and suggest" - Examples: context-awareness, architecture-consultant
      - Layer 2 (middle): Commands - "You control critical operations" - Examples: /HAL-session-end, /HAL-system-check
      - Layer 3 (bottom): Agents - "I offload heavy work" - Examples: research-synthesizer, hal-context-finder
      Tools: Mermaid or SVG
    </div>
  </figure>

  <table>
    <thead>
      <tr>
        <th>Aspect</th>
        <th>Skills</th>
        <th>Commands</th>
        <th>Agents</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Invocation</strong></td>
        <td>Automatic (CPU decides)</td>
        <td>Explicit (user types <code>/HAL-*</code>)</td>
        <td>Delegated (CPU invokes via Task)</td>
      </tr>
      <tr>
        <td><strong>Purpose</strong></td>
        <td>Proactive assistance</td>
        <td>State operations</td>
        <td>Heavy isolated work</td>
      </tr>
      <tr>
        <td><strong>RAM Impact</strong></td>
        <td>Minimal (selective loading)</td>
        <td>Varies</td>
        <td>Zero (isolated 200K context)</td>
      </tr>
      <tr>
        <td><strong>Control</strong></td>
        <td>Collaborative</td>
        <td>User control</td>
        <td>CPU control</td>
      </tr>
      <tr>
        <td><strong>Example</strong></td>
        <td>Detect missing context</td>
        <td><code>/HAL-session-end</code></td>
        <td>research-synthesizer</td>
      </tr>
    </tbody>
  </table>

  <h3>Skills Catalog</h3>

  <h4>1. context-awareness</h4>

  <p><strong>Location:</strong> <code>.claude/skills/context-awareness/</code></p>

  <p><strong>Purpose:</strong> Detect when user questions require loading files not currently in RAM, and ask for clarification instead of guessing or loading speculatively.</p>

  <p><strong>Triggers:</strong></p>
  <ul>
    <li>User asks about specific code/files/components not in current RAM</li>
    <li>User references "that file", "the component", "this function" without clear antecedent</li>
    <li>User asks "which file has X?" (implies CPU should know the file set)</li>
    <li>User asks implementation details when CPU hasn't loaded implementation</li>
    <li>User uses project-specific terms/names not in current context</li>
  </ul>

  <p><strong>Behavior:</strong></p>
  <ul>
    <li>Parse question for missing context signals</li>
    <li>Ask user for clarification immediately</li>
    <li>Suggest specific search terms or file paths</li>
    <li>State what IS currently in context</li>
    <li>After clarification, use hal-context-finder agent for discovery</li>
  </ul>

  <p><strong>Tools Allowed:</strong> <code>Read</code>, <code>Glob</code>, <code>Grep</code>, <code>AskUserQuestion</code></p>

  <p><strong>Implementation:</strong> Context Awareness Protocol from BIOS Operating Principles</p>

  <div class="example-box">
    <strong>Example Activation:</strong>
    <pre><code>User: "Which file contains the authentication logic?"

CPU (context-awareness activates):
"I don't currently have authentication files loaded. Should I search
the codebase for authentication-related files? Or is there a specific
directory/component I should check?"</code></pre>
  </div>

  <h4>2. architecture-consultant</h4>

  <p><strong>Location:</strong> <code>.claude/skills/architecture-consultant/</code></p>

  <p><strong>Purpose:</strong> Validate design decisions against HAL8000-Assistant's architectural principles (von Neumann, Unix philosophy, Assembly concepts) and warn about violations.</p>

  <p><strong>Triggers:</strong></p>
  <ul>
    <li>Creating new commands or agents</li>
    <li>Modifying system structure or organization</li>
    <li>Design discussions about new features</li>
    <li>Code reviews</li>
    <li>User asks "should I..." or "how should I..." about system design</li>
  </ul>

  <p><strong>Behavior:</strong></p>
  <ul>
    <li>Identify which principle is violated and why</li>
    <li>Explain impact (immediate and long-term consequences)</li>
    <li>Suggest architecturally-sound alternatives</li>
    <li>Reference relevant architecture documentation if needed</li>
    <li>Provide positive reinforcement for good designs</li>
  </ul>

  <p><strong>Tools Allowed:</strong> <code>Read</code> (read-only analysis)</p>

  <p><strong>Reference:</strong> <code>.claude/skills/architecture-consultant/principles-reference.md</code> (quick lookup for principles)</p>

  <div class="example-box">
    <strong>Example Activation:</strong>
    <pre><code>User: "I want to create a path .claude/commands/system/utilities/helpers/file-ops/"

CPU (architecture-consultant activates):
"‚ö†Ô∏è Architecture Warning: Depth limit exceeded

Issue: Proposed path has 5 levels of depth
Principle: Unix Philosophy - 'Simple, not complex' (max 3 levels)

Impact:
- Violates HAL8000-Assistant structural standard
- Makes navigation harder

Recommended approach:
- Flatten to: .claude/commands/system/ (level 2)
- OR: .claude/commands/utilities/ if distinct category needed"</code></pre>
  </div>

  <h4>3. hal-script-assistant</h4>

  <p><strong>Location:</strong> <code>.claude/skills/hal-script-assistant/</code></p>

  <p><strong>Purpose:</strong> Help write HAL-Script commands and agents by guiding template selection, generating code, and validating structure.</p>

  <p><strong>Triggers:</strong></p>
  <ul>
    <li>User wants to create a new command</li>
    <li>User asks about HAL-Script syntax or structure</li>
    <li>User needs help choosing a template</li>
    <li>User is editing existing command/agent</li>
    <li>User invokes <code>/HAL-command-create</code> (automation)</li>
  </ul>

  <p><strong>Behavior:</strong></p>
  <ul>
    <li>Ask questions to determine appropriate template level (1-7)</li>
    <li>Guide through template selection decision tree</li>
    <li>Explain YAML frontmatter structure</li>
    <li>Suggest tool permissions based on command purpose</li>
    <li>Validate against architecture principles</li>
    <li>Generate code following HAL-Script patterns</li>
  </ul>

  <p><strong>Tools Allowed:</strong> <code>Read</code>, <code>Write</code>, <code>Edit</code>, <code>Glob</code></p>

  <p><strong>Integration:</strong> Works with command-builder agent and template library</p>

  <p><strong>Reference:</strong> <code>.claude/skills/hal-script-assistant/template-selector.md</code> (decision tree for template selection)</p>

  <div class="example-box">
    <strong>Example Activation:</strong>
    <pre><code>User: "I want to create a command that searches for files and analyzes them"

CPU (hal-script-assistant activates):
"Let me help you choose the right template for this command.

Questions:
1. Does it need conditionals or loops? (YES - searching and analyzing vary by file)
2. Does it delegate to agents? (Depends on analysis complexity)

Recommendation: Start with Level 3 (control-flow) template
- Supports conditionals for different file types
- Can add Level 4 (delegate) if analysis is heavy

Template: .claude/libraries/internal/templates/level-3-control-flow.md

Shall I help you generate the command structure?"</code></pre>
  </div>

  <h4>4. documentation-generator</h4>

  <p><strong>Location:</strong> <code>.claude/skills/documentation-generator/</code></p>

  <p><strong>Purpose:</strong> Create structured, professional documentation for sessions, decisions, architecture, and code.</p>

  <p><strong>Triggers:</strong></p>
  <ul>
    <li>User says: "document this", "create docs", "write this up"</li>
    <li>User requests: "session summary", "decision log", "architecture doc"</li>
    <li>Major milestone completed (new feature, system change)</li>
    <li>Complex decision made requiring rationale capture</li>
  </ul>

  <p><strong>Behavior:</strong></p>
  <ul>
    <li>Determine documentation type (session, decision, architecture, feature, README)</li>
    <li>Gather context (review work, identify decisions, note deliverables)</li>
    <li>Select and populate appropriate template</li>
    <li>Generate file in correct location with descriptive filename</li>
    <li>Report file location and summary to user</li>
  </ul>

  <p><strong>Tools Allowed:</strong> <code>Read</code>, <code>Write</code>, <code>Glob</code></p>

  <p><strong>Templates:</strong> 5 professional templates in <code>.claude/skills/documentation-generator/templates/</code>
    <ul>
      <li><code>session-doc-template.md</code> - Session work summaries</li>
      <li><code>decision-log-template.md</code> - Architectural/design decisions</li>
      <li><code>architecture-doc-template.md</code> - System architecture documentation</li>
      <li><code>feature-doc-template.md</code> - Feature documentation</li>
      <li><code>readme-template.md</code> - Component/project READMEs</li>
    </ul>
  </p>

  <div class="example-box">
    <strong>Example Activation:</strong>
    <pre><code>User: "Document today's work on the Skills integration"

CPU (documentation-generator activates):
"I'll create a session document for the Skills integration work.

[Gathers context from current session]
[Uses session-doc-template.md]
[Creates file: data/sessions/summaries/2025-10-20-1430-skills-integration.md]

‚úÖ Session documentation created

Location: data/sessions/summaries/2025-10-20-1430-skills-integration.md
Type: Session Documentation
Summary: Documented integration of 4 new Skills into HAL8000-Assistant architecture.
Size: ~1,200 words"</code></pre>
  </div>

  <h3>When Skills Activate</h3>

  <p>Skills trigger automatically based on context patterns. The CPU continuously monitors for activation conditions without requiring explicit permission:</p>

  <figure class="diagram-placeholder" data-diagram-id="skills-activation-flow">
    <div class="placeholder-box">
      [DIAGRAM: Skills Activation Flowchart]
      Description: Flowchart showing how CPU detects context patterns and activates appropriate Skills
      Type: Decision flowchart
      Details:
      - Start: User input received
      - Decision: Missing context detected? ‚Üí YES ‚Üí Activate context-awareness
      - Decision: Design decision detected? ‚Üí YES ‚Üí Activate architecture-consultant
      - Decision: Command creation detected? ‚Üí YES ‚Üí Activate hal-script-assistant
      - Decision: Documentation request? ‚Üí YES ‚Üí Activate documentation-generator
      - End: Normal processing (no Skill activation)
      Tools: Mermaid flowchart
    </div>
  </figure>

  <table>
    <thead>
      <tr>
        <th>Skill</th>
        <th>Activation Trigger</th>
        <th>User Experience</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>context-awareness</strong></td>
        <td>User questions require files not in RAM</td>
        <td>CPU asks clarifying questions instead of guessing</td>
      </tr>
      <tr>
        <td><strong>architecture-consultant</strong></td>
        <td>Design decisions or code reviews occur</td>
        <td>CPU warns about principle violations, suggests alternatives</td>
      </tr>
      <tr>
        <td><strong>hal-script-assistant</strong></td>
        <td>Command creation or HAL-Script questions arise</td>
        <td>CPU guides template selection and code generation</td>
      </tr>
      <tr>
        <td><strong>documentation-generator</strong></td>
        <td>User requests docs or major work completes</td>
        <td>CPU creates structured documentation from templates</td>
      </tr>
    </tbody>
  </table>

  <h3>Tool Permissions</h3>

  <p>Each Skill has explicitly whitelisted tools via the <code>allowed-tools</code> YAML frontmatter field. This implements security and performance optimization:</p>

  <table>
    <thead>
      <tr>
        <th>Skill</th>
        <th>Allowed Tools</th>
        <th>Rationale</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>context-awareness</strong></td>
        <td><code>Read, Glob, Grep, AskUserQuestion</code></td>
        <td>Read-only access + user questions. Cannot modify files.</td>
      </tr>
      <tr>
        <td><strong>architecture-consultant</strong></td>
        <td><code>Read</code></td>
        <td>Pure analysis. Only reads architecture docs, cannot modify anything.</td>
      </tr>
      <tr>
        <td><strong>hal-script-assistant</strong></td>
        <td><code>Read, Write, Edit, Glob</code></td>
        <td>Command creation requires write access. Limited to file operations.</td>
      </tr>
      <tr>
        <td><strong>documentation-generator</strong></td>
        <td><code>Read, Write, Glob</code></td>
        <td>Documentation creation requires write access. No edit (only creates new files).</td>
      </tr>
    </tbody>
  </table>

  <h3>Skills vs. Permission Model</h3>

  <p><strong>Key difference:</strong> When a Skill is active, the CPU can use its whitelisted tools <strong>without asking for permission</strong>. This enables proactive intelligence:</p>

  <ul>
    <li><strong>Without Skills:</strong> CPU must ask permission for every tool use, even simple Read operations</li>
    <li><strong>With Skills:</strong> CPU can proactively use whitelisted tools when Skill context is detected</li>
  </ul>

  <div class="insight-box">
    <strong>Design philosophy:</strong> Skills complement user control, they don't replace it. The CPU uses Skills for proactive assistance (suggesting, guiding, detecting), but critical operations (session-end, system state changes) remain under explicit user control via Commands.
  </div>

  <h3>Skills and Architecture Principles</h3>

  <p>Skills follow HAL8000-Assistant's core architectural principles:</p>

  <h4>Von Neumann Architecture</h4>
  <ul>
    <li><strong>Stored-program:</strong> Skills are files (<code>SKILL.md</code>) loaded by CPU like commands</li>
    <li><strong>Selective loading:</strong> Skills activate based on context, not loaded speculatively</li>
    <li><strong>RAM awareness:</strong> Skills minimize RAM impact through selective tool use</li>
  </ul>

  <h4>Unix Philosophy</h4>
  <ul>
    <li><strong>Do one thing well:</strong> Each Skill has single responsibility (context, architecture, scripting, docs)</li>
    <li><strong>Compose via interfaces:</strong> Skills complement Commands and Agents, not duplicate them</li>
    <li><strong>Text streams:</strong> All Skills use plain text files (Markdown)</li>
  </ul>

  <h4>Assembly Principles</h4>
  <ul>
    <li><strong>Explicit control:</strong> Tool permissions explicitly whitelisted in YAML</li>
    <li><strong>One-to-one mapping:</strong> Skill activation maps directly to context pattern detection</li>
    <li><strong>Low-level visibility:</strong> Skill behavior is documented and predictable</li>
  </ul>

  <div class="technical">
    <h3>Technical Implementation</h3>

    <h4>Skill File Structure</h4>
    <pre><code>.claude/skills/
‚îú‚îÄ‚îÄ context-awareness/
‚îÇ   ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ architecture-consultant/
‚îÇ   ‚îú‚îÄ‚îÄ SKILL.md
‚îÇ   ‚îî‚îÄ‚îÄ principles-reference.md
‚îú‚îÄ‚îÄ hal-script-assistant/
‚îÇ   ‚îú‚îÄ‚îÄ SKILL.md
‚îÇ   ‚îî‚îÄ‚îÄ template-selector.md
‚îî‚îÄ‚îÄ documentation-generator/
    ‚îú‚îÄ‚îÄ SKILL.md
    ‚îî‚îÄ‚îÄ templates/
        ‚îú‚îÄ‚îÄ session-doc-template.md
        ‚îú‚îÄ‚îÄ decision-log-template.md
        ‚îú‚îÄ‚îÄ architecture-doc-template.md
        ‚îú‚îÄ‚îÄ feature-doc-template.md
        ‚îî‚îÄ‚îÄ readme-template.md</code></pre>

    <h4>SKILL.md Format</h4>
    <pre><code>---
name: Skill Name
description: What this Skill does and when to activate (critical for discovery!)
allowed-tools:
  - Read
  - Write
---

# Skill Name

## Purpose
[What this Skill does]

## When to Activate
[Specific triggers and patterns]

## Protocol
[Step-by-step behavior]

## Examples
[Concrete activation examples]

## Integration with HAL8000-Assistant
[How this fits into architecture]</code></pre>

    <h4>Auto-Discovery</h4>
    <p>Skills are automatically discovered by Claude Code from <code>.claude/skills/</code>. The CPU reads all <code>SKILL.md</code> files on boot and monitors for activation patterns throughout the session.</p>

    <h4>Invocation Architecture</h4>
    <ol>
      <li>User provides input</li>
      <li>CPU parses input and context</li>
      <li>CPU checks all Skill descriptions for pattern matches</li>
      <li>If match found: Skill activates, CPU loads <code>SKILL.md</code></li>
      <li>CPU executes Skill protocol using whitelisted tools</li>
      <li>CPU provides output to user</li>
    </ol>

    <p><strong>RAM impact:</strong> Minimal. Skills are loaded only when activated (context-triggered), not speculatively.</p>
  </div>

  <div class="insight-box">
    <strong>Version history:</strong> Skills were added in HAL8000-Assistant v1.5.0 (2025-10-20). This is a new capability layer that complements the existing Commands and Agents architecture.
  </div>

</section>



            <!-- Section 18: File System Structure -->
            <section id="file-system" data-status="complete" data-priority="2" 
         data-sources="CLAUDE.md:File System Structure,CLAUDE.md:Memory Architecture" 
         data-estimated-tokens="12000" 
         data-dependencies="memory-architecture">
  
  <div class="meta-guidance" style="display:none;">
    <!-- Meta-Guidance for AI Assistants -->
    This section documents HAL8000-Assistant's file system organization as its memory architecture.
    When updating:
    - Maintain complete directory hierarchy table with all paths
    - Keep naming conventions synchronized with actual system behavior
    - Update depth limit rules if internal structure changes
    - External libraries remain exempt from depth limits
    - All example paths must be absolute from /mnt/d/~HAL8000-Assistant/
    - Verify access patterns match BIOS boot sequence
    Source of truth: CLAUDE.md (File System Structure, Memory Architecture sections)
  </div>

  <h2>18. File System</h2>

  <h3>17.1 Overview</h3>
  
  <p>
    In HAL8000-Assistant, the file system <strong>is</strong> the memory architecture. There is no separation between storage and memory‚Äîall persistent state, instructions, and data exist as files in a hierarchical directory structure. The CPU (Claude instance) loads files selectively into its volatile context window (RAM) as needed.
  </p>

  <div class="concept-box">
    <strong>Core Principle:</strong> Files are memory locations. Reading a file = loading memory into RAM. Writing a file = storing data to persistent memory. The total file system capacity exceeds RAM capacity, requiring selective loading discipline.
  </div>

  <h3>17.2 Directory Structure</h3>

  <p>
    The HAL8000-Assistant file system follows a modified Unix hierarchy with strict organizational rules derived from Unix philosophy (simplicity, modularity) and von Neumann principles (unified memory space).
  </p>

  <div class="diagram-container">
    <img src="assets/diagrams/directory-structure.png" alt="Directory Structure" style="max-width: 100%; height: auto;">
    <p class="diagram-caption">
      <strong>HAL8000-Assistant File System Hierarchy:</strong> Root directory with BIOS, system coordination (.claude/), and data storage
    </p>
  </div>

  <h4>17.2.1 Root Directory</h4>

  <table>
    <thead>
      <tr>
        <th>Path</th>
        <th>Purpose</th>
        <th>Access Pattern</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>/mnt/d/~HAL8000-Assistant/CLAUDE.md</code></td>
        <td>BIOS-ROM: Boot instructions, operating principles, architecture definition</td>
        <td>Loaded every boot (core file)</td>
      </tr>
      <tr>
        <td><code>/mnt/d/~HAL8000-Assistant/.env</code></td>
        <td>MCP server configuration (API keys)</td>
        <td>Read by MCP launcher</td>
      </tr>
      <tr>
        <td><code>/mnt/d/~HAL8000-Assistant/run-omnisearch.sh</code></td>
        <td>MCP server launch script</td>
        <td>Executed to start omnisearch</td>
      </tr>
    </tbody>
  </table>

  <h4>17.2.2 System Coordination Directory (.claude/)</h4>

  <p>
    The <code>.claude/</code> directory contains all system-level coordination files. This directory is the "kernel space" of HAL8000-Assistant‚Äîfiles here control system behavior, state, and instruction execution.
  </p>

  <table>
    <thead>
      <tr>
        <th>Path</th>
        <th>Purpose</th>
        <th>Access Pattern</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>.claude/state.json</code></td>
        <td>Current state pointer (timestamp, active_session, context, next_action)</td>
        <td>Loaded every boot (core file)</td>
      </tr>
      <tr>
        <td><code>.claude/system.log</code></td>
        <td>Historical audit trail (append-only log of all sessions)</td>
        <td>Never loaded into RAM; I/O only</td>
      </tr>
      <tr>
        <td><code>.claude/indexes/master.json</code></td>
        <td>Master file system index</td>
        <td>On-demand (discovery operations)</td>
      </tr>
      <tr>
        <td><code>.claude/indexes/[directory].json</code></td>
        <td>Per-directory indexes</td>
        <td>On-demand (discovery operations)</td>
      </tr>
      <tr>
        <td><code>.claude/sessions/</code></td>
        <td>Session handoff files for continuity across RAM wipes</td>
        <td>On-demand (only when resuming)</td>
      </tr>
      <tr>
        <td><code>.claude/commands/</code></td>
        <td>Executable instruction definitions (slash commands)</td>
        <td>On-demand (when command invoked)</td>
      </tr>
      <tr>
        <td><code>.claude/agents/</code></td>
        <td>Specialized agent definitions (sub-agent virtual memory)</td>
        <td>On-demand (when agent delegated)</td>
      </tr>
      <tr>
        <td><code>.claude/libraries/index.json</code></td>
        <td>Library catalog and metadata</td>
        <td>On-demand (library discovery)</td>
      </tr>
      <tr>
        <td><code>.claude/libraries/internal/</code></td>
        <td>Internally developed reusable instruction collections</td>
        <td>On-demand (when library loaded)</td>
      </tr>
      <tr>
        <td><code>.claude/libraries/external/</code></td>
        <td>External libraries (read-only, package managed)</td>
        <td>On-demand (when library loaded)</td>
      </tr>
      <tr>
        <td><code>.claude/tools/</code></td>
        <td>External program interfaces (MCP servers, scripts)</td>
        <td>Executed via I/O (not loaded)</td>
      </tr>
    </tbody>
  </table>

  <h4>17.2.3 Data Storage Directory (data/)</h4>

  <p>
    The <code>data/</code> directory contains all user-space data: research documents, architecture specifications, project files, and computational results.
  </p>

  <table>
    <thead>
      <tr>
        <th>Path</th>
        <th>Purpose</th>
        <th>Access Pattern</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>data/research/</code></td>
        <td>Research documents (comprehensive technical investigations)</td>
        <td>On-demand (reference material)</td>
      </tr>
      <tr>
        <td><code>data/architecture/</code></td>
        <td>System architecture specifications and design documents</td>
        <td>On-demand (reference material)</td>
      </tr>
      <tr>
        <td><code>data/projects/</code></td>
        <td>Project-specific data and results</td>
        <td>On-demand (project work)</td>
      </tr>
    </tbody>
  </table>

  <h3>17.3 Naming Conventions</h3>

  <h4>17.3.1 Command Files</h4>
  
  <p>
    All command files follow the pattern: <code>HAL-command-name.md</code>
  </p>

  <ul>
    <li><strong>Prefix:</strong> <code>HAL-</code> (identifies as HAL8000-Assistant command)</li>
    <li><strong>Name:</strong> Lowercase with hyphens (e.g., <code>session-end</code>, <code>register-dump</code>)</li>
    <li><strong>Extension:</strong> <code>.md</code> (Markdown format for human readability)</li>
  </ul>

  <div class="example">
    <strong>Examples:</strong>
    <ul>
      <li><code>.claude/commands/HAL-session-end.md</code></li>
      <li><code>.claude/commands/HAL-register-dump.md</code></li>
      <li><code>.claude/commands/HAL-context-find.md</code></li>
    </ul>
  </div>

  <h4>17.3.2 Agent Files</h4>

  <p>
    Agent files use descriptive hyphenated names without prefix: <code>agent-purpose.md</code>
  </p>

  <div class="example">
    <strong>Examples:</strong>
    <ul>
      <li><code>.claude/agents/research-synthesizer.md</code></li>
      <li><code>.claude/agents/hal-context-finder.md</code></li>
    </ul>
  </div>

  <h4>17.3.3 Session Files</h4>

  <p>
    Session files use ISO 8601 timestamp format with description: <code>YYYY-MM-DD-HHMM-description.md</code>
  </p>

  <ul>
    <li><strong>Date:</strong> <code>YYYY-MM-DD</code> (year-month-day)</li>
    <li><strong>Time:</strong> <code>HHMM</code> (24-hour format, hours and minutes)</li>
    <li><strong>Description:</strong> Hyphenated brief summary of session content</li>
    <li><strong>Extension:</strong> <code>.md</code> (Markdown format)</li>
  </ul>

  <div class="example">
    <strong>Examples:</strong>
    <ul>
      <li><code>.claude/sessions/2025-10-04-1455-architecture-research.md</code></li>
      <li><code>.claude/sessions/2025-10-09-2134-register-refactor.md</code></li>
    </ul>
  </div>

  <h4>17.3.4 Data Files</h4>

  <p>
    Data files may use numbered prefixes for ordering: <code>NN-descriptive-name.md</code>
  </p>

  <div class="example">
    <strong>Research documents:</strong>
    <ul>
      <li><code>data/research/01-von-neumann-architecture.md</code></li>
      <li><code>data/research/02-unix-philosophy.md</code></li>
      <li><code>data/research/03-assembly-language-principles.md</code></li>
    </ul>
  </div>

  <h3>17.4 Depth Limit Rules</h3>

  <p>
    HAL8000-Assistant enforces a <strong>maximum 3-level depth</strong> for internal code and system organization. This constraint derives from Unix philosophy: simplicity over complexity.
  </p>

  <h4>17.4.1 Rationale</h4>

  <div class="concept-box">
    <strong>Unix Philosophy: Simple, Not Complex</strong>
    <p>
      Deep hierarchies introduce cognitive overhead and navigation complexity. Three levels provide sufficient organization (root ‚Üí category ‚Üí item) while maintaining simplicity. Deeper nesting indicates over-engineering or poor categorization.
    </p>
  </div>

  <h4>17.4.2 Internal vs External Code</h4>

  <table>
    <thead>
      <tr>
        <th>Category</th>
        <th>Depth Limit</th>
        <th>Rationale</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Internal Code</strong><br/>(HAL8000-Assistant system, commands, agents, internal libraries)</td>
        <td>3 levels maximum</td>
        <td>We control structure; enforce simplicity</td>
      </tr>
      <tr>
        <td><strong>External Libraries</strong><br/>(<code>.claude/libraries/external/</code>)</td>
        <td>No limit (exempt)</td>
        <td>Preserve upstream structure for compatibility and updates</td>
      </tr>
    </tbody>
  </table>

  <h4>17.4.3 Compliant Structure Examples</h4>

  <div class="example">
    <strong>‚úì Compliant (3 levels):</strong>
    <pre>
/mnt/d/~HAL8000-Assistant/              # Level 1: Root
‚îú‚îÄ‚îÄ .claude/                  # Level 2: Category
‚îÇ   ‚îî‚îÄ‚îÄ commands/             # Level 3: Items
‚îÇ       ‚îî‚îÄ‚îÄ HAL-*.md
    </pre>
  </div>

  <div class="example">
    <strong>‚úó Non-Compliant (4 levels):</strong>
    <pre>
/mnt/d/~HAL8000-Assistant/              # Level 1
‚îú‚îÄ‚îÄ .claude/                  # Level 2
‚îÇ   ‚îî‚îÄ‚îÄ commands/             # Level 3
‚îÇ       ‚îî‚îÄ‚îÄ subsystem/        # Level 4 - TOO DEEP!
‚îÇ           ‚îî‚îÄ‚îÄ HAL-*.md
    </pre>
    <strong>Solution:</strong> Flatten by moving subsystem files to level 3, or use naming convention (<code>HAL-subsystem-command.md</code>) instead of directory nesting.
  </div>

  <h4>17.4.4 External Library Exception</h4>

  <div class="example">
    <strong>‚úì Allowed (external library):</strong>
    <pre>
/mnt/d/~HAL8000-Assistant/                    # Level 1
‚îú‚îÄ‚îÄ .claude/                        # Level 2
‚îÇ   ‚îî‚îÄ‚îÄ libraries/                  # Level 3
‚îÇ       ‚îî‚îÄ‚îÄ external/               # Level 4 (exempt)
‚îÇ           ‚îî‚îÄ‚îÄ some-library/       # Level 5 (exempt)
‚îÇ               ‚îî‚îÄ‚îÄ deeply/         # Level 6 (exempt)
‚îÇ                   ‚îî‚îÄ‚îÄ nested/     # Level 7 (exempt) - OK for external code
    </pre>
  </div>

  <h3>17.5 Storage Patterns</h3>

  <p>
    Different types of data have designated storage locations. This organization ensures predictable file discovery and maintains separation of concerns.
  </p>

  <table>
    <thead>
      <tr>
        <th>Data Type</th>
        <th>Storage Location</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Current State</strong></td>
        <td><code>.claude/state.json</code></td>
        <td>Single source of truth for system state (timestamp, active session pointer, context summary, next action)</td>
      </tr>
      <tr>
        <td><strong>Session Continuity</strong></td>
        <td><code>.claude/sessions/</code></td>
        <td>Complete context capture for resuming work after RAM wipe</td>
      </tr>
      <tr>
        <td><strong>Historical Audit</strong></td>
        <td><code>.claude/system.log</code></td>
        <td>Append-only log of all sessions (never loaded into RAM)</td>
      </tr>
      <tr>
        <td><strong>Commands</strong></td>
        <td><code>.claude/commands/</code></td>
        <td>Executable instruction definitions (slash command implementations)</td>
      </tr>
      <tr>
        <td><strong>Agents</strong></td>
        <td><code>.claude/agents/</code></td>
        <td>Specialized agent definitions (sub-agent specifications)</td>
      </tr>
      <tr>
        <td><strong>Libraries</strong></td>
        <td><code>.claude/libraries/internal/</code><br/><code>.claude/libraries/external/</code></td>
        <td>Reusable instruction collections (internal development vs external packages)</td>
      </tr>
      <tr>
        <td><strong>File System Indexes</strong></td>
        <td><code>.claude/indexes/</code></td>
        <td>Hierarchical indexes for file discovery without loading all files</td>
      </tr>
      <tr>
        <td><strong>Research Documents</strong></td>
        <td><code>data/research/</code></td>
        <td>Comprehensive technical investigations and reference material</td>
      </tr>
      <tr>
        <td><strong>Architecture Specs</strong></td>
        <td><code>data/architecture/</code></td>
        <td>System design documents, architecture decisions, technical specifications</td>
      </tr>
      <tr>
        <td><strong>Project Data</strong></td>
        <td><code>data/projects/</code></td>
        <td>Project-specific files, computational results, temporary data</td>
      </tr>
    </tbody>
  </table>

  <h3>17.6 File Types and Roles</h3>

  <h4>17.6.1 State Files (.json)</h4>

  <p>
    JSON files store structured state data with strict schemas.
  </p>

  <table>
    <thead>
      <tr>
        <th>File</th>
        <th>Schema</th>
        <th>Update Pattern</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>state.json</code></td>
        <td><code>{timestamp, active_session, context, next_action, phase, architecture_type}</code></td>
        <td>Updated on every session end</td>
      </tr>
      <tr>
        <td><code>indexes/master.json</code></td>
        <td>File system hierarchy metadata</td>
        <td>Updated via <code>/HAL-index-update</code></td>
      </tr>
      <tr>
        <td><code>libraries/index.json</code></td>
        <td>Library catalog with metadata</td>
        <td>Updated when libraries added/removed</td>
      </tr>
    </tbody>
  </table>

  <h4>17.6.2 Command Files (.md)</h4>

  <p>
    Markdown files defining executable commands. Each command file contains:
  </p>

  <ul>
    <li><strong>Purpose:</strong> What the command does</li>
    <li><strong>Usage:</strong> How to invoke the command</li>
    <li><strong>Implementation:</strong> Step-by-step instructions for CPU execution</li>
    <li><strong>Error Handling:</strong> How to handle failures</li>
    <li><strong>Examples:</strong> Sample invocations and outputs</li>
  </ul>

  <h4>17.6.3 Session Files (.md)</h4>

  <p>
    Markdown files capturing complete session context for continuity. Structure:
  </p>

  <ul>
    <li><strong>Metadata:</strong> Timestamp, session ID, description</li>
    <li><strong>Context Summary:</strong> What was being worked on</li>
    <li><strong>Loaded Files:</strong> CONTEXT_MANIFEST register contents</li>
    <li><strong>Register State:</strong> All CPU registers at session end</li>
    <li><strong>Work Completed:</strong> What was accomplished</li>
    <li><strong>Next Actions:</strong> What to do on resume</li>
  </ul>

  <h4>17.6.4 Data Files (.md)</h4>

  <p>
    Markdown files storing research, documentation, and results. Format varies by subdirectory:
  </p>

  <ul>
    <li><strong>Research documents:</strong> Title, metadata, overview, detailed sections, references</li>
    <li><strong>Architecture specs:</strong> Introduction, design goals, components, diagrams, decisions</li>
    <li><strong>Project data:</strong> Free-form (project-specific structure)</li>
  </ul>

  <h3>17.7 Access Patterns</h3>

  <p>
    Files are loaded into RAM according to strict access patterns. Understanding these patterns is critical for RAM management.
  </p>

  <h4>17.7.1 Core Files (Boot Time)</h4>

  <p>
    Core files are <strong>always</strong> loaded on every boot. Failure to load = system failure.
  </p>

  <table>
    <thead>
      <tr>
        <th>File</th>
        <th>Purpose</th>
        <th>Failure Mode</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>CLAUDE.md</code></td>
        <td>BIOS: Architecture, operating principles, boot sequence</td>
        <td>CRITICAL: Cannot boot without BIOS</td>
      </tr>
      <tr>
        <td><code>.claude/state.json</code></td>
        <td>State pointer: timestamp, active_session, context, next_action</td>
        <td>CRITICAL: No state = degraded mode</td>
      </tr>
    </tbody>
  </table>

  <h4>17.7.2 On-Demand Files</h4>

  <p>
    On-demand files are loaded <strong>only when needed</strong> for current task. This is the majority of files.
  </p>

  <table>
    <thead>
      <tr>
        <th>File Category</th>
        <th>Load Trigger</th>
        <th>RAM Cost</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Session Files</strong></td>
        <td>User says "resume" or "continue previous work"</td>
        <td>5K-15K tokens (high)</td>
      </tr>
      <tr>
        <td><strong>Commands</strong></td>
        <td>Command invoked via <code>/HAL-command-name</code></td>
        <td>2K-5K tokens (medium)</td>
      </tr>
      <tr>
        <td><strong>Agents</strong></td>
        <td>Agent delegated for sub-task</td>
        <td>3K-8K tokens (medium-high)</td>
      </tr>
      <tr>
        <td><strong>Libraries</strong></td>
        <td>Explicitly loaded for current task</td>
        <td>Variable (library-dependent)</td>
      </tr>
      <tr>
        <td><strong>Research Docs</strong></td>
        <td>Referenced during work requiring deep understanding</td>
        <td>10K-30K tokens (very high)</td>
      </tr>
      <tr>
        <td><strong>Architecture Specs</strong></td>
        <td>Referenced during system design or debugging</td>
        <td>8K-20K tokens (high)</td>
      </tr>
      <tr>
        <td><strong>Indexes</strong></td>
        <td>File discovery operations (via <code>/HAL-context-find</code>)</td>
        <td>1K-3K tokens (low)</td>
      </tr>
    </tbody>
  </table>

  <h4>17.7.3 Never-Loaded Files (I/O Only)</h4>

  <p>
    Some files are <strong>never loaded into RAM</strong>. They are accessed only via I/O operations (append, read on demand).
  </p>

  <table>
    <thead>
      <tr>
        <th>File</th>
        <th>Purpose</th>
        <th>Access Method</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>.claude/system.log</code></td>
        <td>Historical audit trail (all sessions)</td>
        <td>Append-only writes; read specific entries on demand (never full load)</td>
      </tr>
      <tr>
        <td><strong>Tool Scripts</strong></td>
        <td>External programs (<code>.claude/tools/</code>)</td>
        <td>Executed via Bash tool; output captured (script itself not loaded)</td>
      </tr>
    </tbody>
  </table>

  <h4>17.7.4 Access Pattern Decision Tree</h4>

  <div class="concept-box">
    <strong>Before loading any file, ask:</strong>
    <ol>
      <li><strong>Is it a core file?</strong> ‚Üí Load immediately on boot</li>
      <li><strong>Is it needed for current task?</strong> ‚Üí Load now (on-demand)</li>
      <li><strong>Can I delegate discovery?</strong> ‚Üí Use <code>/HAL-context-find</code> sub-agent (saves 60-85% RAM)</li>
      <li><strong>Is it I/O-only?</strong> ‚Üí Never load; append/read specific sections</li>
      <li><strong>Can I infer from already-loaded context?</strong> ‚Üí Don't load; work with existing RAM</li>
    </ol>
  </div>

  <h3>17.8 File System as Memory Architecture</h3>

  <p>
    The file system isn't just storage‚Äîit's the complete memory architecture of HAL8000-Assistant. Understanding this mapping is essential.
  </p>

  <table>
    <thead>
      <tr>
        <th>Memory Concept</th>
        <th>File System Equivalent</th>
        <th>Characteristics</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>RAM</strong></td>
        <td>CPU context window (volatile)</td>
        <td>Limited capacity (~200K tokens), append-only within session, wiped on new session</td>
      </tr>
      <tr>
        <td><strong>Persistent Memory</strong></td>
        <td>File system (files on disk)</td>
        <td>Unlimited capacity, survives RAM wipes, selective loading required</td>
      </tr>
      <tr>
        <td><strong>ROM</strong></td>
        <td><code>CLAUDE.md</code> (BIOS)</td>
        <td>Read-only, defines system behavior, loaded every boot</td>
      </tr>
      <tr>
        <td><strong>CMOS/NVRAM</strong></td>
        <td><code>state.json</code></td>
        <td>Small persistent state, updated frequently, critical for continuity</td>
      </tr>
      <tr>
        <td><strong>Virtual Memory</strong></td>
        <td>Sub-agents (isolated contexts)</td>
        <td>Extend total RAM capacity via process isolation; return summaries not raw data</td>
      </tr>
      <tr>
        <td><strong>Swap Space</strong></td>
        <td>Session files</td>
        <td>Context moved to disk before RAM exhaustion; loaded back on resume</td>
      </tr>
      <tr>
        <td><strong>Memory Segments</strong></td>
        <td>Directories</td>
        <td>Logical grouping: system (.claude/), data (data/), by function</td>
      </tr>
    </tbody>
  </table>

  <div class="note">
    <strong>Key Insight:</strong> Total file system capacity far exceeds RAM capacity. This is by design. The CPU must practice <em>selective loading discipline</em>‚Äîloading only what's needed for the current task, offloading results to persistent memory, and using sub-agents to extend effective capacity through context isolation.
  </div>

</section>

            <!-- Section 19: MCP Integration -->
            <section id="mcp-integration" data-status="complete" data-priority="2" 
         data-sources="CLAUDE.md:MCP Integration,.claude/commands/HAL-mcp-control.md" 
         data-estimated-tokens="12000" 
         data-dependencies="">
  
  <div class="meta-guidance" style="display:none;">
    This section documents HAL8000-Assistant's integration with Model Context Protocol (MCP) servers.
    MCP extends HAL8000-Assistant's capabilities through external tool servers.
    
    Maintenance notes:
    - Keep tool catalog synchronized with actual MCP server configurations
    - Update /HAL-mcp-control documentation when command evolves
    - Verify server status defaults if MCP configuration changes
    - Document new MCP servers as they are added to the system
    
    Sources: CLAUDE.md MCP Integration section, .claude/commands/HAL-mcp-control.md
  </div>

  <h2>19. MCP Integration</h2>

  <h3>18.1 Introduction</h3>
  
  <p>
    The Model Context Protocol (MCP) is an open protocol that enables AI assistants to 
    interact with external tools and data sources through a standardized interface. 
    HAL8000-Assistant integrates with MCP to extend the CPU's capabilities beyond native Claude Code 
    tools, providing enhanced web search, file system operations, and IDE integration.
  </p>

  <p>
    MCP servers run as separate processes that expose tools through a JSON-RPC protocol. 
    The HAL8000-Assistant CPU can invoke these tools as if they were native operations, enabling 
    modular extension of system capabilities without requiring changes to the core architecture.
  </p>

  <h4>18.1.1 Why HAL8000-Assistant Uses MCP</h4>

  <ul>
    <li><strong>Extended Capabilities:</strong> Access specialized tools (advanced web search, 
        content extraction) not available in native Claude Code</li>
    <li><strong>Modular Design:</strong> Add/remove capabilities without modifying core system</li>
    <li><strong>RAM Optimization:</strong> Dynamically load/unload servers to manage context usage</li>
    <li><strong>Standardized Interface:</strong> Consistent tool invocation across different server types</li>
    <li><strong>External Integration:</strong> Connect to VS Code, file systems, and web APIs</li>
  </ul>

  <h3>18.2 MCP Architecture</h3>

  <div class="diagram-container">
    <img src="assets/diagrams/mcp-architecture.png" alt="MCP Architecture" style="max-width: 100%; height: auto;">
    <p class="diagram-caption">
      <strong>Transport:</strong> stdio (omnisearch) | SSE (filesystem, ide)<br>
      <strong>Protocol:</strong> JSON-RPC 2.0<br>
      <strong>Tool Prefix:</strong> mcp__[server]__[tool_name]
    </p>
  </div>

  <h4>18.2.1 Protocol Overview</h4>

  <p>
    MCP uses JSON-RPC 2.0 for communication between the HAL8000-Assistant CPU and MCP servers. 
    Each server exposes a set of tools with defined schemas. The CPU invokes tools by 
    sending JSON-RPC requests and receives structured responses.
  </p>

  <p><strong>Key Protocol Characteristics:</strong></p>
  <ul>
    <li><strong>Stateless Invocation:</strong> Each tool call is independent</li>
    <li><strong>Typed Parameters:</strong> Tool parameters have JSONSchema definitions</li>
    <li><strong>Standardized Errors:</strong> Consistent error reporting across servers</li>
    <li><strong>Resource Discovery:</strong> Servers can expose resources (files, data) via URIs</li>
  </ul>

  <h4>18.2.2 Server Types</h4>

  <table>
    <thead>
      <tr>
        <th>Server</th>
        <th>Transport</th>
        <th>Purpose</th>
        <th>Default Status</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>omnisearch</code></td>
        <td>stdio</td>
        <td>Web search and content extraction</td>
        <td>Disabled (manual enable)</td>
      </tr>
      <tr>
        <td><code>filesystem</code></td>
        <td>SSE</td>
        <td>Direct file system operations</td>
        <td>Enabled</td>
      </tr>
      <tr>
        <td><code>ide</code></td>
        <td>SSE</td>
        <td>VS Code integration</td>
        <td>Enabled</td>
      </tr>
    </tbody>
  </table>

  <h4>18.2.3 Tool Exposure Pattern</h4>

  <p>
    MCP tools are exposed to the CPU with a naming convention: 
    <code>mcp__[server]__[tool_name]</code>. This prevents naming conflicts and 
    makes the tool's origin explicit.
  </p>

  <p><strong>Example:</strong></p>
  <pre><code>mcp__omnisearch__web_search       # Web search via omnisearch server
mcp__filesystem__read_text_file   # Read file via filesystem server
mcp__ide__getDiagnostics          # Get diagnostics via ide server</code></pre>

  <h3>18.3 Configured MCP Servers</h3>

  <h4>18.3.1 omnisearch Server</h4>

  <p>
    Provides enhanced web search and content extraction capabilities through integration 
    with multiple search providers and web scraping services.
  </p>

  <table>
    <thead>
      <tr>
        <th>Property</th>
        <th>Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Transport</strong></td>
        <td>stdio</td>
      </tr>
      <tr>
        <td><strong>Configuration</strong></td>
        <td><code>.env</code> (API keys for Brave, Firecrawl)</td>
      </tr>
      <tr>
        <td><strong>Launch Script</strong></td>
        <td><code>run-omnisearch.sh</code></td>
      </tr>
      <tr>
        <td><strong>Default Status</strong></td>
        <td>Disabled (high RAM cost)</td>
      </tr>
      <tr>
        <td><strong>Tools Provided</strong></td>
        <td>2 tools (web_search, firecrawl_process)</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Provided Tools:</strong></p>
  <ul>
    <li><code>mcp__omnisearch__web_search</code> - Multi-provider web search (Tavily, Brave, Kagi, Exa)</li>
    <li><code>mcp__omnisearch__firecrawl_process</code> - Web content extraction (scrape, crawl, map, extract, actions)</li>
  </ul>

  <p><strong>Use Cases:</strong></p>
  <ul>
    <li>Research tasks requiring current web information</li>
    <li>Content extraction from web pages</li>
    <li>Deep web crawling for documentation</li>
    <li>Structured data extraction from websites</li>
  </ul>

  <p><strong>When to Enable:</strong></p>
  <pre><code>/HAL-mcp-control enable omnisearch</code></pre>
  <p>Enable when user explicitly requests web research or when delegating to research-synthesizer agent.</p>

  <h4>18.3.2 filesystem Server</h4>

  <p>
    Provides comprehensive file system operations including reading, writing, searching, 
    and directory management. Operates within configured allowed directories.
  </p>

  <table>
    <thead>
      <tr>
        <th>Property</th>
        <th>Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Transport</strong></td>
        <td>SSE (Server-Sent Events)</td>
      </tr>
      <tr>
        <td><strong>Configuration</strong></td>
        <td>Allowed directories configured in MCP settings</td>
      </tr>
      <tr>
        <td><strong>Default Status</strong></td>
        <td>Enabled</td>
      </tr>
      <tr>
        <td><strong>Tools Provided</strong></td>
        <td>18 tools (read, write, edit, search, directory ops)</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Tool Categories:</strong></p>

  <p><em>Reading Tools:</em></p>
  <ul>
    <li><code>mcp__filesystem__read_file</code> - Read file as text (deprecated, use read_text_file)</li>
    <li><code>mcp__filesystem__read_text_file</code> - Read complete file with encoding support</li>
    <li><code>mcp__filesystem__read_media_file</code> - Read image/audio as base64</li>
    <li><code>mcp__filesystem__read_multiple_files</code> - Batch read multiple files</li>
  </ul>

  <p><em>Writing Tools:</em></p>
  <ul>
    <li><code>mcp__filesystem__write_file</code> - Create or overwrite file</li>
    <li><code>mcp__filesystem__edit_file</code> - Line-based edits with diff output</li>
  </ul>

  <p><em>Directory Tools:</em></p>
  <ul>
    <li><code>mcp__filesystem__create_directory</code> - Create directories (nested supported)</li>
    <li><code>mcp__filesystem__list_directory</code> - List files and directories</li>
    <li><code>mcp__filesystem__list_directory_with_sizes</code> - List with size information</li>
    <li><code>mcp__filesystem__directory_tree</code> - Recursive JSON tree structure</li>
  </ul>

  <p><em>Search and Discovery:</em></p>
  <ul>
    <li><code>mcp__filesystem__search_files</code> - Recursive pattern-based search</li>
    <li><code>mcp__filesystem__get_file_info</code> - File metadata (size, timestamps, permissions)</li>
    <li><code>mcp__filesystem__list_allowed_directories</code> - Show accessible directories</li>
  </ul>

  <p><em>File Operations:</em></p>
  <ul>
    <li><code>mcp__filesystem__move_file</code> - Move or rename files/directories</li>
  </ul>

  <p><strong>Security Model:</strong></p>
  <p>
    All filesystem operations are restricted to configured allowed directories. 
    Attempts to access files outside these directories will fail with permission errors.
  </p>

  <h4>18.3.3 ide Server</h4>

  <p>
    Provides integration with VS Code for diagnostics and code execution in Jupyter kernels.
  </p>

  <table>
    <thead>
      <tr>
        <th>Property</th>
        <th>Value</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Transport</strong></td>
        <td>SSE</td>
      </tr>
      <tr>
        <td><strong>Configuration</strong></td>
        <td>VS Code workspace integration</td>
      </tr>
      <tr>
        <td><strong>Default Status</strong></td>
        <td>Enabled</td>
      </tr>
      <tr>
        <td><strong>Tools Provided</strong></td>
        <td>2 tools (diagnostics, code execution)</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Provided Tools:</strong></p>
  <ul>
    <li><code>mcp__ide__getDiagnostics</code> - Get language diagnostics (errors, warnings) from VS Code</li>
    <li><code>mcp__ide__executeCode</code> - Execute Python code in Jupyter kernel</li>
  </ul>

  <p><strong>Use Cases:</strong></p>
  <ul>
    <li>Checking code for syntax errors and warnings</li>
    <li>Running Python code in notebook context</li>
    <li>Validating code changes before committing</li>
  </ul>

  <h3>18.4 Dynamic MCP Control</h3>

  <p>
    The <code>/HAL-mcp-control</code> command provides dynamic management of MCP servers 
    to optimize RAM usage. Since MCP server contexts consume RAM, selectively enabling 
    servers only when needed helps maintain RAM_ZONE: SAFE.
  </p>

  <h4>18.4.1 Command Syntax</h4>

  <pre><code>/HAL-mcp-control [command] [server_name]</code></pre>

  <p><strong>Commands:</strong></p>
  <ul>
    <li><code>status</code> - Show current status of all MCP servers</li>
    <li><code>enable [server]</code> - Enable specified MCP server</li>
    <li><code>disable [server]</code> - Disable specified MCP server</li>
  </ul>

  <h4>18.4.2 Usage Examples</h4>

  <p><strong>Check Server Status:</strong></p>
  <pre><code>/HAL-mcp-control status</code></pre>

  <p><em>Output:</em></p>
  <pre><code>MCP Server Status:
‚îú‚îÄ omnisearch: DISABLED (high RAM cost - enable when needed for research)
‚îú‚îÄ filesystem: ENABLED (18 tools available)
‚îî‚îÄ ide: ENABLED (2 tools available)

RAM Optimization:
- Enable omnisearch only for research tasks
- Disable unused servers to free RAM
- Current configuration optimized for general use</code></pre>

  <p><strong>Enable omnisearch for Research:</strong></p>
  <pre><code>/HAL-mcp-control enable omnisearch</code></pre>

  <p><em>Output:</em></p>
  <pre><code>‚úì Enabled MCP server: omnisearch
Tools now available:
- mcp__omnisearch__web_search (multi-provider search)
- mcp__omnisearch__firecrawl_process (content extraction)

Note: omnisearch has high RAM cost. Disable after research completes.</code></pre>

  <p><strong>Disable After Research:</strong></p>
  <pre><code>/HAL-mcp-control disable omnisearch</code></pre>

  <p><em>Output:</em></p>
  <pre><code>‚úì Disabled MCP server: omnisearch
RAM freed for other operations</code></pre>

  <h4>18.4.3 When to Enable/Disable Servers</h4>

  <table>
    <thead>
      <tr>
        <th>Server</th>
        <th>Enable When</th>
        <th>Disable When</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>omnisearch</code></td>
        <td>
          - User requests web research<br>
          - Delegating to research-synthesizer<br>
          - Need current web information
        </td>
        <td>
          - Research task complete<br>
          - RAM_ZONE approaching CAUTION<br>
          - Not needed for current work
        </td>
      </tr>
      <tr>
        <td><code>filesystem</code></td>
        <td>
          - File operations needed<br>
          - Batch file processing<br>
          - Directory tree analysis
        </td>
        <td>
          - Prefer native Read/Write tools<br>
          - Minimal file operations needed
        </td>
      </tr>
      <tr>
        <td><code>ide</code></td>
        <td>
          - Need VS Code diagnostics<br>
          - Python code execution<br>
          - Jupyter notebook work
        </td>
        <td>
          - No IDE integration needed<br>
          - Working outside notebooks
        </td>
      </tr>
    </tbody>
  </table>

  <h4>18.4.4 RAM Optimization Strategy</h4>

  <p><strong>Default Configuration (RAM-Optimized):</strong></p>
  <ul>
    <li><code>omnisearch</code>: DISABLED (enable on-demand)</li>
    <li><code>filesystem</code>: ENABLED (frequently used)</li>
    <li><code>ide</code>: ENABLED (low RAM cost)</li>
  </ul>

  <p><strong>Best Practices:</strong></p>
  <ol>
    <li>Check server status before major tasks: <code>/HAL-mcp-control status</code></li>
    <li>Enable omnisearch only for research, disable immediately after</li>
    <li>Monitor RAM_ZONE when multiple servers enabled</li>
    <li>Document server state changes in session notes</li>
    <li>Prefer native tools when MCP not required</li>
  </ol>

  <h3>18.5 MCP vs Native Tools</h3>

  <p>
    HAL8000-Assistant has both MCP-provided tools and native Claude Code tools. Understanding when 
    to use each optimizes performance and RAM usage.
  </p>

  <h4>18.5.1 File Operations Comparison</h4>

  <table>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Native Tool</th>
        <th>MCP Tool</th>
        <th>Recommendation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Read single file</td>
        <td><code>Read</code></td>
        <td><code>mcp__filesystem__read_text_file</code></td>
        <td>Use <strong>Read</strong> (lower overhead)</td>
      </tr>
      <tr>
        <td>Read multiple files</td>
        <td>Multiple <code>Read</code> calls</td>
        <td><code>mcp__filesystem__read_multiple_files</code></td>
        <td>Use <strong>MCP</strong> (batch efficiency)</td>
      </tr>
      <tr>
        <td>Write file</td>
        <td><code>Write</code></td>
        <td><code>mcp__filesystem__write_file</code></td>
        <td>Use <strong>Write</strong> (simpler)</td>
      </tr>
      <tr>
        <td>Edit file</td>
        <td><code>Edit</code></td>
        <td><code>mcp__filesystem__edit_file</code></td>
        <td>Use <strong>Edit</strong> (string-based, proven)</td>
      </tr>
      <tr>
        <td>Search files</td>
        <td><code>Grep</code></td>
        <td><code>mcp__filesystem__search_files</code></td>
        <td>Use <strong>Grep</strong> (regex, powerful)</td>
      </tr>
      <tr>
        <td>List directory</td>
        <td><code>Bash: ls</code></td>
        <td><code>mcp__filesystem__list_directory</code></td>
        <td>Use <strong>MCP</strong> (structured output)</td>
      </tr>
      <tr>
        <td>File metadata</td>
        <td><code>Bash: stat</code></td>
        <td><code>mcp__filesystem__get_file_info</code></td>
        <td>Use <strong>MCP</strong> (parsed data)</td>
      </tr>
      <tr>
        <td>Directory tree</td>
        <td><code>Bash: tree</code></td>
        <td><code>mcp__filesystem__directory_tree</code></td>
        <td>Use <strong>MCP</strong> (JSON structure)</td>
      </tr>
    </tbody>
  </table>

  <h4>18.5.2 Decision Framework</h4>

  <p><strong>Prefer Native Tools When:</strong></p>
  <ul>
    <li>Single, simple operations (read one file, write one file)</li>
    <li>Content-based search (Grep's regex is more powerful)</li>
    <li>String-based editing (Edit tool is battle-tested)</li>
    <li>RAM_ZONE is CAUTION or DANGER (minimize overhead)</li>
  </ul>

  <p><strong>Prefer MCP Tools When:</strong></p>
  <ul>
    <li>Batch operations (read/process multiple files)</li>
    <li>Structured data needed (directory trees as JSON)</li>
    <li>File metadata required (timestamps, permissions, sizes)</li>
    <li>Path-based search (pattern matching on filenames)</li>
    <li>Need parsed, structured responses (not raw text)</li>
  </ul>

  <h4>18.5.3 Web Operations</h4>

  <table>
    <thead>
      <tr>
        <th>Operation</th>
        <th>Native Tool</th>
        <th>MCP Tool</th>
        <th>Recommendation</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Simple web search</td>
        <td><code>WebSearch</code></td>
        <td><code>mcp__omnisearch__web_search</code></td>
        <td>Use <strong>MCP</strong> (more providers)</td>
      </tr>
      <tr>
        <td>Fetch web page</td>
        <td><code>WebFetch</code></td>
        <td><code>mcp__omnisearch__firecrawl_process</code></td>
        <td>Use <strong>MCP</strong> (better extraction)</td>
      </tr>
      <tr>
        <td>Deep web crawl</td>
        <td>Not available</td>
        <td><code>mcp__omnisearch__firecrawl_process</code></td>
        <td>Use <strong>MCP</strong> (only option)</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Note:</strong> omnisearch must be enabled before use: <code>/HAL-mcp-control enable omnisearch</code></p>

  <h3>18.6 Configuration</h3>

  <h4>18.6.1 MCP Server Configuration Files</h4>

  <p>
    MCP servers are configured in Claude Code's MCP settings. HAL8000-Assistant uses both stdio 
    and SSE transport mechanisms depending on server requirements.
  </p>

  <p><strong>omnisearch Configuration:</strong></p>
  <pre><code># .env
BRAVE_API_KEY=your_brave_api_key
FIRECRAWL_API_KEY=your_firecrawl_api_key</code></pre>

  <p><strong>Launch Script:</strong></p>
  <pre><code># run-omnisearch.sh
#!/bin/bash
# Launches omnisearch MCP server with environment variables
source .env
exec omnisearch-server</code></pre>

  <h4>18.6.2 Transport Types</h4>

  <table>
    <thead>
      <tr>
        <th>Transport</th>
        <th>Description</th>
        <th>Used By</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>stdio</strong></td>
        <td>Standard input/output communication. Server runs as subprocess, 
            communicates via stdin/stdout.</td>
        <td>omnisearch</td>
      </tr>
      <tr>
        <td><strong>SSE</strong></td>
        <td>Server-Sent Events over HTTP. Server runs independently, 
            CPU connects via HTTP endpoint.</td>
        <td>filesystem, ide</td>
      </tr>
    </tbody>
  </table>

  <h4>18.6.3 Environment Variables</h4>

  <p>
    MCP servers requiring API keys or credentials use environment variables 
    loaded from <code>.env</code> files or system environment.
  </p>

  <p><strong>omnisearch Requirements:</strong></p>
  <ul>
    <li><code>BRAVE_API_KEY</code> - API key for Brave Search</li>
    <li><code>FIRECRAWL_API_KEY</code> - API key for Firecrawl content extraction</li>
  </ul>

  <p><strong>filesystem and ide:</strong> No environment variables required (use system permissions)</p>

  <h3>18.7 Tool Catalog</h3>

  <h4>18.7.1 omnisearch Tools</h4>

  <table>
    <thead>
      <tr>
        <th>Tool</th>
        <th>Parameters</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>mcp__omnisearch__web_search</code></td>
        <td>
          - <code>query</code> (string, required)<br>
          - <code>provider</code> (tavily|brave|kagi|exa, required)<br>
          - <code>limit</code> (number, optional)<br>
          - <code>include_domains</code> (string[], optional)<br>
          - <code>exclude_domains</code> (string[], optional)
        </td>
        <td>
          Search the web using multiple providers. Tavily for factual/citations, 
          Brave for privacy/operators, Kagi for quality/operators, Exa for AI-semantic search.
        </td>
      </tr>
      <tr>
        <td><code>mcp__omnisearch__firecrawl_process</code></td>
        <td>
          - <code>url</code> (string | string[], required)<br>
          - <code>mode</code> (scrape|crawl|map|extract|actions, required)<br>
          - <code>extract_depth</code> (basic|advanced, optional)
        </td>
        <td>
          Extract web content using Firecrawl. Modes: scrape (single page), crawl (deep crawl), 
          map (URL discovery), extract (structured data), actions (interactive).
        </td>
      </tr>
    </tbody>
  </table>

  <h4>18.7.2 filesystem Tools</h4>

  <table>
    <thead>
      <tr>
        <th>Tool</th>
        <th>Parameters</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>mcp__filesystem__read_text_file</code></td>
        <td>
          - <code>path</code> (string, required)<br>
          - <code>head</code> (number, optional)<br>
          - <code>tail</code> (number, optional)
        </td>
        <td>Read complete file as text with encoding support. Optional head/tail for partial reads.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__read_media_file</code></td>
        <td>- <code>path</code> (string, required)</td>
        <td>Read image or audio file as base64 encoded data with MIME type.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__read_multiple_files</code></td>
        <td>- <code>paths</code> (string[], required)</td>
        <td>Read multiple files simultaneously. More efficient than sequential reads.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__write_file</code></td>
        <td>
          - <code>path</code> (string, required)<br>
          - <code>content</code> (string, required)
        </td>
        <td>Create new file or overwrite existing file. Use with caution.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__edit_file</code></td>
        <td>
          - <code>path</code> (string, required)<br>
          - <code>edits</code> (array, required)<br>
          - <code>dryRun</code> (boolean, optional)
        </td>
        <td>Make line-based edits. Returns git-style diff. Each edit: {oldText, newText}.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__create_directory</code></td>
        <td>- <code>path</code> (string, required)</td>
        <td>Create directory or nested directories. Succeeds silently if exists.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__list_directory</code></td>
        <td>- <code>path</code> (string, required)</td>
        <td>List files and directories with [FILE] and [DIR] prefixes.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__list_directory_with_sizes</code></td>
        <td>
          - <code>path</code> (string, required)<br>
          - <code>sortBy</code> (name|size, optional, default: name)
        </td>
        <td>List files and directories with size information. Sortable by name or size.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__directory_tree</code></td>
        <td>- <code>path</code> (string, required)</td>
        <td>Get recursive tree as JSON. Each entry: {name, type, children}.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__move_file</code></td>
        <td>
          - <code>source</code> (string, required)<br>
          - <code>destination</code> (string, required)
        </td>
        <td>Move or rename files/directories. Fails if destination exists.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__search_files</code></td>
        <td>
          - <code>path</code> (string, required)<br>
          - <code>pattern</code> (string, required)<br>
          - <code>excludePatterns</code> (string[], optional)
        </td>
        <td>Recursive pattern-based search. Case-insensitive, matches partial names.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__get_file_info</code></td>
        <td>- <code>path</code> (string, required)</td>
        <td>Get metadata: size, creation time, modified time, permissions, type.</td>
      </tr>
      <tr>
        <td><code>mcp__filesystem__list_allowed_directories</code></td>
        <td>(no parameters)</td>
        <td>List directories server is allowed to access. Subdirectories also accessible.</td>
      </tr>
    </tbody>
  </table>

  <h4>18.7.3 ide Tools</h4>

  <table>
    <thead>
      <tr>
        <th>Tool</th>
        <th>Parameters</th>
        <th>Purpose</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><code>mcp__ide__getDiagnostics</code></td>
        <td>- <code>uri</code> (string, optional)</td>
        <td>Get language diagnostics (errors, warnings) from VS Code. Optional URI filters to specific file.</td>
      </tr>
      <tr>
        <td><code>mcp__ide__executeCode</code></td>
        <td>- <code>code</code> (string, required)</td>
        <td>Execute Python code in Jupyter kernel. Code persists across calls unless kernel restarted.</td>
      </tr>
    </tbody>
  </table>

  <h3>18.8 Best Practices</h3>

  <h4>18.8.1 RAM Management</h4>

  <ul>
    <li>Check <code>/HAL-mcp-control status</code> at session start</li>
    <li>Enable omnisearch only when needed, disable immediately after</li>
    <li>Monitor RAM_ZONE when multiple MCP servers active</li>
    <li>Prefer native tools for simple operations (lower overhead)</li>
  </ul>

  <h4>18.8.2 Tool Selection</h4>

  <ul>
    <li>Use native <code>Read/Write/Edit</code> for single file operations</li>
    <li>Use MCP <code>read_multiple_files</code> for batch operations</li>
    <li>Use native <code>Grep</code> for content search (regex support)</li>
    <li>Use MCP <code>search_files</code> for filename pattern search</li>
    <li>Use MCP directory tools for structured output (JSON trees)</li>
  </ul>

  <h4>18.8.3 Error Handling</h4>

  <ul>
    <li>MCP tools return standardized JSON-RPC errors</li>
    <li>filesystem tools enforce allowed directory restrictions</li>
    <li>Check tool availability before invocation (server may be disabled)</li>
    <li>Handle permission errors gracefully (suggest re-enabling server)</li>
  </ul>

  <h4>18.8.4 Security</h4>

  <ul>
    <li>filesystem server operates within allowed directories only</li>
    <li>Never commit API keys (<code>.env</code> in .gitignore)</li>
    <li>Verify file paths before write operations</li>
    <li>Use <code>list_allowed_directories</code> to understand access scope</li>
  </ul>

  <h3>18.9 Troubleshooting</h3>

  <h4>18.9.1 Server Not Available</h4>

  <p><strong>Symptom:</strong> Tool invocation fails with "server not found" or "tool not available"</p>

  <p><strong>Diagnosis:</strong></p>
  <pre><code>/HAL-mcp-control status</code></pre>

  <p><strong>Solution:</strong></p>
  <pre><code>/HAL-mcp-control enable [server_name]</code></pre>

  <h4>18.9.2 Permission Denied (filesystem)</h4>

  <p><strong>Symptom:</strong> filesystem tool fails with permission error</p>

  <p><strong>Diagnosis:</strong></p>
  <pre><code>mcp__filesystem__list_allowed_directories</code></pre>

  <p><strong>Solution:</strong> Verify target path is within allowed directories. If needed, 
  update MCP configuration to allow access to required paths.</p>

  <h4>18.9.3 omnisearch API Errors</h4>

  <p><strong>Symptom:</strong> web_search or firecrawl_process fails with authentication error</p>

  <p><strong>Diagnosis:</strong> Check <code>.env</code> file exists and contains valid API keys</p>

  <p><strong>Solution:</strong></p>
  <ol>
    <li>Verify <code>.env</code> has <code>BRAVE_API_KEY</code> and <code>FIRECRAWL_API_KEY</code></li>
    <li>Ensure keys are valid (test on provider websites)</li>
    <li>Restart omnisearch server: <code>/HAL-mcp-control disable omnisearch</code> then <code>/HAL-mcp-control enable omnisearch</code></li>
  </ol>

  <h4>18.9.4 High RAM Usage</h4>

  <p><strong>Symptom:</strong> RAM_ZONE enters CAUTION or DANGER with MCP servers enabled</p>

  <p><strong>Solution:</strong></p>
  <pre><code>/HAL-mcp-control disable omnisearch  # High RAM cost server
# Continue with filesystem and ide only</code></pre>

  <p>omnisearch has the highest RAM cost. Disable when not actively researching.</p>

</section>

            <!-- Section 20: External Tools -->
            <section id="external-tools" data-status="complete" data-priority="2" data-sources=".claude/state.json:external_agents,.claude/tools/" data-estimated-tokens="10000" data-dependencies="">
                <h2>20. External Tools</h2>
                <div class="content">
                    <p>
                        HAL8000-Assistant integrates with external tools to extend capabilities beyond the core architecture. Following Unix philosophy, the system prefers host-installed tools over containerized alternatives for simplicity and direct access. External tools provide specialized functions: AI agents for massive context tasks, containers for isolated environments, and MCP servers for protocol-based integrations.
                    </p>

                    <h3>External AI Agents</h3>
                    <p>
                        HAL8000-Assistant leverages external AI agents when tasks exceed sub-agent capacity or require specialized capabilities.
                    </p>

                    <h4>Gemini CLI Integration</h4>
                    <ul>
                        <li><strong>Version:</strong> 0.4.1</li>
                        <li><strong>Context Window:</strong> 1,000,000 tokens (1M) - 5x larger than sub-agents</li>
                        <li><strong>Installation:</strong> Host-installed (preferred per Unix simplicity)</li>
                        <li><strong>Path:</strong> <code>/mnt/c/Users/Shahram-Dev/AppData/Roaming/npm/gemini</code></li>
                        <li><strong>Purpose:</strong> Ultra-large context tasks beyond 200K sub-agent capacity</li>
                        <li><strong>Invocation:</strong> Via bash <code>gemini</code> command</li>
                    </ul>

                    <p><strong>Usage Pattern:</strong></p>
                    <pre><code># Direct invocation for massive context tasks
gemini "Analyze this 500K token codebase for security vulnerabilities"

# Pipe input for processing
cat large-dataset.txt | gemini "Summarize key insights"</code></pre>

                    <div class="note">
                        <strong>When to Use Gemini vs Sub-Agents:</strong>
                        <ul>
                            <li><strong>Sub-agents (200K):</strong> Standard tasks, research synthesis, context discovery</li>
                            <li><strong>Gemini (1M):</strong> Massive codebases, extensive documentation analysis, multi-file refactoring requiring holistic view</li>
                        </ul>
                    </div>

                    <h3>Document Processing Tools</h3>
                    <p>
                        HAL8000-Assistant integrates document conversion tools to ingest knowledge from various file formats (PDF, Office documents, images, audio) into the knowledge base.
                    </p>

                    <h4>Docling CLI Integration</h4>
                    <ul>
                        <li><strong>Version:</strong> Latest (Python 3.13)</li>
                        <li><strong>Supported Formats:</strong> 15+ formats including PDF, DOCX, PPTX, XLSX, images, audio</li>
                        <li><strong>Installation:</strong> Host-installed via pip (Python package)</li>
                        <li><strong>Path:</strong> <code>C:\Users\Shahram-Dev\AppData\Local\Programs\Python\Python313\Scripts\docling.exe</code></li>
                        <li><strong>Purpose:</strong> Convert documents to Markdown/JSON/HTML for knowledge ingestion</li>
                        <li><strong>Invocation:</strong> Via PowerShell bridge from WSL</li>
                    </ul>

                    <p><strong>Key Features:</strong></p>
                    <ul>
                        <li><strong>Universal Conversion:</strong> PDF, DOCX, PPTX, images, audio ‚Üí Markdown/JSON/HTML</li>
                        <li><strong>OCR Support:</strong> Extract text from scanned documents and images (EasyOCR, RapidOCR, Tesseract)</li>
                        <li><strong>Audio Transcription:</strong> Convert audio/video to text (Whisper models)</li>
                        <li><strong>Table Extraction:</strong> Fast or accurate modes for preserving table structure</li>
                        <li><strong>Content Enrichment:</strong> Formula, code, and picture classification/description</li>
                        <li><strong>Image Handling:</strong> Placeholder, embedded (base64), or referenced modes</li>
                    </ul>

                    <p><strong>Usage Pattern:</strong></p>
                    <pre><code># Basic PDF to Markdown conversion
powershell.exe -Command "docling input.pdf --to md --output /output/dir"

# OCR for scanned documents
powershell.exe -Command "docling scanned.pdf --ocr --ocr-engine rapidocr --to md"

# Audio transcription
powershell.exe -Command "docling recording.mp3 --pipeline asr --asr-model whisper_small --to md"</code></pre>

                    <p><strong>Integration with HAL-knowledge-ingest:</strong></p>
                    <p>
                        The HAL-knowledge-ingest command (v1.1+) automatically detects document formats and invokes docling for conversion before ingestion. Users can directly ingest PDFs, Office documents, images, and audio files without manual conversion.
                    </p>

                    <pre><code># Automatic conversion and ingestion
/HAL-knowledge-ingest "/path/to/document.pdf"
/HAL-knowledge-ingest "/path/to/presentation.pptx"
/HAL-knowledge-ingest "/path/to/scanned-image.jpg"</code></pre>

                    <div class="note">
                        <strong>Zero RAM Impact:</strong> Docling runs in an external PowerShell process. Document conversion happens outside HAL8000-Assistant's context window - only the converted Markdown output is loaded into RAM. A 50-page PDF might consume 500KB on disk but only 10-20K tokens once converted to Markdown.
                    </div>

                    <p><strong>Supported Input Formats:</strong></p>
                    <table>
                        <thead>
                            <tr>
                                <th>Format Category</th>
                                <th>Extensions</th>
                                <th>Special Processing</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>PDF Documents</td>
                                <td><code>.pdf</code></td>
                                <td>Native text extraction + optional OCR</td>
                            </tr>
                            <tr>
                                <td>Office Documents</td>
                                <td><code>.docx</code>, <code>.pptx</code>, <code>.xlsx</code></td>
                                <td>Structure preservation, table extraction</td>
                            </tr>
                            <tr>
                                <td>Images</td>
                                <td><code>.png</code>, <code>.jpg</code>, <code>.jpeg</code>, <code>.gif</code>, <code>.bmp</code></td>
                                <td>OCR required for text extraction</td>
                            </tr>
                            <tr>
                                <td>Audio/Video</td>
                                <td><code>.mp3</code>, <code>.wav</code>, <code>.mp4</code>, <code>.avi</code></td>
                                <td>ASR (Whisper) transcription</td>
                            </tr>
                            <tr>
                                <td>Structured Data</td>
                                <td><code>.csv</code>, <code>.xml</code>, <code>.html</code></td>
                                <td>Format-specific parsing</td>
                            </tr>
                            <tr>
                                <td>Markup</td>
                                <td><code>.md</code>, <code>.asciidoc</code></td>
                                <td>Direct conversion</td>
                            </tr>
                        </tbody>
                    </table>

                    <p><strong>Tool Documentation:</strong></p>
                    <p>
                        Complete docling documentation is available at <code>.claude/tools/docling-cli.md</code>, including:
                    </p>
                    <ul>
                        <li>Comprehensive command reference (20+ options)</li>
                        <li>OCR engine selection guide</li>
                        <li>Performance optimization strategies</li>
                        <li>WSL path conversion patterns</li>
                        <li>Error handling and troubleshooting</li>
                        <li>Integration examples with HAL-knowledge-ingest</li>
                    </ul>

                    <h3>Container Infrastructure</h3>
                    <p>
                        HAL8000-Assistant has access to Docker for isolated execution environments, though host-installed tools are preferred per Unix simplicity.
                    </p>

                    <h4>Docker Environment</h4>
                    <ul>
                        <li><strong>Version:</strong> 28.4.0</li>
                        <li><strong>Containers Running:</strong> 5</li>
                        <li><strong>Images Available:</strong> 10</li>
                        <li><strong>Purpose:</strong> Isolated execution environments for tooling</li>
                    </ul>

                    <div class="note">
                        <strong>Design Philosophy:</strong> Host-installed tools are preferred over containers when possible. Containers are used only when isolation is required (conflicting dependencies, security boundaries, reproducible environments). This maintains Unix simplicity and reduces abstraction layers.
                    </div>

                    <h3>MCP Servers</h3>
                    <p>
                        HAL8000-Assistant uses MCP (Model Context Protocol) servers to access specialized capabilities through a standardized protocol. MCP servers are selectively enabled to optimize RAM usage.
                    </p>

                    <h4>MCP Infrastructure Status</h4>
                    <ul>
                        <li><strong>Total Configured:</strong> 5 servers</li>
                        <li><strong>Currently Enabled:</strong> 2 servers</li>
                        <li><strong>Connected:</strong> 2 servers</li>
                    </ul>

                    <h4>Available MCP Servers</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Server</th>
                                <th>Status</th>
                                <th>Purpose</th>
                                <th>Capabilities</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>omnisearch</strong></td>
                                <td>Enabled</td>
                                <td>Enhanced web search and content extraction</td>
                                <td>Brave Search API, Firecrawl API for web scraping</td>
                            </tr>
                            <tr>
                                <td><strong>filesystem</strong></td>
                                <td>Enabled</td>
                                <td>Direct file system operations</td>
                                <td>Read, write, edit, search, directory operations</td>
                            </tr>
                            <tr>
                                <td><strong>ide</strong></td>
                                <td>Configured</td>
                                <td>VS Code integration</td>
                                <td>Diagnostics, code execution, language server protocol</td>
                            </tr>
                            <tr>
                                <td><strong>replicate</strong></td>
                                <td>Configured</td>
                                <td>Replicate API integration</td>
                                <td>ML model execution via Replicate platform</td>
                            </tr>
                            <tr>
                                <td><strong>context7</strong></td>
                                <td>Configured</td>
                                <td>Context management</td>
                                <td>Advanced context operations</td>
                            </tr>
                        </tbody>
                    </table>

                    <h4>MCP Server Details</h4>

                    <p><strong>omnisearch:</strong></p>
                    <ul>
                        <li>Configuration: <code>.env</code> with API keys</li>
                        <li>Launch script: <code>run-omnisearch.sh</code></li>
                        <li>Tools: <code>mcp__omnisearch__web_search</code>, <code>mcp__omnisearch__firecrawl_process</code></li>
                        <li>Use case: Research tasks, web content extraction, search result synthesis</li>
                    </ul>

                    <p><strong>filesystem:</strong></p>
                    <ul>
                        <li>Direct file system access within allowed directories</li>
                        <li>Tools: <code>mcp__filesystem__read_text_file</code>, <code>mcp__filesystem__write_file</code>, <code>mcp__filesystem__edit_file</code>, <code>mcp__filesystem__search_files</code>, etc.</li>
                        <li>Use case: File I/O operations, directory traversal, batch file operations</li>
                    </ul>

                    <p><strong>ide:</strong></p>
                    <ul>
                        <li>VS Code integration for development workflows</li>
                        <li>Tools: <code>mcp__ide__getDiagnostics</code>, <code>mcp__ide__executeCode</code></li>
                        <li>Use case: Language diagnostics, code execution in Jupyter kernels</li>
                    </ul>

                    <h3>MCP Server Management</h3>
                    <p>
                        MCP servers are dynamically managed to optimize RAM usage. Only required servers are enabled during a session.
                    </p>

                    <h4>HAL-mcp-control Command</h4>
                    <p>
                        The <code>HAL-mcp-control</code> command provides dynamic MCP server management.
                    </p>

                    <p><strong>Operations:</strong></p>
                    <pre><code># Check status of all MCP servers
/HAL-mcp-control status

# Enable a specific server
/HAL-mcp-control enable omnisearch

# Disable a specific server
/HAL-mcp-control disable replicate</code></pre>

                    <p><strong>Usage Pattern:</strong></p>
                    <ul>
                        <li><strong>Selective Loading:</strong> Enable only servers needed for current task</li>
                        <li><strong>RAM Optimization:</strong> Each enabled server consumes token overhead - disable unused servers</li>
                        <li><strong>Dynamic Control:</strong> Enable/disable mid-session as needs change</li>
                    </ul>

                    <div class="note">
                        <strong>Best Practice:</strong> Start sessions with minimal MCP servers enabled. Enable additional servers on-demand when specific capabilities are needed. This follows the selective loading principle and minimizes RAM overhead.
                    </div>

                    <h4>MCP Server Selection Guidelines</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Task Type</th>
                                <th>Enable</th>
                                <th>Rationale</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Web research</td>
                                <td>omnisearch</td>
                                <td>Enhanced search and content extraction</td>
                            </tr>
                            <tr>
                                <td>File operations</td>
                                <td>filesystem</td>
                                <td>Direct file system access (alternative to core tools)</td>
                            </tr>
                            <tr>
                                <td>Code diagnostics</td>
                                <td>ide</td>
                                <td>Language server integration</td>
                            </tr>
                            <tr>
                                <td>ML model execution</td>
                                <td>replicate</td>
                                <td>Access to Replicate model library</td>
                            </tr>
                            <tr>
                                <td>Standard operations</td>
                                <td>None</td>
                                <td>Use core tools (Read, Write, Edit, Grep, Glob, Bash)</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>AI Image Generation Tool</h3>
                    <p>
                        HAL8000-Assistant integrates AI-powered image generation through a Dockerized Stable Diffusion system. This tool enables on-demand creation of high-quality images using local GPU acceleration, maintaining zero RAM impact on HAL8000-Assistant sessions.
                    </p>

                    <h4>Image Generation System Overview</h4>
                    <ul>
                        <li><strong>Version:</strong> 1.0.0</li>
                        <li><strong>Backend:</strong> ComfyUI + Stable Diffusion (SDXL, SD1.5)</li>
                        <li><strong>Architecture:</strong> Docker container with NVIDIA GPU passthrough</li>
                        <li><strong>Location:</strong> <code>.claude/tools/image-generation/</code></li>
                        <li><strong>GPU:</strong> RTX 3090 (24GB VRAM) - local acceleration</li>
                        <li><strong>Pattern:</strong> Mirrors diagram-generation tool (proven architecture)</li>
                    </ul>

                    <p><strong>Key Features:</strong></p>
                    <ul>
                        <li><strong>Dockerized Execution:</strong> Complete isolation, no host pollution</li>
                        <li><strong>GPU-Accelerated:</strong> Local RTX 3090 for fast generation (3-8 seconds per image)</li>
                        <li><strong>Multiple Models:</strong> SDXL (best quality), SD1.5 (faster)</li>
                        <li><strong>Model Caching:</strong> Download once (~6.5GB), reuse forever</li>
                        <li><strong>Zero RAM Impact:</strong> External execution, only file path returned to HAL8000-Assistant</li>
                        <li><strong>Cost-Effective:</strong> $0 per image after setup (vs. $0.04+ cloud services)</li>
                    </ul>

                    <h4>Usage Pattern</h4>
                    <p><strong>Basic Image Generation:</strong></p>
                    <pre><code># Standard quality (SDXL, default)
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "futuristic computer CPU with glowing circuits, cyberpunk style" \
  --output data/images/cpu.png

# Fast generation (SD1.5)
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "simple robot sketch" \
  --model sd15 \
  --steps 15 \
  --output data/images/robot.png

# High quality (more steps)
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "detailed architectural visualization" \
  --model sdxl \
  --steps 40 \
  --output data/images/architecture.png


                    <p><strong>HAL8000-Assistant Integration:</strong></p>
                    <p>
                        When users request images, HAL8000-Assistant (Claude) automatically enhances prompts and invokes the tool. Users don't interact with the tool directly - they simply ask for images and Claude generates them.
                    </p>

                    <pre><code>User: "Generate an image of a friendly robot"

Claude executes:
  python3 .claude/tools/image-generation/HAL-generate-image.py \
    --prompt "friendly humanoid robot assistant, modern design, clean background, detailed" \
    --model sdxl \
    --steps 25 \
    --output data/images/robot-assistant.png

User receives: "Image generated: data/images/robot-assistant.png"</code></pre>

                    <h4>Text Overlay Feature</h4>
                    <p>
                        SD models cannot generate readable text (they produce gibberish). Use the <code>--text</code> parameter to overlay clean text with ImageMagick post-processing:
                    </p>

                    <pre><code># Simple text overlay (bottom center by default)
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "solid blue background" \
  --text "HELLO WORLD" \
  --output labeled-image.png

# Custom text positioning and styling
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "cyberpunk city at night" \
  --text "NEO TOKYO 2077" \
  --text-position north \
  --text-size 96 \
  --text-color white \
  --output cyberpunk-titled.png

# Hex color support
python3 .claude/tools/image-generation/HAL-generate-image.py \
  --prompt "robot assistant" \
  --text "HAL8000-Assistant" \
  --text-position center \
  --text-size 120 \
  --text-color "#00FF00" \
  --output robot-labeled.png</code></pre>

                    <p><strong>Text Options:</strong></p>
                    <ul>
                        <li><code>--text</code>: Text to overlay on image</li>
                        <li><code>--text-position</code>: north, south (default), east, west, center</li>
                        <li><code>--text-size</code>: Font size in points (default: 72)</li>
                        <li><code>--text-color</code>: Color name (white, black, red, blue) or hex (#RRGGBB)</li>
                    </ul>
                    <p><strong>Note:</strong> Text is rendered with black stroke outline for readability on any background color.</p>

                    <h4>Available Models</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Model</th>
                                <th>Size</th>
                                <th>VRAM</th>
                                <th>Speed (RTX 3090)</th>
                                <th>Quality</th>
                                <th>Best For</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>SDXL</strong> (default)</td>
                                <td>6.5GB</td>
                                <td>6-8GB</td>
                                <td>3-5 seconds</td>
                                <td>‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ</td>
                                <td>Production quality, high detail</td>
                            </tr>
                            <tr>
                                <td><strong>SD1.5</strong></td>
                                <td>4GB</td>
                                <td>4-5GB</td>
                                <td>1-2 seconds</td>
                                <td>‚òÖ‚òÖ‚òÖ‚òÖ</td>
                                <td>Fast iterations, prototyping</td>
                            </tr>
                            <tr>
                        </tbody>
                    </table>


                    <h4>Performance Characteristics</h4>
                    <p><strong>First-Time Setup:</strong></p>
                    <ul>
                        <li>Docker image build: ~5-10 minutes (one-time)</li>
                        <li>Model download: ~5-10 minutes per model (one-time)</li>
                        <li>Total initial setup: ~15-20 minutes</li>
                    </ul>

                    <p><strong>Runtime Performance (RTX 3090):</strong></p>
                    <ul>
                        <li>Container startup: ~2 seconds</li>
                        <li>Model load (from cache): ~3-5 seconds</li>
                        <li>Image generation: ~3-8 seconds (depending on model/steps)</li>
                        <li>Container cleanup: ~1 second</li>
                        <li><strong>Total:</strong> ~10-15 seconds per image (after initial setup)</li>
                    </ul>

                    <h4>Storage Requirements</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Component</th>
                                <th>Location</th>
                                <th>Size</th>
                                <th>Purpose</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Docker Image</td>
                                <td>C: drive (WSL2)</td>
                                <td>~3GB</td>
                                <td>Container with ComfyUI + dependencies</td>
                            </tr>
                            <tr>
                                <td>Model Cache</td>
                                <td>D: drive (<code>.docker-cache/models/</code>)</td>
                                <td>~6.5GB (SDXL) + 4GB (SD1.5)</td>
                                <td>AI model weights (persistent)</td>
                            </tr>
                            <tr>
                                <td>Generated Images</td>
                                <td>D: drive (<code>data/images/</code>)</td>
                                <td>~2-5MB each</td>
                                <td>Output images</td>
                            </tr>
                        </tbody>
                    </table>

                    <div class="note">
                        <strong>Hybrid Storage Strategy:</strong> Docker images on C: drive (~3GB), model weights and outputs on D: drive (~10-20GB). This optimizes space usage across drives while maintaining fast access via SSD caching.
                    </div>

                    <h4>Architecture Pattern</h4>
                    <p><strong>Docker-Based I/O Device:</strong></p>
                    <pre><code>User Request
    ‚Üì
HAL8000-Assistant (Claude/CPU) - enhances prompt
    ‚Üì
HAL-generate-image.py - driver script
    ‚Üì
docker run hal8000-image-gen:latest --prompt "..." --output image.png
    ‚Üì
Container: Start ‚Üí Load Model ‚Üí Generate ‚Üí Save ‚Üí Exit
    ‚Üì
Image saved to data/images/
    ‚Üì
HAL8000-Assistant returns file path to user (~10 tokens RAM impact)</code></pre>

                    <div class="note">
                        <strong>Zero RAM Impact:</strong> Like the diagram-generation tool, image generation runs in an external Docker container. Only the output file path is loaded into HAL8000-Assistant's RAM (~10 tokens), not the generation process or intermediate data. This enables unlimited image generation without RAM constraints.
                    </div>

                    <h4>Installation and Setup</h4>
                    <p><strong>Prerequisites:</strong></p>
                    <ul>
                        <li>Docker Desktop with WSL2 backend</li>
                        <li>NVIDIA GPU drivers</li>
                        <li>NVIDIA Container Toolkit (for GPU passthrough)</li>
                        <li>~10GB free disk space (3GB C:, 7GB D:)</li>
                    </ul>

                    <p><strong>Build Process:</strong></p>
                    <pre><code># Navigate to tool directory
cd /mnt/d/~HAL8000-Assistant/.claude/tools/image-generation

# Build Docker image
./build-image.sh

# Test installation
python3 HAL-generate-image.py \
  --prompt "test: red circle" \
  --model sd15 \
  --output test.png</code></pre>

                    <p><strong>Documentation Files:</strong></p>
                    <ul>
                        <li><code>README.md</code> - Complete user guide with examples</li>
                        <li><code>INSTALL.md</code> - Detailed installation and troubleshooting</li>
                        <li><code>QUICKSTART.txt</code> - Quick reference card</li>
                        <li><code>CLAUDE.md</code> - HAL8000-Assistant integration guide</li>
                        <li><code>image-generation-tool.md</code> - System documentation</li>
                    </ul>

                    <h4>Use Cases</h4>
                    <p><strong>Typical Applications:</strong></p>
                    <ul>
                        <li><strong>Technical Illustrations:</strong> Hardware diagrams, system architectures, component visualizations</li>
                        <li><strong>Concept Art:</strong> Design mockups, visual prototypes, creative explorations</li>
                        <li><strong>Character Design:</strong> Robot assistants, AI entities, user avatars</li>
                        <li><strong>Architectural Visualization:</strong> Building designs, interior layouts, spatial concepts</li>
                        <li><strong>Abstract Art:</strong> Patterns, textures, stylistic explorations</li>
                        <li><strong>Product Mockups:</strong> Device concepts, interface designs, packaging ideas</li>
                    </ul>

                    <div class="note">
                        <strong>Cost Comparison:</strong> Cloud services (DALL-E 3, Midjourney) charge $0.04-0.08 per image. With local generation, after initial setup (~$0 for existing GPU hardware), each image costs only electricity (~$0.001). At 100 images/month, savings are ~$4-8/month. At 1000 images/month, savings are ~$40-80/month.
                    </div>

                    <h4>Comparison to Other Tools</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Tool</th>
                                <th>Type</th>
                                <th>RAM Impact</th>
                                <th>Speed</th>
                                <th>Use Case</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>image-generation</strong></td>
                                <td>Docker (GPU)</td>
                                <td>Zero</td>
                                <td>10-15s</td>
                                <td>AI image creation</td>
                            </tr>
                            <tr>
                                <td><strong>diagram-generation</strong></td>
                                <td>Docker</td>
                                <td>Zero</td>
                                <td>&lt;1s</td>
                                <td>Technical diagrams (Mermaid)</td>
                            </tr>
                            <tr>
                                <td><strong>docling-cli</strong></td>
                                <td>PowerShell</td>
                                <td>Zero</td>
                                <td>Variable</td>
                                <td>Document processing</td>
                            </tr>
                            <tr>
                                <td><strong>gemini-cli</strong></td>
                                <td>CLI</td>
                                <td>Zero</td>
                                <td>Variable</td>
                                <td>Massive context analysis</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3>Integration Patterns</h3>

                    <h4>External Tool Selection Decision Tree</h4>
                    <pre><code>Task requires specialized capability?
‚îú‚îÄ NO ‚Üí Use core tools (Read, Write, Bash, etc.)
‚îî‚îÄ YES ‚Üí Specialized capability type?
    ‚îú‚îÄ Massive context (>200K) ‚Üí Gemini CLI
    ‚îú‚îÄ Document conversion ‚Üí Docling CLI
    ‚îú‚îÄ AI image generation ‚Üí Image Generation Tool
    ‚îú‚îÄ Technical diagrams ‚Üí Diagram Generation Tool
    ‚îú‚îÄ Web search/extraction ‚Üí MCP omnisearch
    ‚îú‚îÄ File system operations ‚Üí MCP filesystem or core tools
    ‚îú‚îÄ Code diagnostics ‚Üí MCP ide
    ‚îú‚îÄ ML model execution ‚Üí MCP replicate
    ‚îî‚îÄ Isolation required ‚Üí Docker container</code></pre>

                    <h4>RAM Impact Considerations</h4>
                    <ul>
                        <li><strong>Core Tools:</strong> Minimal overhead (built-in)</li>
                        <li><strong>MCP Servers:</strong> Token overhead per enabled server (~1-5K tokens each)</li>
                        <li><strong>External AI (Gemini):</strong> No RAM impact (separate process, returns results only)</li>
                        <li><strong>Document Conversion (Docling):</strong> No RAM impact (external PowerShell process, only converted output loaded)</li>
                        <li><strong>Image Generation:</strong> No RAM impact (Docker container, only file path returned ~10 tokens)</li>
                        <li><strong>Diagram Generation:</strong> No RAM impact (Docker container, only file path returned)</li>
                        <li><strong>Docker Containers:</strong> No RAM impact (isolated container, communicate via I/O)</li>
                    </ul>

                    <div class="note">
                        <strong>Architecture Note:</strong> External tools extend HAL8000-Assistant's capabilities without violating core architectural constraints. Gemini provides virtual memory beyond 200K limits. Docling enables universal document ingestion. Image Generation creates AI visuals with GPU acceleration. Diagram Generation produces technical diagrams. MCP servers offer protocol-based integrations. Docker provides process isolation. All follow Unix philosophy: specialized tools composed via standard interfaces (bash, file I/O, PowerShell bridge, MCP protocol, Docker containers).
                    </div>

                    <h3>Cross-Reference</h3>
                    <ul>
                        <li><strong>Commands:</strong> See <a href="#hal-mcp-control">HAL-mcp-control</a> for MCP server management, <a href="#hal-knowledge-ingest">HAL-knowledge-ingest</a> for automatic document ingestion</li>
                        <li><strong>Tool Documentation:</strong>
                            <ul>
                                <li><code>.claude/tools/image-generation/</code> - AI image generation (README.md, INSTALL.md, CLAUDE.md)</li>
                                <li><code>.claude/tools/diagram-generation/</code> - Technical diagram generation</li>
                                <li><code>.claude/tools/docling-cli.md</code> - Document processing</li>
                                <li><code>.claude/tools/gemini-cli.md</code> - Massive context AI agent</li>
                                <li><code>.claude/tools/image-generation-tool.md</code> - Image tool system documentation</li>
                            </ul>
                        </li>
                        <li><strong>Sub-Agents:</strong> See <a href="#sub-agents">5.4 Sub-Agents</a> for comparison with external AI agents</li>
                        <li><strong>Core Tools:</strong> See <a href="#core-tools">5.1 Core Tools</a> for built-in capabilities</li>
                        <li><strong>Resource Management:</strong> See <a href="#ram-management">4.3 RAM Management</a> for optimization guidelines</li>
                    </ul>
                </div>
            </section>

            <!-- Part V: Development & Extension -->
            <div class="part-divider">
                <h1 class="part-header">Part V: Development</h1>
                <p class="part-description">Creating commands, building agents, library system, and contributing</p>
            </div>

            <!-- Section 21: Creating Commands -->
<section id="creating-commands">
    <h2>20. Creating Custom Commands</h2>
    <div class="content">

        <p>HAL8000-Assistant commands are executable instructions stored as Markdown files that the CPU (Claude) fetches, decodes, and executes. Creating custom commands extends the system's capabilities while maintaining architectural integrity.</p>

        <div class="callout callout-info">
            <strong>Command Philosophy:</strong> Commands follow the Unix principle of "do one thing well." Each command implements a single, well-defined operation that can be composed with other commands to create complex workflows.
        </div>

        <h3>20.1 Command Anatomy</h3>

        <p>HAL commands consist of several key components that enable the CPU to understand and execute them correctly.</p>

        <h4>File Location and Naming</h4>
        <ul>
            <li><strong>Location:</strong> <code>.claude/commands/</code></li>
            <li><strong>Naming convention:</strong> <code>HAL-commandname.md</code> (kebab-case)</li>
            <li><strong>Format:</strong> Markdown (.md)</li>
            <li><strong>Invocation:</strong> <code>/HAL-commandname</code></li>
        </ul>

        <div class="example">
            <strong>Example file names:</strong>
            <pre>
.claude/commands/HAL-session-end.md    ‚Üí /HAL-session-end
.claude/commands/HAL-register-dump.md  ‚Üí /HAL-register-dump
.claude/commands/HAL-system-check.md   ‚Üí /HAL-system-check
.claude/commands/HAL-hello-world.md    ‚Üí /HAL-hello-world</pre>
        </div>

        <h4>File Structure</h4>
        <p>Command files use a consistent structure that provides both human documentation and CPU execution instructions:</p>

        <ol>
            <li><strong>Frontmatter:</strong> YAML metadata block (optional but recommended)</li>
            <li><strong>Title and Description:</strong> Clear explanation of command purpose</li>
            <li><strong>Usage Section:</strong> Invocation syntax and parameters</li>
            <li><strong>Implementation Section:</strong> Step-by-step CPU instructions</li>
            <li><strong>Example Section:</strong> Concrete usage examples</li>
            <li><strong>Architecture Notes:</strong> How command aligns with HAL8000-Assistant principles</li>
        </ol>

        <h4>Invocation Methods</h4>
        <p>Commands can be invoked in two ways:</p>
        <ul>
            <li><strong>Direct slash command:</strong> User types <code>/HAL-commandname</code> in chat</li>
            <li><strong>SlashCommand tool:</strong> CPU or other commands use the SlashCommand tool programmatically</li>
        </ul>

        <h3>20.2 Basic Command Template</h3>

        <p>Here's a minimal template for creating new commands:</p>

        <div class="code-block">
<pre>---
name: HAL-commandname
description: Brief description of what this command does
---

# HAL Command Name

**Command Type:** [Utility | Maintenance | System | Development]
**Category:** [Categorization]
**Purpose:** Clear one-sentence purpose statement

---

## Purpose

Detailed explanation of what this command accomplishes and why it exists.

## Usage

```bash
/HAL-commandname [arg1] [arg2]
```

**Arguments:**
- `arg1` (required/optional): Description of first argument
- `arg2` (required/optional): Description of second argument

## Execution Logic

When `/HAL-commandname` is invoked, the CPU will:

1. **Step One:** First action to perform
   - Detail about step one
   - What to check or validate

2. **Step Two:** Second action to perform
   - Detail about step two
   - Expected outcomes

3. **Step Three:** Final action
   - What to display or return
   - Success criteria

## Expected Output

Description or example of what the command produces:

```
Example output format
```

## Example Execution

```bash
/HAL-commandname example-arg
```

**Result:**
```
Example of actual command output
```

## Architecture Alignment

How this command implements HAL8000-Assistant principles:

**Von Neumann:**
- Principle alignment notes

**Unix Philosophy:**
- Principle alignment notes

**Assembly Principles:**
- Principle alignment notes

## Related Components

- **Related file 1:** Description
- **Related file 2:** Description

## Notes

- Important usage notes
- Warnings or caveats
- When to use vs. when not to use</pre>
        </div>

<section id="section-20-4">
    <h3>20.4 Using Prompt Templates</h3>

    <p>HAL8000-Assistant provides a comprehensive library of <strong>prompt templates</strong> that accelerate command creation through composable, reusable patterns. Rather than writing commands from scratch, you can start with a proven template and customize it for your specific needs.</p>

    <h4>The Lego Block Principle</h4>

    <p>Templates follow the <strong>"Lego Block"</strong> principle: each section of a template (Purpose, Usage, Instructions, etc.) is a reusable building block that can be included or omitted based on your requirements.</p>

    <div class="callout callout-info">
        <strong>Core Concept:</strong> Start with a template, remove unused sections, fill in your logic. Templates are guides, not constraints.
    </div>

    <p><strong>The workflow:</strong></p>
    <ol>
        <li>Choose a template that matches your needs</li>
        <li>Copy the template to your command file location</li>
        <li>Remove sections you don't need</li>
        <li>Fill in your specific logic</li>
        <li>Save to appropriate <code>.claude/commands/</code> subdirectory</li>
    </ol>

    <h4>The 7 Levels Framework</h4>

    <p>HAL8000-Assistant's template system is inspired by <strong>IndyDevDan's "7 Levels of Agentic Prompt Formats"</strong> and adapted for HAL-Script. Each level represents increasing complexity:</p>

    <figure class="diagram" data-diagram-id="template-levels-pyramid">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600" width="800" height="600">
  <defs>
    <style>
      .level-text { font-family: Arial, sans-serif; font-size: 14px; font-weight: bold; fill: #333; text-anchor: middle; }
      .level-desc { font-family: Arial, sans-serif; font-size: 11px; fill: #666; text-anchor: middle; }
      .level-box { stroke: #333; stroke-width: 2; }
    </style>
  </defs>

  <!-- Title -->
  <text x="400" y="30" style="font-size: 20px; font-weight: bold; text-anchor: middle; fill: #2c3e50;">7 Levels of Command Complexity</text>

  <!-- Level 7 - System (Top - smallest) -->
  <polygon points="350,80 450,80 480,140 320,140" class="level-box" fill="#FFEBEE"/>
  <text x="400" y="105" class="level-text">Level 7: System</text>
  <text x="400" y="125" class="level-desc">Production-critical</text>

  <!-- Level 6 - Workflow Composition -->
  <polygon points="310,145 490,145 530,215 270,215" class="level-box" fill="#E1BEE7"/>
  <text x="400" y="170" class="level-text">Level 6: Workflow Composition</text>
  <text x="400" y="190" class="level-desc">Command composition</text>

  <!-- Level 5 - Supervisor -->
  <polygon points="260,220 540,220 590,300 210,300" class="level-box" fill="#F8BBD0"/>
  <text x="400" y="250" class="level-text">Level 5: Supervisor</text>
  <text x="400" y="270" class="level-desc">Multi-agent coordination</text>

  <!-- Level 4 - Delegate -->
  <polygon points="200,305 600,305 660,395 140,395" class="level-box" fill="#FFCCBC"/>
  <text x="400" y="340" class="level-text">Level 4: Delegate</text>
  <text x="400" y="360" class="level-desc">Sub-agent invocation</text>

  <!-- Level 3 - Control Flow -->
  <polygon points="130,400 670,400 740,500 60,500" class="level-box" fill="#FFE0B2"/>
  <text x="400" y="440" class="level-text">Level 3: Control Flow</text>
  <text x="400" y="460" class="level-desc">Conditionals & loops</text>

  <!-- Level 2 - Workflow -->
  <polygon points="50,505 750,505 780,560 20,560" class="level-box" fill="#FFF9C4"/>
  <text x="400" y="527" class="level-text">Level 2: Workflow</text>
  <text x="400" y="545" class="level-desc">Multi-step with parameters</text>

  <!-- Level 1 - Basic (Bottom - largest) -->
  <polygon points="10,565 790,565 800,595 0,595" class="level-box" fill="#E8F5E9"/>
  <text x="400" y="582" class="level-text">Level 1: Basic - Simple single-step operations</text>

  <!-- Complexity Arrow -->
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
      <polygon points="0 0, 10 3, 0 6" fill="#e74c3c" />
    </marker>
  </defs>
  <line x1="750" y1="570" x2="750" y2="100" stroke="#e74c3c" stroke-width="3" marker-end="url(#arrowhead)"/>
  <text x="765" y="335" style="font-size: 16px; font-weight: bold; fill: #e74c3c; writing-mode: tb;">Increasing Complexity</text>
</svg>
        <figcaption>The 7 Levels of command complexity, from simple operations to system infrastructure</figcaption>
    </figure>

    <div class="level-cards">
        <div class="level-card" style="border-left: 4px solid #4CAF50;">
            <div class="level-header" style="background: #E8F5E9;">
                <span class="level-number">1</span>
                <span class="level-title">Basic</span>
                <span class="level-badge" style="background: #4CAF50;">Minimal</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Simple, single-step operations with no parameters. Minimal error handling.</p>
                <p><strong>Examples:</strong> Display status, show version.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #CDDC39;">
            <div class="level-header" style="background: #FFF9C4;">
                <span class="level-number">2</span>
                <span class="level-title">Workflow</span>
                <span class="level-badge" style="background: #CDDC39;">Low-Medium</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Multi-step sequential processes with input parameters and structured output.</p>
                <p><strong>Examples:</strong> Process files, generate reports.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #FF9800;">
            <div class="level-header" style="background: #FFE0B2;">
                <span class="level-number">3</span>
                <span class="level-title">Control Flow</span>
                <span class="level-badge" style="background: #FF9800;">Medium</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Commands with conditionals, loops, and branching logic.</p>
                <p><strong>Examples:</strong> Validate and fix errors, iterate until condition met.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #FF5722;">
            <div class="level-header" style="background: #FFCCBC;">
                <span class="level-number">4</span>
                <span class="level-title">Delegate</span>
                <span class="level-badge" style="background: #FF5722;">Medium-High</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Commands that invoke sub-agents for specialized processing.</p>
                <p><strong>Examples:</strong> Research synthesis, context discovery.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #E91E63;">
            <div class="level-header" style="background: #F8BBD0;">
                <span class="level-number">5</span>
                <span class="level-title">Supervisor</span>
                <span class="level-badge" style="background: #E91E63; color: white;">High</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Multi-agent coordination with parallel execution and result integration.</p>
                <p><strong>Examples:</strong> Parallel research, multi-phase validation.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #9C27B0;">
            <div class="level-header" style="background: #E1BEE7;">
                <span class="level-number">6</span>
                <span class="level-title">Workflow Composition</span>
                <span class="level-badge" style="background: #9C27B0; color: white;">High</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Composition of multiple commands into end-to-end workflows.</p>
                <p><strong>Examples:</strong> Complete analysis pipelines, release processes.</p>
            </div>
        </div>

        <div class="level-card" style="border-left: 4px solid #F44336;">
            <div class="level-header" style="background: #FFEBEE;">
                <span class="level-number">7</span>
                <span class="level-title">System</span>
                <span class="level-badge" style="background: #F44336; color: white;">Maximum</span>
            </div>
            <div class="level-content">
                <p><strong>Purpose:</strong> Production-critical system infrastructure with comprehensive documentation and testing.</p>
                <p><strong>Examples:</strong> HAL-session-end, HAL-system-check.</p>
            </div>
        </div>
    </div>

    <style>
        .level-cards {
            display: grid;
            gap: 16px;
            margin: 20px 0;
        }
        .level-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .level-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .level-header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .level-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            font-weight: bold;
            font-size: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .level-title {
            font-weight: bold;
            font-size: 18px;
            flex: 1;
        }
        .level-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        .level-content {
            padding: 16px;
            background: #fafafa;
        }
        .level-content p {
            margin: 8px 0;
            line-height: 1.6;
        }
        .level-content strong {
            color: #2c3e50;
        }
    </style>

    <h4>Template Selection Guide</h4>

    <p>Use this quick reference to choose the appropriate template:</p>

    <table>
        <thead>
            <tr>
                <th>Your Need</th>
                <th>Level</th>
                <th>Template File</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Simple task, no inputs</td>
                <td>1</td>
                <td><code>level-1-basic.md</code></td>
            </tr>
            <tr>
                <td>Multi-step with parameters</td>
                <td>2</td>
                <td><code>level-2-workflow.md</code></td>
            </tr>
            <tr>
                <td>Conditionals or loops</td>
                <td>3</td>
                <td><code>level-3-control-flow.md</code></td>
            </tr>
            <tr>
                <td>Delegate to sub-agent</td>
                <td>4</td>
                <td><code>level-4-delegate.md</code></td>
            </tr>
            <tr>
                <td>Multiple agents</td>
                <td>5</td>
                <td><code>level-5-supervisor.md</code></td>
            </tr>
            <tr>
                <td>Compose commands</td>
                <td>6</td>
                <td><code>level-6-workflow-composition.md</code></td>
            </tr>
            <tr>
                <td>Core system component</td>
                <td>7</td>
                <td><code>level-7-system.md</code></td>
            </tr>
            <tr>
                <td>Custom/unsure</td>
                <td>Master</td>
                <td><code>master-prompt-template.md</code></td>
            </tr>
        </tbody>
    </table>

    <h4>Master Template</h4>

    <p>The <code>master-prompt-template.md</code> shows <strong>all possible sections</strong> - a complete catalog of Lego blocks. Use it when building complex custom commands or when you need a comprehensive reference.</p>

    <div class="callout callout-tip">
        <strong>Pro Tip:</strong> Start with Level 1-2 templates for most commands. Only add complexity when actually needed. Don't include sections "just in case."
    </div>

    <h4>Example: Creating a Command from Template</h4>

    <p>Let's create a command that searches the codebase and generates a report:</p>

    <pre><code class="language-bash"># Step 1: Choose template (multi-step with parameters = Level 2)
cp .claude/libraries/internal/templates/level-2-workflow.md \\
   .claude/commands/development/HAL-search-report.md

# Step 2: Open and edit the file
# - Keep: Purpose, Usage, Variables, Instructions, Output Format
# - Remove: Sections you don't need
# - Fill in: Your specific search and report logic

# Step 3: Result is a well-structured, consistent command
</code></pre>

    <h4>Benefits of Template-Based Development</h4>

    <ul>
        <li><strong>Faster creation:</strong> Start with proven structure instead of blank file</li>
        <li><strong>Consistency:</strong> All commands follow same organizational pattern</li>
        <li><strong>Completeness:</strong> Templates remind you of important sections (error handling, examples)</li>
        <li><strong>Best practices:</strong> Built-in patterns from existing system commands</li>
        <li><strong>Maintainability:</strong> Familiar structure makes commands easier to update</li>
    </ul>

    <p><strong>References:</strong></p>
    <ul>
        <li>Template files: <code>.claude/libraries/internal/templates/</code></li>
        <li>Complete guide: <code>template-guide.md</code></li>
        <li>Framework credit: IndyDevDan's "7 Levels of Agentic Prompt Formats"</li>
    </ul>
</section>

<!-- ============================================ -->

<section id="section-20-5">
    <h3>20.5 YAML Frontmatter for Commands</h3>

    <p><strong>YAML frontmatter</strong> is a Claude Code feature that enhances command discoverability and user experience. Added to commands in HAL8000-Assistant v1.2.0, frontmatter provides metadata that integrates with Claude Code's command palette and parameter system.</p>

    <h4>What is YAML Frontmatter?</h4>

    <p>YAML frontmatter appears at the beginning of command files, enclosed in <code>---</code> markers:</p>

    <pre><code class="language-yaml">---
name: command-name
description: Brief description for command palette
parameters:
  - name: param1
    description: What this parameter does
    type: string
    required: true
---

# Command Title

Command content follows...
</code></pre>

    <div class="callout callout-info">
        <strong>Important:</strong> Frontmatter is <em>optional</em> but highly beneficial. Commands work without it, but users experience better discoverability and guidance with it.
    </div>

    <h4>Required Fields for Commands</h4>

    <dl>
        <dt><code>name</code></dt>
        <dd>Command identifier (must match file name pattern <code>HAL-*</code>)</dd>

        <dt><code>description</code></dt>
        <dd>Brief one-sentence description shown in Claude Code command palette</dd>
    </dl>

    <h4>Optional Parameters Section</h4>

    <p>If your command accepts arguments, document them in the <code>parameters</code> array:</p>

    <pre><code class="language-yaml">parameters:
  - name: input_path
    description: Path to input file or directory
    type: string
    required: true
  - name: output_format
    description: Output format (json|yaml|text)
    type: string
    required: false
  - name: verbose
    description: Enable verbose output
    type: boolean
    required: false
</code></pre>

    <h4>Parameter Types</h4>

    <p>Supported parameter types:</p>
    <ul>
        <li><code>string</code> - Text values</li>
        <li><code>number</code> - Numeric values</li>
        <li><code>boolean</code> - True/false flags</li>
    </ul>

    <h4>Complete Example</h4>

    <pre><code class="language-yaml">---
name: HAL-search-report
description: Search codebase for pattern and generate comprehensive report
parameters:
  - name: search_pattern
    description: Search pattern (regex supported)
    type: string
    required: true
  - name: output_file
    description: Report output location (default: data/reports/search-results.md)
    type: string
    required: false
  - name: include_context
    description: Include surrounding lines in results
    type: boolean
    required: false
---

# HAL-search-report

**Command Type:** Development
**Purpose:** Search codebase and generate formatted report

## Usage

\`\`\`bash
/HAL-search-report "pattern" [output_file] [include_context]
\`\`\`

...
</code></pre>

    <h4>Benefits of YAML Frontmatter</h4>

    <figure class="diagram" data-diagram-id="frontmatter-benefits" style="max-width: 600px; margin: 20px auto;">
        <img src="assets/diagrams/frontmatter-benefits.png" alt="How YAML frontmatter enhances the command invocation experience" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: white;">
        <figcaption>How YAML frontmatter enhances the command invocation experience</figcaption>
    </figure>
    <table>
        <thead>
            <tr>
                <th>Model</th>
                <th>Speed</th>
                <th>Cost</th>
                <th>Use For</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><strong>Haiku</strong></td>
                <td>Fast</td>
                <td>Low</td>
                <td>File system operations, simple searches, fast navigation</td>
            </tr>
            <tr>
                <td><strong>Sonnet</strong></td>
                <td>Medium</td>
                <td>Medium</td>
                <td>Code generation, research synthesis, balanced reasoning (default)</td>
            </tr>
            <tr>
                <td><strong>Opus</strong></td>
                <td>Slow</td>
                <td>High</td>
                <td>Complex reasoning, multi-step analysis (rarely needed)</td>
            </tr>
        </tbody>
    </table>
    <div class="callout callout-tip">
        <strong>Pro Tip:</strong> Start with Sonnet (default). Only use Haiku for performance-critical file operations, or Opus for genuinely complex reasoning tasks.
    </div>
    <h4>Tool Whitelisting: Principle of Least Privilege</h4>
    <p>Agents should have <strong>minimal necessary capabilities</strong>. This security principle:</p>
    <ul>
        <li>Reduces attack surface (agent can't misuse tools it doesn't have)</li>
        <li>Improves performance (smaller tool set = faster agent startup)</li>
        <li>Documents capabilities (clear audit trail of what agent can do)</li>
        <li>Prevents scope creep (agent stays focused on intended purpose)</li>
    </ul>
    <h4>Example: HAL-Context-Finder Agent</h4>
    <p>This agent finds and loads system context. It needs file system access but no web access or code execution:</p>
    <pre><code class="language-yaml">---
name: hal-context-finder
description: Find and load system context without consuming main session RAM
tools:
  - Read                                    # Read file contents
  - Grep                                    # Search within files
  - Glob                                    # Find files by pattern
  - mcp__filesystem__search_files           # Recursive search
  - mcp__filesystem__list_directory         # Directory listing
  - mcp__filesystem__get_file_info          # File metadata
model: haiku                                 # Speed-optimized
---
</code></pre>
    <p><strong>Notice what's NOT included:</strong></p>
    <ul>
        <li>‚ùå Write/Edit - Agent only reads, never modifies</li>
        <li>‚ùå Bash - No shell access needed</li>
        <li>‚ùå WebSearch/WebFetch - Local file system only</li>
        <li>‚ùå Task - Doesn't delegate to other agents</li>
    </ul>
    <h4>Security Model Visualization</h4>
    <figure class="diagram" data-diagram-id="agent-security-model">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 600" width="800" height="600">
  <defs>
    <style>
      .title { font-family: Arial, sans-serif; font-size: 20px; font-weight: bold; text-anchor: middle; fill: #2c3e50; }
      .label { font-family: Arial, sans-serif; font-size: 14px; font-weight: bold; text-anchor: middle; }
      .desc { font-family: Arial, sans-serif; font-size: 12px; text-anchor: middle; fill: #666; }
      .principle { font-family: Arial, sans-serif; font-size: 16px; font-weight: bold; text-anchor: middle; fill: #e74c3c; }
    </style>
  </defs>

  <!-- Title -->
  <text x="400" y="40" class="title">Agent Security Model: Tool Whitelisting</text>

  <!-- Outer Circle - All Available Tools (blocked) -->
  <circle cx="400" cy="330" r="250" fill="#ffebee" stroke="#e57373" stroke-width="3" opacity="0.7"/>
  <text x="400" y="90" class="label" fill="#c62828">All Available Tools</text>
  <text x="400" y="110" class="desc">(Blocked by default)</text>

  <!-- Tool labels around outer circle -->
  <text x="150" y="200" class="desc" fill="#999">‚ùå TodoWrite</text>
  <text x="120" y="350" class="desc" fill="#999">‚ùå NotebookEdit</text>
  <text x="180" y="480" class="desc" fill="#999">‚ùå WebFetch</text>
  <text x="620" y="200" class="desc" fill="#999">‚ùå SlashCommand</text>
  <text x="680" y="350" class="desc" fill="#999">‚ùå BashOutput</text>
  <text x="620" y="480" class="desc" fill="#999">‚ùå KillShell</text>

  <!-- Middle Circle - Whitelisted Tools -->
  <circle cx="400" cy="330" r="160" fill="#fff9c4" stroke="#fbc02d" stroke-width="4"/>
  <text x="400" y="175" class="label" fill="#f57f17">Whitelisted Tools</text>
  <text x="400" y="195" class="desc">(Explicit permissions)</text>

  <!-- Whitelisted tool labels -->
  <text x="300" y="265" class="desc" fill="#f57f17">‚úì Read</text>
  <text x="500" y="265" class="desc" fill="#f57f17">‚úì Grep</text>
  <text x="300" y="390" class="desc" fill="#f57f17">‚úì Glob</text>
  <text x="500" y="390" class="desc" fill="#f57f17">‚úì search_files</text>

  <!-- Inner Circle - Agent -->
  <circle cx="400" cy="330" r="70" fill="#c8e6c9" stroke="#43a047" stroke-width="4"/>
  <text x="400" y="325" class="label" fill="#1b5e20">Agent</text>
  <text x="400" y="345" class="desc" fill="#2e7d32">(Restricted</text>
  <text x="400" y="360" class="desc" fill="#2e7d32">process)</text>

  <!-- Arrows showing access -->
  <defs>
    <marker id="access-arrow" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
      <polygon points="0 0, 8 4, 0 8" fill="#43a047" />
    </marker>
    <marker id="block-arrow" markerWidth="8" markerHeight="8" refX="7" refY="4" orient="auto">
      <polygon points="0 0, 8 4, 0 8" fill="#e57373" />
    </marker>
  </defs>

  <!-- Access arrows (agent can access whitelisted) -->
  <line x1="360" y1="290" x2="320" y2="270" stroke="#43a047" stroke-width="2" marker-end="url(#access-arrow)"/>
  <line x1="440" y1="290" x2="480" y2="270" stroke="#43a047" stroke-width="2" marker-end="url(#access-arrow)"/>

  <!-- Block arrows (agent cannot access non-whitelisted) -->
  <line x1="320" y1="300" x2="200" y2="230" stroke="#e57373" stroke-width="2" stroke-dasharray="5,5" marker-end="url(#block-arrow)"/>
  <text x="250" y="260" style="font-size: 10px; fill: #c62828;">‚úó Blocked</text>

  <!-- Principle label at bottom -->
  <rect x="200" y="540" width="400" height="50" fill="#ffebee" stroke="#e74c3c" stroke-width="2" rx="5"/>
  <text x="400" y="570" class="principle">Principle of Least Privilege</text>
</svg>
        <figcaption>Tool whitelisting creates security boundaries around agent capabilities</figcaption>
    </figure>
    <p><strong>References:</strong></p>
    <ul>
        <li>Complete tool catalog: <code>.claude/libraries/internal/tool-reference.md</code></li>
        <li>Common tool combinations: See Section 21.5 below</li>
        <li>Existing agents: <code>.claude/agents/</code> (reference implementations)</li>
    </ul>
</section>
<!-- ============================================ -->

<section id="section-21-5">
    <h3>21.5 Tool Selection and Security</h3>
    <p>Choosing the right tool set for your agent is critical for security and performance. This section provides common patterns and decision-making guidance.</p>
    <h4>Tool Reference</h4>
    <p>The complete tool catalog is available in <code>.claude/libraries/internal/tool-reference.md</code>. This reference documents:</p>
    <ul>
        <li>All standard Claude Code tools</li>
        <li>All MCP server tools (filesystem, omnisearch, ide)</li>
        <li>Tool descriptions and use cases</li>
        <li>Common tool combinations by agent type</li>
        <li>Security implications and best practices</li>
    </ul>
    <h4>Common Agent Patterns and Tool Sets</h4>
    <h5>File System Agents</h5>
    <p><strong>Purpose:</strong> Navigate, search, and read file system without modification</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Grep
  - Glob
  - mcp__filesystem__search_files
  - mcp__filesystem__list_directory
  - mcp__filesystem__get_file_info
</code></pre>
    <p><strong>Examples:</strong> hal-context-finder, system-maintenance agent</p>
    <h5>Research Agents</h5>
    <p><strong>Purpose:</strong> Web research with content extraction and synthesis</p>
    <pre><code class="language-yaml">tools:
  - mcp__omnisearch__web_search
  - mcp__omnisearch__firecrawl_process
  - WebSearch
  - WebFetch
  - Read
  - Write
</code></pre>
    <p><strong>Examples:</strong> research-synthesizer</p>
    <h5>Code Generation Agents</h5>
    <p><strong>Purpose:</strong> Generate or modify code files</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Write
  - Edit
  - Glob
  - Grep
</code></pre>
    <p><strong>Examples:</strong> command-builder</p>
    <h5>System Administration Agents</h5>
    <p><strong>Purpose:</strong> System validation, maintenance, operations</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Bash
  - Glob
  - Grep
  - mcp__filesystem__search_files
</code></pre>
    <p><strong>Examples:</strong> system-maintenance, validation agents</p>
    <h5>Minimal Read-Only Agents</h5>
    <p><strong>Purpose:</strong> Simple file reading and analysis</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Grep
  - Glob
</code></pre>
    <p><strong>Use when:</strong> Agent only needs to read and analyze, no writes or modifications</p>
    <h4>Tool Selection Decision Process</h4>
    <figure class="diagram" data-diagram-id="tool-selection-flowchart">
        <img src="assets/diagrams/tool-selection-flowchart.png" alt="Systematic approach to determining minimal necessary tool set" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: white;">
        <figcaption>Systematic approach to determining minimal necessary tool set</figcaption>
    </figure>
    <p><strong>Step-by-step process:</strong></p>
    <ol>
        <li><strong>List agent's tasks</strong> - What does it need to accomplish?</li>
        <li><strong>Match tasks to tools</strong> - Which tools enable those tasks?</li>
        <li><strong>Remove unnecessary tools</strong> - Challenge each tool: "Is this actually needed?"</li>
        <li><strong>Prefer built-in tools</strong> - Use Read/Write/Edit over MCP equivalents when possible</li>
        <li><strong>Document reasoning</strong> - Note why each tool is included</li>
    </ol>
    <h4>Security Implications</h4>
    <table>
        <thead>
            <tr>
                <th>Tool</th>
                <th>Risk Level</th>
                <th>Rationale</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>Read</code></td>
                <td>Low</td>
                <td>Read-only access, standard for most agents</td>
            </tr>
            <tr>
                <td><code>Write/Edit</code></td>
                <td>Medium</td>
                <td>Can modify files - ensure agent logic is sound</td>
            </tr>
            <tr>
                <td><code>Bash</code></td>
                <td>High</td>
                <td>Shell access - only for trusted system agents</td>
            </tr>
            <tr>
                <td><code>WebSearch/WebFetch</code></td>
                <td>Low-Medium</td>
                <td>External access - could leak info in queries</td>
            </tr>
            <tr>
                <td><code>Task</code></td>
                <td>Medium</td>
                <td>Delegates to sub-agents - ensure proper coordination</td>
            </tr>
        </tbody>
    </table>
    <div class="callout callout-warning">
        <strong>Bash Tool Warning:</strong> The Bash tool provides shell access. Only include it in agents that genuinely need to run system commands. Document why it's necessary.
    </div>
    <h4>Performance Considerations</h4>
    <p><strong>Tool set size impacts performance:</strong></p>
    <ul>
        <li><strong>Smaller tool sets:</strong> Faster agent initialization, clearer purpose</li>
        <li><strong>Larger tool sets:</strong> More flexible but slower startup, potential confusion</li>
    </ul>
    <p><strong>Optimization strategy:</strong></p>
    <ol>
        <li>Start with minimal tool set</li>
        <li>Test agent functionality</li>
        <li>Add tools only when proven necessary</li>
        <li>Document why each tool was added</li>
    </ol>
    <h4>Tool Audit Checklist</h4>
    <p>When reviewing agent tool specifications, ask:</p>
    <ul>
        <li>‚úÖ Is every tool actually used in the agent's instructions?</li>
        <li>‚úÖ Could any tool be removed without losing functionality?</li>
        <li>‚úÖ Are there built-in alternatives to MCP tools?</li>
        <li>‚úÖ Is Bash included? If yes, is it truly necessary?</li>
        <li>‚úÖ Does tool set match agent's stated purpose?</li>
        <li>‚úÖ Are security implications documented?</li>
    </ul>
    <h4>Examples from HAL8000-Assistant System Agents</h4>
    <p><strong>hal-context-finder:</strong> Minimal file system tools + Haiku model (speed-optimized)</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Grep
  - Glob
  - mcp__filesystem__search_files
  - mcp__filesystem__list_directory
  - mcp__filesystem__get_file_info
model: haiku
</code></pre>
    <p><strong>research-synthesizer:</strong> Full web research toolset + Sonnet model (reasoning)</p>
    <pre><code class="language-yaml">tools:
  - mcp__omnisearch__web_search
  - mcp__omnisearch__firecrawl_process
  - WebSearch
  - WebFetch
  - Read
  - Write
model: sonnet
</code></pre>
    <p><strong>command-builder:</strong> Code generation tools only + Sonnet model</p>
    <pre><code class="language-yaml">tools:
  - Read
  - Glob
  - Grep
model: sonnet
</code></pre>
    <div class="callout callout-success">
        <strong>Best Practice:</strong> Review existing HAL8000-Assistant agents in <code>.claude/agents/</code> as reference implementations. They demonstrate proven tool selection patterns.
    </div>
    <p><strong>References:</strong></p>
    <ul>
        <li>Complete tool catalog: <code>.claude/libraries/internal/tool-reference.md</code></li>
        <li>Existing agents: <code>.claude/agents/</code></li>
        <li>Claude Code tool documentation: Official docs for latest tool specifications</li>
    </ul>
</section>
<!-- ============================================ -->
<!-- SECTION 22 ENHANCEMENT -->
<!-- ============================================ -->

        <p class="cross-ref">See also: <a href="#agent-reference">Agent Reference</a>, <a href="#ram-management">RAM Management</a>, <a href="#creating-commands">Creating Commands</a></p>

    </div>
</section>

            <!-- Section 23: Library System -->
<section id="library-system" data-status="complete" data-priority="3" data-sources=".claude/libraries/" data-estimated-tokens="12000" data-dependencies="">
    <h2>23. Library System</h2>
    <div class="content">

        <p>The Library System provides reusable instruction collections that enable pattern discovery and composition without reinventing solutions.</p>

        <h3>Library Architecture</h3>
        <pre><code>.claude/libraries/
‚îú‚îÄ‚îÄ index.json              # Master searchable index
‚îú‚îÄ‚îÄ internal/               # Libraries you develop
‚îÇ   ‚îú‚îÄ‚îÄ development/
‚îÇ   ‚îú‚îÄ‚îÄ research/
‚îÇ   ‚îú‚îÄ‚îÄ deployment/
‚îÇ   ‚îî‚îÄ‚îÄ system/
‚îî‚îÄ‚îÄ external/               # Third-party libraries (read-only)
    ‚îî‚îÄ‚îÄ fabric-patterns/    # 227 patterns, 292 files</code></pre>

        <h3>Internal vs External Libraries</h3>

        <h4>Internal Libraries</h4>
        <ul>
            <li>Developed and maintained by you</li>
            <li>YAML frontmatter metadata</li>
            <li>Organized by 4 categories: development, research, deployment, system</li>
            <li>Can be modified and improved</li>
        </ul>

        <h4>External Libraries</h4>
        <ul>
            <li><strong>Read-only:</strong> Never modify external files</li>
            <li>Original structure preserved exactly</li>
            <li>Metadata extracted via content scanning (not frontmatter)</li>
            <li>Exempt from 3-level depth limit</li>
            <li>Updated via <code>/HAL-library-update</code></li>
        </ul>

        <h3>Library Index System</h3>
        <p>The index.json file enables discovery without loading files into RAM:</p>
        <ul>
            <li>Search by keywords</li>
            <li>Estimate token costs before loading</li>
            <li>Track 226+ indexed patterns</li>
            <li>Updated via <code>/HAL-index-update</code></li>
        </ul>

        <h3>Using Libraries</h3>
        <pre><code># Discover libraries
/HAL-context-find "code review"

# Load selected library
Read .claude/libraries/internal/development/code-review.md

# Apply instructions to current task</code></pre>

        <h3>Creating Internal Libraries</h3>
        <p><strong>When to create:</strong></p>
        <ul>
            <li>Workflow used 2-3+ times successfully</li>
            <li>Pattern is generalizable</li>
            <li>Instructions are reusable</li>
        </ul>

        <p><strong>Frontmatter template:</strong></p>
        <pre><code>---
title: "Library Title"
description: "Brief description"
keywords: ["keyword1", "keyword2"]
category: "development"
dependencies: ["other-library"]
composable: true
last_updated: "2025-10-10"
---</code></pre>

        <h3>Package Manager</h3>
        <p>Manage external library lifecycles:</p>
        <pre><code># Update external library
/HAL-library-update fabric-patterns

# Workflow: validate ‚Üí check updates ‚Üí backup ‚Üí download ‚Üí replace ‚Üí reindex</code></pre>

        <h3>Library Composition</h3>
        <p>Chain libraries via dependencies to build complex workflows from simple components:</p>
        <pre><code>dependencies: ["code-review-workflow", "test-suite-execution"]</code></pre>

        <h3>Best Practices</h3>
        <ul>
            <li>Always discover before loading (<code>/HAL-context-find</code>)</li>
            <li>Check token estimates before loading</li>
            <li>Load only specific libraries needed</li>
            <li><strong>Never modify external libraries</strong></li>
            <li>Reindex after creating/modifying libraries</li>
            <li>Offload library content after applying instructions</li>
        </ul>

        <h3>Current Status</h3>
        <ul>
            <li><strong>Categories:</strong> 4 (development, research, deployment, system)</li>
            <li><strong>External Libraries:</strong> 1 (fabric-patterns)</li>
            <li><strong>Indexed Patterns:</strong> 226</li>
            <li><strong>Total Estimated Tokens:</strong> ~189,400</li>
        </ul>


<section id="section-22-3">
    <h3>22.3 Template Library</h3>
    <p>The <strong>Template Library</strong> (<code>.claude/libraries/internal/templates/</code>) provides composable prompt templates for creating well-structured HAL-Script commands. This library implements the "Lego Block" principle: reusable sections that can be mixed and matched.</p>
    <h4>Library Contents</h4>
    <p><strong>Location:</strong> <code>.claude/libraries/internal/templates/</code></p>
    <p><strong>Files:</strong></p>
    <ul>
        <li><code>master-prompt-template.md</code> - Complete catalog of all possible sections</li>
        <li><code>level-1-basic.md</code> - Simple single-step commands</li>
        <li><code>level-2-workflow.md</code> - Multi-step workflows with parameters</li>
        <li><code>level-3-control-flow.md</code> - Commands with conditionals/loops</li>
        <li><code>level-4-delegate.md</code> - Sub-agent invocation patterns</li>
        <li><code>level-5-supervisor.md</code> - Multi-agent coordination</li>
        <li><code>level-6-workflow-composition.md</code> - Command composition patterns</li>
        <li><code>level-7-system.md</code> - Production-critical system commands</li>
        <li><code>template-guide.md</code> - Complete usage guide and reference</li>
    </ul>
    <h4>The 7 Levels Framework</h4>
    <p>Templates are organized by complexity using <strong>IndyDevDan's "7 Levels of Agentic Prompt Formats"</strong> adapted for HAL-Script:</p>
    <figure class="diagram" data-diagram-id="template-library-structure">
        <img src="assets/diagrams/template-library-structure.png" alt="Template library organization and relationships" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: white;">
        <figcaption>Template library organization and relationships</figcaption>
    </figure>
    <table>
        <thead>
            <tr>
                <th>Level</th>
                <th>Complexity</th>
                <th>Key Features</th>
                <th>Use Cases</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1 - Basic</td>
                <td>Minimal</td>
                <td>Purpose + Instructions only</td>
                <td>Simple status checks, display commands</td>
            </tr>
            <tr>
                <td>2 - Workflow</td>
                <td>Low-Medium</td>
                <td>Multi-step, parameters, output format</td>
                <td>File processing, report generation</td>
            </tr>
            <tr>
                <td>3 - Control Flow</td>
                <td>Medium</td>
                <td>Conditionals, loops, branching</td>
                <td>Validation, iteration, conditional processing</td>
            </tr>
            <tr>
                <td>4 - Delegate</td>
                <td>Medium-High</td>
                <td>Sub-agent invocation, orchestration</td>
                <td>Research, analysis, specialized tasks</td>
            </tr>
            <tr>
                <td>5 - Supervisor</td>
                <td>High</td>
                <td>Multi-agent coordination, parallel execution</td>
                <td>Complex workflows, multi-phase operations</td>
            </tr>
            <tr>
                <td>6 - Workflow Composition</td>
                <td>High</td>
                <td>Command composition, end-to-end workflows</td>
                <td>Release processes, data pipelines</td>
            </tr>
            <tr>
                <td>7 - System</td>
                <td>Maximum</td>
                <td>Comprehensive docs, testing, production-grade</td>
                <td>Core infrastructure, state management</td>
            </tr>
        </tbody>
    </table>
    <h4>Lego Block Principle</h4>
    <p>Each template is composed of <strong>reusable sections</strong> (Lego blocks):</p>
    <dl>
        <dt>Purpose</dt>
        <dd>What the command does and why it exists</dd>
        <dt>Usage</dt>
        <dd>How to invoke the command and what arguments it accepts</dd>
        <dt>Variables/Parameters</dt>
        <dd>Input parameters, configuration, output variables</dd>
        <dt>Instructions</dt>
        <dd>Step-by-step execution logic</dd>
        <dt>Delegation Patterns</dt>
        <dd>How command invokes sub-agents</dd>
        <dt>Workflow Integration</dt>
        <dd>How command composes with other commands</dd>
        <dt>Output Format</dt>
        <dd>Structure of command output</dd>
        <dt>Error Handling</dt>
        <dd>How failures are detected and handled</dd>
        <dt>Examples</dt>
        <dd>Real-world usage scenarios</dd>
        <dt>Dependencies</dt>
        <dd>Required files, commands, or system components</dd>
        <dt>Performance Considerations</dt>
        <dd>RAM usage, execution time, optimizations</dd>
        <dt>Testing & Validation</dt>
        <dd>How to verify command works correctly</dd>
        <dt>Metadata</dt>
        <dd>Version, status, dates, authorship</dd>
    </dl>
    <p><strong>Mix and match:</strong> Start with a level template, then add/remove sections as needed. Templates are guides, not constraints.</p>
    <h4>Quick Selection Guide</h4>
    <p>Choose your template based on command requirements:</p>
    <table>
        <thead>
            <tr>
                <th>If You Need...</th>
                <th>Choose This Level</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Simple task, no parameters</td>
                <td>Level 1 (Basic)</td>
            </tr>
            <tr>
                <td>Multi-step process with inputs</td>
                <td>Level 2 (Workflow)</td>
            </tr>
            <tr>
                <td>If/else logic or loops</td>
                <td>Level 3 (Control Flow)</td>
            </tr>
            <tr>
                <td>Delegate to one agent</td>
                <td>Level 4 (Delegate)</td>
            </tr>
            <tr>
                <td>Coordinate multiple agents</td>
                <td>Level 5 (Supervisor)</td>
            </tr>
            <tr>
                <td>Compose multiple commands</td>
                <td>Level 6 (Workflow Composition)</td>
            </tr>
            <tr>
                <td>Core system infrastructure</td>
                <td>Level 7 (System)</td>
            </tr>
            <tr>
                <td>Unsure / custom needs</td>
                <td>Master Template</td>
            </tr>
        </tbody>
    </table>
    <h4>Integration with Command Creation Tools</h4>
    <p>The template library integrates with HAL8000-Assistant's command creation automation:</p>
    <figure class="diagram" data-diagram-id="template-automation-workflow">
        <img src="assets/diagrams/template-automation-workflow.png" alt="How template library enables automated command creation" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: white;">
        <figcaption>How template library enables automated command creation</figcaption>
    </figure>
    <p><strong>Automation components:</strong></p>
    <ul>
        <li><strong>HAL-command-create command:</strong> User interface for creating commands</li>
        <li><strong>command-builder agent:</strong> Processes requirements and generates commands</li>
        <li><strong>Template library:</strong> Provides proven structures and patterns</li>
    </ul>
    <p><strong>Workflow:</strong></p>
    <ol>
        <li>User invokes <code>/HAL-command-create</code> with requirements</li>
        <li>Command delegates to command-builder agent</li>
        <li>Agent analyzes requirements and selects appropriate template</li>
        <li>Agent customizes template (removes unused sections, fills in logic)</li>
        <li>Agent outputs production-ready command with YAML frontmatter</li>
        <li>User reviews and deploys command</li>
    </ol>
    <h4>Master Template</h4>
    <p>The <code>master-prompt-template.md</code> is the <strong>complete Lego block catalog</strong> showing all possible sections. Use it when:</p>
    <ul>
        <li>Building complex custom commands</li>
        <li>You need comprehensive reference</li>
        <li>Existing level templates don't fit your needs</li>
        <li>Creating new level templates</li>
    </ul>
    <div class="callout callout-info">
        <strong>Philosophy:</strong> The master template ensures you never forget possible sections. Start with it, remove what you don't need, and you'll have a complete, well-structured command.
    </div>
    <h4>Usage Example</h4>
    <pre><code class="language-bash"># Manual approach: Copy and customize template
cp .claude/libraries/internal/templates/level-2-workflow.md \\
   .claude/commands/development/HAL-new-command.md
# Edit the file, remove unused sections, fill in logic
# Result: Consistent command structure
# Automated approach: Use command-builder
/HAL-command-create "Create command that searches code and generates report"
# Agent selects Level 2 template, generates complete command
# Result: Production-ready command with frontmatter
</code></pre>
    <h4>Template Guide</h4>
    <p>The <code>template-guide.md</code> file provides comprehensive documentation:</p>
    <ul>
        <li>Detailed description of each level</li>
        <li>Section-by-section usage guide</li>
        <li>Common patterns and best practices</li>
        <li>YAML frontmatter integration</li>
        <li>Examples and recommendations</li>
    </ul>
    <p><strong>Read the template guide for:</strong></p>
    <ul>
        <li>Understanding when to use each level</li>
        <li>Learning what each section should contain</li>
        <li>Seeing examples of template usage</li>
        <li>Best practices for command creation</li>
    </ul>
    <h4>Benefits of Template Library</h4>
    <ul>
        <li><strong>Consistency:</strong> All commands follow same organizational pattern</li>
        <li><strong>Speed:</strong> Start with proven structure instead of blank file</li>
        <li><strong>Completeness:</strong> Templates remind you of important sections</li>
        <li><strong>Best practices:</strong> Built-in patterns from production commands</li>
        <li><strong>Maintainability:</strong> Familiar structure across all commands</li>
        <li><strong>Automation:</strong> Enables command-builder agent functionality</li>
        <li><strong>Quality:</strong> Reduces errors through standardized structure</li>
    </ul>
    <div class="callout callout-success">
        <strong>Integration Complete:</strong> As of HAL8000-Assistant v1.2.0, all templates include YAML frontmatter examples and are production-ready.
    </div>
    <p><strong>References:</strong></p>
    <ul>
        <li>Template library location: <code>.claude/libraries/internal/templates/</code></li>
        <li>Complete guide: <code>template-guide.md</code></li>
        <li>Framework credit: IndyDevDan's "7 Levels of Agentic Prompt Formats"</li>
        <li>Related: Section 20.4 (Using Prompt Templates)</li>
        <li>Related: Section 20.5 (YAML Frontmatter)</li>
    </ul>
</section>

        <p class="cross-ref">See also: <a href="#command-reference">HAL-library-update</a>, <a href="#command-reference">HAL-index-update</a>, <a href="#hal-context-find">HAL-context-find</a></p>

    </div>
</section>

            <!-- Section 24: Contributing Patterns -->
<section id="contributing" data-status="complete" data-priority="3" data-sources="" data-estimated-tokens="10000" data-dependencies="">
    <h2>24. Contributing Patterns</h2>
    <div class="content">

        <p>HAL8000-Assistant is a living system designed for continuous improvement through self-modifying code capabilities. This section guides effective contribution following von Neumann principles and Unix philosophy.</p>

        <h3>Philosophy of Contribution</h3>
        <ul>
            <li><strong>Build Reusable Patterns, Not One-Offs:</strong> Solve classes of problems</li>
            <li><strong>Improve the Architecture:</strong> Enhance the system itself</li>
            <li><strong>Documentation-Driven:</strong> Document before, during, and after</li>
            <li><strong>Self-Modifying Code:</strong> Embrace the capability</li>
            <li><strong>RAM Optimization First:</strong> Always consider context efficiency</li>
        </ul>

        <h3>What to Contribute</h3>

        <h4>Commands (.claude/commands/HAL-*.md)</h4>
        <p><strong>When to create:</strong></p>
        <ul>
            <li>Solve same problem repeatedly across sessions</li>
            <li>Workflow emerges combining multiple steps</li>
            <li>System management needs new operation</li>
            <li>Need to automate complex state transition</li>
        </ul>

        <h4>Agents (.claude/agents/*.md)</h4>
        <p><strong>When to create:</strong></p>
        <ul>
            <li>Task requires >30K tokens context</li>
            <li>Processing benefits from isolated context</li>
            <li>Output much smaller than input (high compression)</li>
            <li>Pattern repeats across use cases</li>
        </ul>

        <h4>Libraries (.claude/libraries/internal/)</h4>
        <p><strong>When to create:</strong></p>
        <ul>
            <li>Pattern emerges from repeated implementations</li>
            <li>Multiple components share common logic</li>
            <li>Generalizable solution discovered</li>
            <li>Workflow needs codification</li>
        </ul>

        <h4>Documentation (data/)</h4>
        <p><strong>When to contribute:</strong></p>
        <ul>
            <li>Architecture evolves</li>
            <li>New patterns emerge</li>
            <li>Research uncovers foundations</li>
            <li>Reference manual needs expansion</li>
        </ul>

        <h3>Contribution Workflow</h3>

        <h4>Step 1: Identify Reusable Pattern</h4>
        <ul>
            <li>Have I solved this >1 time?</li>
            <li>Could this benefit other scenarios?</li>
            <li>Does this improve architecture?</li>
            <li>Is this generalizable?</li>
        </ul>

        <h4>Step 2: Design Following Principles</h4>
        <ul>
            <li><strong>Von Neumann:</strong> Fits stored-program concept, self-modifiable?</li>
            <li><strong>Unix:</strong> One thing well, composable, text I/O?</li>
            <li><strong>Assembly:</strong> Explicit control, no hidden state?</li>
            <li><strong>RAM:</strong> Optimizes context usage?</li>
        </ul>

        <h4>Step 3: Implement</h4>
        <ul>
            <li>Follow naming conventions</li>
            <li>Include frontmatter metadata</li>
            <li>Structure logically with clear sections</li>
            <li>Provide examples</li>
        </ul>

        <h4>Step 4: Test Thoroughly</h4>
        <ul>
            <li><strong>Commands:</strong> Invocation, parameters, errors, state</li>
            <li><strong>Agents:</strong> Real scenarios, token savings, output format</li>
            <li><strong>Libraries:</strong> Application, composability, accuracy</li>
        </ul>

        <h4>Step 5: Document Clearly</h4>
        <ul>
            <li>Purpose/overview</li>
            <li>Usage instructions</li>
            <li>Parameters/inputs</li>
            <li>Expected outputs</li>
            <li>Examples</li>
            <li>Cross-references</li>
        </ul>

        <h4>Step 6: Update Indexes</h4>
        <pre><code>/HAL-index-update</code></pre>

        <h4>Step 7: Update State and Create Session</h4>
        <pre><code># Update state.json
Edit .claude/state.json

# Create session file
/HAL-session-end "added-new-component"</code></pre>

        <h3>Quality Standards</h3>

        <h4>Code and Commands</h4>
        <ul>
            <li>Single responsibility</li>
            <li>Clear naming</li>
            <li>Self-documenting</li>
            <li>Error handling</li>
            <li>Explicit state management</li>
        </ul>

        <h4>Architecture</h4>
        <ul>
            <li>Von Neumann compliance</li>
            <li>Unix philosophy adherence</li>
            <li>3-level depth limit (except external libraries)</li>
            <li>RAM optimization</li>
        </ul>

        <h3>Contribution Checklist</h3>
        <ul>
            <li>‚òê Follows design principles</li>
            <li>‚òê Tested thoroughly</li>
            <li>‚òê Documented clearly</li>
            <li>‚òê Indexes updated</li>
            <li>‚òê State.json updated</li>
            <li>‚òê System check passed (<code>/HAL-system-check</code>)</li>
            <li>‚òê Session file created</li>
            <li>‚òê Boot verified</li>
        </ul>

        <h3>Getting Started</h3>

        <h4>For New Contributors</h4>
        <ol>
            <li><strong>Read BIOS:</strong> <code>Read CLAUDE.md</code></li>
            <li><strong>Study Components:</strong> Examine commands, agents, libraries</li>
            <li><strong>Start Small:</strong> Simple command or library pattern</li>
            <li><strong>Ask Questions:</strong> Use <code>/HAL-context-find</code></li>
            <li><strong>Iterate:</strong> Create, test, refine</li>
        </ol>

        <h3>Best Practices</h3>
        <ul>
            <li>Solve real problems (not speculative)</li>
            <li>Document as you build</li>
            <li>Test in real scenarios</li>
            <li>Seek feedback (run system checks)</li>
            <li>Think architecturally</li>
            <li>Optimize for RAM</li>
            <li>Cross-reference extensively</li>
            <li>Follow naming conventions</li>
        </ul>

        <h3>The Living System</h3>
        <p>HAL8000-Assistant evolves through contributions. Commands can create commands, agents can be generated, patterns evolve into frameworks. Your contribution extends the system's capabilities and enables new classes of operations.</p>

        <p class="cross-ref">See also: <a href="#operating-principles">Operating Principles</a>, <a href="#creating-commands">Creating Commands</a>, <a href="#building-agents">Building Agents</a>, <a href="#library-system">Library System</a></p>

    </div>
</section>

            <!-- Appendices -->
            <div class="part-divider">
                <h1 class="part-header">Appendices</h1>
                <p class="part-description">Glossary, troubleshooting, design decisions, version history, and index</p>
            </div>

            <!-- Appendix A: Glossary -->
<section id="glossary" class="doc-section">
  <h2>Appendix A: Glossary</h2>

  <div class="glossary-intro">
    <p>This glossary defines key terms and concepts used throughout the HAL8000-Assistant system. Terms are organized alphabetically within logical categories for easy reference.</p>
  </div>

  <h3>Architecture Terms</h3>
  <dl class="glossary-list">
    <dt id="term-alu">ALU (Arithmetic Logic Unit)</dt>
    <dd>
      <p>The reasoning and computation component of the CPU. In HAL8000-Assistant, this represents Claude's ability to perform logical operations, calculations, and data transformations.</p>
      <p class="see-also">See also: <a href="#term-cpu">CPU</a>, <a href="#term-control-unit">Control Unit</a></p>
    </dd>

    <dt id="term-append-only-ram">Append-Only RAM</dt>
    <dd>
      <p>A fundamental constraint of HAL8000-Assistant's memory model where the context window accumulates content without dynamic eviction within a session. Once content is loaded into RAM, it remains until the session boundary is reached.</p>
      <p class="see-also">See also: <a href="#term-ram">RAM</a>, <a href="#term-session-boundary">Session Boundary</a></p>
    </dd>

    <dt id="term-control-unit">Control Unit</dt>
    <dd>
      <p>The orchestration and decision-making component of the CPU. In HAL8000-Assistant, this represents Claude's ability to coordinate operations, manage workflow, and make strategic decisions about system operation.</p>
      <p class="see-also">See also: <a href="#term-cpu">CPU</a>, <a href="#term-alu">ALU</a></p>
    </dd>

    <dt id="term-fetch-decode-execute">Fetch-Decode-Execute Cycle</dt>
    <dd>
      <p>The fundamental operational cycle of the CPU: (1) Fetch an instruction from memory, (2) Decode the instruction to understand what operation is required, (3) Execute the operation, (4) Update system state and prepare for the next instruction.</p>
      <p class="see-also">See also: <a href="#term-cpu">CPU</a>, <a href="#term-pc-register">PC Register</a></p>
    </dd>

    <dt id="term-harvard-architecture">Harvard Architecture</dt>
    <dd>
      <p>A computer architecture with physically separate storage and signal pathways for instructions and data. HAL8000-Assistant uses Harvard-like organization (separate .claude/ and data/ directories) while maintaining von Neumann capabilities.</p>
      <p class="see-also">See also: <a href="#term-modified-von-neumann">Modified von Neumann Architecture</a></p>
    </dd>

    <dt id="term-modified-von-neumann">Modified von Neumann Architecture</dt>
    <dd>
      <p>HAL8000-Assistant's architectural model that combines Harvard-like organization (separate instruction/data spaces) with von Neumann capabilities (unified access, self-modifying code). This hybrid approach accommodates environmental constraints while preserving the stored-program concept.</p>
      <p class="see-also">See also: <a href="#term-stored-program">Stored-Program Concept</a>, <a href="#term-self-modifying-code">Self-Modifying Code</a></p>
    </dd>

    <dt id="term-ram-zone">RAM Zone</dt>
    <dd>
      <p>Performance classification of current RAM usage: SAFE (0-80%, normal operation), CAUTION (80-90%, monitor closely, prepare checkpoint), DANGER (90-100%, checkpoint urgently, performance degraded). Used to guide resource management decisions.</p>
      <p class="see-also">See also: <a href="#term-ram">RAM</a>, <a href="#term-checkpoint">Checkpoint</a></p>
    </dd>

    <dt id="term-self-modifying-code">Self-Modifying Code</dt>
    <dd>
      <p>A von Neumann capability where programs can create or modify other programs. In HAL8000-Assistant, commands can write to .claude/commands/ to create new commands or modify existing ones, enabling dynamic system evolution.</p>
      <p class="see-also">See also: <a href="#term-stored-program">Stored-Program Concept</a>, <a href="#term-command">Command</a></p>
    </dd>

    <dt id="term-stored-program">Stored-Program Concept</dt>
    <dd>
      <p>The von Neumann principle where instructions and data reside in the same memory space and are accessed in the same way. In HAL8000-Assistant, both instructions (commands) and data are stored as files with unified access through the file system.</p>
      <p class="see-also">See also: <a href="#term-modified-von-neumann">Modified von Neumann Architecture</a></p>
    </dd>

    <dt id="term-virtual-memory">Virtual Memory (Sub-Agents)</dt>
    <dd>
      <p>The architectural model where sub-agents act as virtual memory by providing isolated 200K RAM contexts. This extends total system capacity beyond the main session's 200K limit through process isolation, with agents returning only essential summaries rather than full processing output.</p>
      <p class="see-also">See also: <a href="#term-sub-agent">Sub-Agent</a>, <a href="#term-agent">Agent</a></p>
    </dd>
  </dl>

  <h3>System Components</h3>
  <dl class="glossary-list">
    <dt id="term-agent">Agent</dt>
    <dd>
      <p>A specialized co-processor with isolated 200K RAM context that performs specific tasks (research, context discovery, system maintenance). Agents extend system capacity by processing heavy workloads in isolated contexts and returning clean summaries to the main session.</p>
      <p class="see-also">See also: <a href="#term-sub-agent">Sub-Agent Protocol</a>, <a href="#term-virtual-memory">Virtual Memory</a></p>
    </dd>

    <dt id="term-bios">BIOS (Basic Input/Output System)</dt>
    <dd>
      <p>The boot instructions stored in CLAUDE.md at the repository root. Contains system architecture definition, boot sequence, operating principles, and fundamental system protocols. Loaded on every new session to initialize the CPU.</p>
      <p class="see-also">See also: <a href="#term-boot-sequence">Boot Sequence</a>, <a href="#term-cpu">CPU</a></p>
    </dd>

    <dt id="term-command">Command</dt>
    <dd>
      <p>An executable instruction stored in .claude/commands/ with naming convention HAL-*.md. Commands implement specific operations (session-end, register-dump, etc.) and follow the principle of doing one thing well.</p>
      <p class="see-also">See also: <a href="#term-instruction-set">Instruction Set</a></p>
    </dd>

    <dt id="term-cpu">CPU (Central Processing Unit)</dt>
    <dd>
      <p>The Claude instance itself, serving as the processing unit of HAL8000-Assistant. Comprises the Control Unit (orchestration/decision-making), ALU (reasoning/computation), and Registers (immediate working context).</p>
      <p class="see-also">See also: <a href="#term-control-unit">Control Unit</a>, <a href="#term-alu">ALU</a>, <a href="#term-register">Register</a></p>
    </dd>

    <dt id="term-index">Index</dt>
    <dd>
      <p>A discovery mechanism stored in .claude/indexes/ that catalogs file system structure or library patterns. Includes master index (entire file system), per-directory indexes, and library index. Enables efficient discovery without loading all files into RAM.</p>
      <p class="see-also">See also: <a href="#term-hierarchical-index">Hierarchical Index</a>, <a href="#term-library-index">Library Index</a></p>
    </dd>

    <dt id="term-library">Library</dt>
    <dd>
      <p>A collection of reusable instructions, patterns, or workflows. Can be internal (developed within HAL8000-Assistant) or external (imported from external sources). Libraries are indexed for efficient discovery and organized by category.</p>
      <p class="see-also">See also: <a href="#term-library-index">Library Index</a>, <a href="#term-package-manager">Package Manager</a></p>
    </dd>

    <dt id="term-ram">RAM (Random Access Memory)</dt>
    <dd>
      <p>The Claude context window, limited to 200,000 tokens. Volatile (lost at session boundary), append-only within session (no dynamic eviction), and serves as the CPU's working memory. RAM Zone classifications (SAFE/CAUTION/DANGER) guide usage.</p>
      <p class="see-also">See also: <a href="#term-ram-zone">RAM Zone</a>, <a href="#term-session-boundary">Session Boundary</a></p>
    </dd>

    <dt id="term-register">Register</dt>
    <dd>
      <p>A component of immediate working context holding specific system state values. HAL8000-Assistant defines 21 registers across 5 categories: System State, Resource Management, Context Tracking, Execution Control, and Diagnostic registers.</p>
      <p class="see-also">See also: <a href="#term-cpu">CPU</a>, <a href="register-architecture.html">Register Architecture Reference</a></p>
    </dd>

    <dt id="term-session-file">Session File</dt>
    <dd>
      <p>A markdown file in .claude/sessions/ containing rich context for resuming work after RAM wipe. Named YYYY-MM-DD-HHMM-description.md, containing Context, Key Decisions, Active Work, Loaded Files, and Variables/State sections.</p>
      <p class="see-also">See also: <a href="#term-session-continuity">Session Continuity</a>, <a href="#term-state-pointer">State Pointer</a></p>
    </dd>

    <dt id="term-state-pointer">State Pointer (state.json)</dt>
    <dd>
      <p>A JSON file at .claude/state.json containing the current system state snapshot. Always loaded on boot. Contains timestamp, active_session reference, context description, next_action, loaded_commands, and variables. Overwritten on each checkpoint (no history retention).</p>
      <p class="see-also">See also: <a href="#term-session-file">Session File</a>, <a href="#term-boot-sequence">Boot Sequence</a></p>
    </dd>

    <dt id="term-sub-agent">Sub-Agent</dt>
    <dd>
      <p>An agent invoked via the Sub-Agent Protocol for context-heavy tasks. Operates in isolated 200K RAM context, processes work, and returns clean summaries to main session. Results are volatile (lost at session boundary unless persisted to files).</p>
      <p class="see-also">See also: <a href="#term-agent">Agent</a>, <a href="#term-virtual-memory">Virtual Memory</a></p>
    </dd>
  </dl>

  <h3>Operating Concepts</h3>
  <dl class="glossary-list">
    <dt id="term-boot-sequence">Boot Sequence</dt>
    <dd>
      <p>The mandatory initialization process executed on every new session: (1) Load BIOS (CLAUDE.md), (2) Load State (state.json), (3) Note available session (do not auto-load), (4) Provide structured boot acknowledgment, (5) Set CPU_STATUS to OPERATIONAL or DEGRADED, (6) Ready to execute.</p>
      <p class="see-also">See also: <a href="#term-bios">BIOS</a>, <a href="#term-degraded-mode">Degraded Mode</a></p>
    </dd>

    <dt id="term-checkpoint">Checkpoint</dt>
    <dd>
      <p>The process of saving current session state before RAM wipe. Triggered proactively when RAM_ZONE enters CAUTION, major work completed, before context-heavy operations, or when explicitly requested by user. Executed via /HAL-session-end command.</p>
      <p class="see-also">See also: <a href="#term-session-continuity">Session Continuity</a>, <a href="#term-ram-zone">RAM Zone</a></p>
    </dd>

    <dt id="term-context-manifest">Context Manifest</dt>
    <dd>
      <p>A register (CONTEXT_MANIFEST) tracking all files currently loaded in RAM. Used to prevent duplicate loading and assess current RAM consumption. Essential for selective loading discipline.</p>
      <p class="see-also">See also: <a href="#term-selective-loading">Selective Loading</a>, <a href="#term-register">Register</a></p>
    </dd>

    <dt id="term-degraded-mode">Degraded Mode</dt>
    <dd>
      <p>Operational state when optional files fail to load during boot (session files, command files, architecture docs). System continues with reduced functionality and warns user. Core file failures (BIOS, state.json) result in system failure, not degraded mode.</p>
      <p class="see-also">See also: <a href="#term-boot-sequence">Boot Sequence</a>, <a href="#term-bios">BIOS</a></p>
    </dd>

    <dt id="term-ram-wipe">RAM Wipe</dt>
    <dd>
      <p>The clearing of the context window (RAM) when starting a new session. Results in complete loss of volatile working memory. Session continuity protocol (checkpoint before wipe, resume after wipe) enables work continuity across RAM wipes.</p>
      <p class="see-also">See also: <a href="#term-session-boundary">Session Boundary</a>, <a href="#term-checkpoint">Checkpoint</a></p>
    </dd>

    <dt id="term-selective-loading">Selective Loading</dt>
    <dd>
      <p>The discipline of loading ONLY files needed for the current task, never speculatively. Required because RAM is append-only within session‚Äîevery file load is a one-way commitment. Enforced through resource management protocol checking CONTEXT_MANIFEST and RAM_ZONE before loading.</p>
      <p class="see-also">See also: <a href="#term-append-only-ram">Append-Only RAM</a>, <a href="#term-context-manifest">Context Manifest</a></p>
    </dd>

    <dt id="term-session-boundary">Session Boundary</dt>
    <dd>
      <p>The point at which one session ends and another begins. Serves as garbage collection‚Äîthe only way to reclaim RAM in HAL8000-Assistant's append-only memory model. All volatile data (RAM, sub-agent output) is lost unless persisted to files before crossing boundary.</p>
      <p class="see-also">See also: <a href="#term-ram-wipe">RAM Wipe</a>, <a href="#term-session-continuity">Session Continuity</a></p>
    </dd>

    <dt id="term-session-continuity">Session Continuity</dt>
    <dd>
      <p>The protocol for maintaining work context across session boundaries. Before RAM wipe: run /HAL-session-end to capture state. After RAM wipe: boot sequence notes available session, user can say "resume" to load it. Enables seamless work continuation despite volatile RAM.</p>
      <p class="see-also">See also: <a href="#term-session-file">Session File</a>, <a href="#term-state-pointer">State Pointer</a></p>
    </dd>

    <dt id="term-sub-agent-protocol">Sub-Agent Protocol</dt>
    <dd>
      <p>The architectural pattern for delegating context-heavy tasks to isolated agents. ALWAYS delegate: web research, context discovery, large file analysis, multi-step tasks >30K tokens. Agent processes in isolated 200K context, returns clean summary to main session. Critical constraint: sub-agent output is volatile‚Äîmust persist to files before session-end.</p>
      <p class="see-also">See also: <a href="#term-sub-agent">Sub-Agent</a>, <a href="#term-virtual-memory">Virtual Memory</a></p>
    </dd>
  </dl>

  <h3>Unix Philosophy Terms</h3>
  <dl class="glossary-list">
    <dt id="term-composability">Composability</dt>
    <dd>
      <p>The principle that components should be designed to work together. In HAL8000-Assistant, commands, agents, and libraries can be composed into complex workflows through the universal interface of file I/O.</p>
      <p class="see-also">See also: <a href="#term-modularity">Modularity</a>, <a href="#term-universal-interface">Universal Interface</a></p>
    </dd>

    <dt id="term-depth-limit">Depth Limit</dt>
    <dd>
      <p>The maximum directory nesting depth of 3 levels enforced by Unix simplicity principle. Prevents excessive complexity in file system organization. Exception: external libraries maintain their original structure for compatibility.</p>
      <p class="see-also">See also: <a href="#term-simplicity">Simplicity Principle</a></p>
    </dd>

    <dt id="term-do-one-thing-well">Do One Thing Well</dt>
    <dd>
      <p>The foundational Unix principle that each component should have a single, well-defined responsibility. Applied to HAL8000-Assistant files, commands, agents, and libraries‚Äîeach does one thing and does it well.</p>
      <p class="see-also">See also: <a href="#term-modularity">Modularity</a>, <a href="#term-command">Command</a></p>
    </dd>

    <dt id="term-modularity">Modularity</dt>
    <dd>
      <p>The practice of building systems from small, focused, composable pieces. HAL8000-Assistant achieves modularity through single-purpose commands, specialized agents, categorized libraries, and clear component boundaries.</p>
      <p class="see-also">See also: <a href="#term-do-one-thing-well">Do One Thing Well</a>, <a href="#term-composability">Composability</a></p>
    </dd>

    <dt id="term-simplicity">Simplicity Principle</dt>
    <dd>
      <p>The Unix tenet favoring simple structures over complex ones. In HAL8000-Assistant: max 3-level directory depth, minimal abstractions, plain text files, direct access to components. Complexity is managed through composition, not intricate internal structure.</p>
      <p class="see-also">See also: <a href="#term-depth-limit">Depth Limit</a></p>
    </dd>

    <dt id="term-universal-interface">Universal Interface</dt>
    <dd>
      <p>File I/O as the common language for all system components. Commands, agents, libraries, data, and system state all interact through reading and writing files. This creates consistent, composable interfaces across the entire system.</p>
      <p class="see-also">See also: <a href="#term-composability">Composability</a></p>
    </dd>
  </dl>

  <h3>File System Terms</h3>
  <dl class="glossary-list">
    <dt id="term-hierarchical-index">Hierarchical Index</dt>
    <dd>
      <p>The multi-level indexing system stored in .claude/indexes/ comprising master.json (entire file system) and per-directory JSON files. Enables scalable discovery for 1000+ directories with 2-5K token cost instead of loading all files.</p>
      <p class="see-also">See also: <a href="#term-index">Index</a>, <a href="#term-master-index">Master Index</a></p>
    </dd>

    <dt id="term-indexed-directory">Indexed Directory</dt>
    <dd>
      <p>A directory that has a corresponding JSON index file in .claude/indexes/ cataloging its contents. Indexed directories support efficient discovery without loading all contained files into RAM.</p>
      <p class="see-also">See also: <a href="#term-hierarchical-index">Hierarchical Index</a></p>
    </dd>

    <dt id="term-library-index">Library Index</dt>
    <dd>
      <p>The .claude/libraries/index.json file cataloging all available libraries (internal and external), their patterns/workflows, categories, and metadata. Enables pattern discovery without loading full library contents into RAM.</p>
      <p class="see-also">See also: <a href="#term-library">Library</a>, <a href="#term-index">Index</a></p>
    </dd>

    <dt id="term-master-index">Master Index</dt>
    <dd>
      <p>The .claude/indexes/master.json file providing a top-level catalog of the entire file system structure. Entry point for hierarchical discovery, references per-directory indexes for detailed exploration.</p>
      <p class="see-also">See also: <a href="#term-hierarchical-index">Hierarchical Index</a></p>
    </dd>

    <dt id="term-working-directory">Working Directory</dt>
    <dd>
      <p>The current directory context for file operations. In HAL8000-Assistant, typically /mnt/d/~HAL8000-Assistant/ (the system root). Commands and operations execute relative to this directory unless absolute paths are used.</p>
    </dd>
  </dl>

  <h3>MCP Terms</h3>
  <dl class="glossary-list">
    <dt id="term-mcp-resource">MCP Resource</dt>
    <dd>
      <p>A data entity exposed by an MCP server that can be read or accessed. Resources provide structured access to external data sources through the MCP protocol.</p>
      <p class="see-also">See also: <a href="#term-mcp-server">MCP Server</a></p>
    </dd>

    <dt id="term-mcp-server">MCP Server</dt>
    <dd>
      <p>A Model Context Protocol server providing tools, resources, or prompts to Claude. HAL8000-Assistant configures MCP servers in .mcp.json. Examples: omnisearch (web search/extraction), filesystem (file operations), ide (VS Code integration).</p>
      <p class="see-also">See also: <a href="#term-mcp-tool">MCP Tool</a>, <a href="#term-stdio-transport">stdio Transport</a></p>
    </dd>

    <dt id="term-mcp-tool">MCP Tool</dt>
    <dd>
      <p>A function provided by an MCP server that Claude can invoke to perform operations. Examples: web_search (omnisearch), read_file (filesystem), getDiagnostics (ide). Tools extend Claude's native capabilities through external services.</p>
      <p class="see-also">See also: <a href="#term-mcp-server">MCP Server</a></p>
    </dd>

    <dt id="term-stdio-transport">stdio Transport</dt>
    <dd>
      <p>The communication mechanism for MCP servers using standard input/output streams. The MCP server process communicates with Claude through stdin/stdout, enabling process isolation and clean lifecycle management.</p>
      <p class="see-also">See also: <a href="#term-mcp-server">MCP Server</a></p>
    </dd>
  </dl>

  <h3>Development Terms</h3>
  <dl class="glossary-list">
    <dt id="term-instruction-set">Instruction Set</dt>
    <dd>
      <p>The collection of available commands and operations. In HAL8000-Assistant, the tools (Read, Write, Edit, Bash, etc.) ARE the instruction set‚Äîno abstraction layer exists between commands and tool invocations. This follows assembly language principles of direct hardware access.</p>
      <p class="see-also">See also: <a href="#term-command">Command</a></p>
    </dd>

    <dt id="term-package-manager">Package Manager</dt>
    <dd>
      <p>The system component (HAL-library-update command) responsible for library lifecycle management: checking updates, backup, download, replace, reindex. Essential OS infrastructure equivalent to apt, npm, or pip. Future: install and remove operations.</p>
      <p class="see-also">See also: <a href="#term-library">Library</a></p>
    </dd>

    <dt id="term-pc-register">PC (Program Counter) Register</dt>
    <dd>
      <p>A register pointing to the next instruction to execute. In the fetch-decode-execute cycle, PC determines which instruction is fetched next. Updated after each instruction execution or modified by control flow changes.</p>
      <p class="see-also">See also: <a href="#term-fetch-decode-execute">Fetch-Decode-Execute Cycle</a>, <a href="#term-register">Register</a></p>
    </dd>
  </dl>

  <h3>Protocol Terms</h3>
  <dl class="glossary-list">
    <dt id="term-context-awareness-protocol">Context Awareness Protocol</dt>
    <dd>
      <p>The operating principle for recognizing context hierarchy (User's Mind > Filesystem > RAM) and proactively detecting missing context signals. Steps: (1) Parse question for missing context signals, (2) Ask user for clarification before loading/searching, (3) Acquire context only after user clarifies, (4) Answer with context transparency about what's loaded and what's not.</p>
      <p class="see-also">See also: <a href="#term-selective-loading">Selective Loading</a>, <a href="#term-context-manifest">Context Manifest</a></p>
    </dd>

    <dt id="term-resource-management-protocol">Resource Management Protocol</dt>
    <dd>
      <p>The discipline for managing RAM resources: (1) Check CONTEXT_MANIFEST before loading, (2) Estimate token cost, (3) Evaluate projected RAM_ZONE, (4) Proceed/warn/refuse based on zone. Includes proactive checkpoint triggers, selective loading discipline, and "reduce and delegate" principle.</p>
      <p class="see-also">See also: <a href="#term-selective-loading">Selective Loading</a>, <a href="#term-ram-zone">RAM Zone</a></p>
    </dd>
  </dl>
</section>

            <!-- Appendix B: Troubleshooting -->
<section id="troubleshooting" class="doc-section">
  <h2>Appendix B: Troubleshooting</h2>
  
  <div class="troubleshooting-intro">
    <p>This section provides solutions to common issues encountered when operating the HAL8000-Assistant system. Problems are organized by category with specific symptoms, causes, solutions, and prevention strategies.</p>
    <p><strong>General Troubleshooting Approach:</strong></p>
    <ul>
      <li>Check system status with <code>/HAL-system-check</code></li>
      <li>Verify register states with <code>/HAL-register-dump</code></li>
      <li>Review current RAM usage in system warnings</li>
      <li>Consult <code>.claude/system.log</code> for historical context</li>
    </ul>
  </div>

  <div class="troubleshooting-category">
    <h3>1. Boot and Initialization Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: BIOS Not Loading</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> CPU does not acknowledge HAL8000-Assistant architecture on startup, no structured boot acknowledgment</p>
        <p><strong>Cause:</strong> <code>CLAUDE.md</code> file missing, corrupted, or not being read</p>
        <p><strong>Solution:</strong> Verify file exists at /mnt/d/~HAL8000-Assistant/CLAUDE.md, check permissions, restore from version control</p>
        <p><strong>Prevention:</strong> Never delete CLAUDE.md, treat as read-only ROM, keep in version control</p>
      </div>
    </div>

    <div class="troubleshooting-item">
      <h4>Problem: state.json Missing or Corrupted</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Boot fails with "CRITICAL: state.json not found", JSON parse errors</p>
        <p><strong>Solution:</strong> Check if .claude/state.json exists, validate JSON syntax, restore from system.log or create minimal valid state</p>
        <p><strong>Prevention:</strong> Always use /HAL-session-end to update state.json safely</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>2. RAM Management Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: RAM Zone Entering CAUTION (80-90%)</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Token usage 160K-180K/200K, RAM_ZONE shows CAUTION</p>
        <p><strong>Solution:</strong> Check RAM usage, run /HAL-register-dump, save work with /HAL-session-end, either continue carefully or restart fresh</p>
        <p><strong>Prevention:</strong> Use /HAL-context-find (saves 60-85% RAM), delegate to sub-agents, checkpoint at 70-75%</p>
      </div>
    </div>

    <div class="troubleshooting-item">
      <h4>Problem: RAM Zone Entering DANGER (90-100%)</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Token usage exceeds 180K/200K, system may refuse file loads</p>
        <p><strong>Solution:</strong> URGENT - Save session immediately with /HAL-session-end, offload results to files, complete only current operation, then restart</p>
        <p><strong>Prevention:</strong> Never let RAM reach DANGER zone, checkpoint at CAUTION (80%)</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>3. Session Continuity Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: Lost Context After RAM Wipe</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> New session starts with no knowledge of previous work</p>
        <p><strong>Solution:</strong> Check .claude/sessions/ for session files, review state.json active_session pointer, consult system.log for recent activity</p>
        <p><strong>Prevention:</strong> ALWAYS run /HAL-session-end before RAM wipe, include detailed context in session descriptions</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>4. Command and Agent Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: Command Not Found</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> /HAL-command-name reports "Command not found"</p>
        <p><strong>Solution:</strong> List available commands with ls .claude/commands/, verify naming convention HAL-*.md, check spelling (case-sensitive)</p>
      </div>
    </div>

    <div class="troubleshooting-item">
      <h4>Problem: Agent Launch Failures</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Agent doesn't launch or immediately terminates</p>
        <p><strong>Solution:</strong> Verify agent file exists in .claude/agents/, check file format, try simpler test to confirm environment can spawn agents</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>5. File System Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: Index Out of Sync</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Context-find can't locate files that exist, new files not in search results</p>
        <p><strong>Solution:</strong> Run /HAL-index-update to rebuild indexes, verify .claude/indexes/master.json timestamp</p>
        <p><strong>Prevention:</strong> Run /HAL-index-update after manual file system changes</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>6. MCP Integration Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: MCP Server Not Connecting</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> MCP tools unavailable, connection timeout errors</p>
        <p><strong>Solution:</strong> Check server status with /HAL-mcp-control status, verify .mcp.json configuration, restart server if needed</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>7. Library System Issues</h3>
    
    <div class="troubleshooting-item">
      <h4>Problem: Library Not Found</h4>
      <div class="problem-details">
        <p><strong>Symptoms:</strong> Library pattern search returns no results</p>
        <p><strong>Solution:</strong> Check library exists in .claude/libraries/, verify library index .claude/libraries/index.json, run /HAL-index-update</p>
      </div>
    </div>
  </div>

  <div class="troubleshooting-category">
    <h3>8. Diagnostic Commands Summary</h3>
    <ul>
      <li><code>/HAL-system-check</code> - Comprehensive system health check</li>
      <li><code>/HAL-register-dump</code> - Display all CPU register states</li>
      <li><code>/HAL-mcp-control status</code> - Check MCP server status</li>
      <li><code>/HAL-index-update</code> - Rebuild system indexes</li>
      <li><code>tail -50 .claude/system.log</code> - Recent system events</li>
    </ul>
  </div>

  <div class="troubleshooting-category">
    <h3>9. Emergency Recovery</h3>
    <p><strong>For catastrophic failures:</strong> Restore CLAUDE.md and state.json from version control, rebuild all indexes, start new session, run /HAL-system-check, review system.log for context.</p>
  </div>
</section>


            <!-- Appendix C: Design Decisions -->
<section id="design-decisions" class="doc-section">
  <h2>Appendix C: Design Decisions</h2>
  
  <div class="design-intro">
    <p>This appendix documents key architectural decisions, explaining the rationale, trade-offs, and alternatives considered.</p>
  </div>

  <div class="design-category">
    <h3>1. Modified von Neumann Architecture</h3>
    <p><strong>Decision:</strong> Hybrid architecture combining Harvard-like organization with von Neumann capabilities</p>
    <p><strong>Rationale:</strong> Claude Code requires commands in .claude/commands/ (environmental constraint), but commands can write to that directory (self-modifying code). Preserves stored-program concept while respecting constraints.</p>
    <p><strong>Trade-offs:</strong> More complex to explain than pure architecture, but provides best of both worlds</p>
  </div>

  <div class="design-category">
    <h3>2. Append-Only RAM Model</h3>
    <p><strong>Decision:</strong> Context window accumulates without dynamic eviction within session</p>
    <p><strong>Rationale:</strong> Claude's context window doesn't support selective unloading. Makes resource management explicit and forces selective loading discipline.</p>
    <p><strong>Trade-offs:</strong> Limited context within single session, but prevents false sense of unlimited RAM</p>
  </div>

  <div class="design-category">
    <h3>3. Session Boundaries as Garbage Collection</h3>
    <p><strong>Decision:</strong> Session end is the only way to reclaim RAM</p>
    <p><strong>Rationale:</strong> Append-only RAM means no partial cleanup possible. Mirrors real computer reboot clearing volatile memory.</p>
  </div>

  <div class="design-category">
    <h3>4. Unix Philosophy: 3-Level Depth Limit</h3>
    <p><strong>Decision:</strong> Maximum 3 directory levels (exception: external libraries)</p>
    <p><strong>Rationale:</strong> Unix simplicity principle. Deep hierarchies hard to navigate. Forces clear organization.</p>
    <p><strong>Trade-offs:</strong> May require flatter organization, but system remains navigable</p>
  </div>

  <div class="design-category">
    <h3>5. Sub-Agents as Virtual Memory</h3>
    <p><strong>Decision:</strong> Treat sub-agents as virtual memory with isolated 200K RAM contexts</p>
    <p><strong>Rationale:</strong> Extends total capacity beyond main session's 200K limit. Process isolation prevents RAM pollution.</p>
    <p><strong>Trade-offs:</strong> Sub-agent invocation overhead, but enables handling large tasks</p>
  </div>

  <div class="design-category">
    <h3>6. state.json as State Pointer</h3>
    <p><strong>Decision:</strong> Current state pointer only, overwritten on checkpoint (no history)</p>
    <p><strong>Rationale:</strong> Keeps boot lightweight (file always small). History belongs in system.log.</p>
  </div>

  <div class="design-category">
    <h3>7. Session Files Not Auto-Loaded</h3>
    <p><strong>Decision:</strong> Note session pointer but don't auto-load on boot</p>
    <p><strong>Rationale:</strong> Keeps boot lightweight, saves RAM. User may want different work than last session.</p>
  </div>

  <div class="design-category">
    <h3>8. Skipped Components</h3>
    <p><strong>No Instruction Set:</strong> Tools ARE the instruction set (Unix: do one thing well). No abstraction needed.</p>
    <p><strong>No Interrupts/Clock:</strong> Uncontrollable emergent behavior. Can't document what can't be controlled.</p>
    <p><strong>Rationale from state.json:</strong> "Unix principle - tools ARE the instruction set, interrupts/timers are uncontrollable emergent behavior"</p>
  </div>

  <div class="design-category">
    <h3>9. External Tools: Host-Installed Over Containers</h3>
    <p><strong>Decision:</strong> Prefer host-installed tools (Unix simplicity)</p>
    <p><strong>Rationale:</strong> Simpler architecture, better performance, standard installation. Docker available but not mandatory.</p>
    <p><strong>Lesson learned from state.json:</strong> "Host-installed tools preferred over containers (Unix simplicity)"</p>
  </div>
</section>


            <!-- Appendix D: Version History -->
<section id="version-history" class="doc-section">
  <h2>Appendix D: Version History</h2>
  
  <div class="version-intro">
    <p>HAL8000-Assistant evolution through development phases. For detailed change history, see <code>.claude/system.log</code>.</p>
  </div>

  <div class="version-block">
    <h3>Version 1.0.0 - Production Release (October 2025)</h3>
    <p><strong>Status:</strong> Production-ready with comprehensive documentation</p>
    <h4>New Components</h4>
    <ul>
      <li>Reference Manual System (31 sections, HTML-based)</li>
      <li>HAL-refman command for manual management</li>
      <li>HAL-CC-check command for interface validation</li>
      <li>Gemini CLI integration (1M context window)</li>
      <li>Docker environment support</li>
    </ul>
    <h4>System Metrics</h4>
    <p>Commands: 9 | Agents: 5 | MCP Servers: 4 (2 active) | Library Patterns: 226 | External Libraries: 1</p>
  </div>

  <div class="version-block">
    <h3>v0.9.0 - Integration Phase (October 2025)</h3>
    <p>MCP stdio migration, Gemini CLI integration, Docker verification</p>
    <p><strong>Lesson:</strong> External agents extend HAL8000-Assistant beyond 200K sub-agents. Host-installed tools preferred (Unix simplicity).</p>
  </div>

  <div class="version-block">
    <h3>v0.8.0 - Library & Extension System</h3>
    <p>Library architecture, Agent architecture, Package manager (HAL-library-update), 226 patterns indexed</p>
  </div>

  <div class="version-block">
    <h3>v0.7.0 - Context Management</h3>
    <p>Context-finder agent (60-85% RAM savings), Context Awareness Protocol, Research-synthesizer refactor</p>
  </div>

  <div class="version-block">
    <h3>v0.6.0 - Resilience & Recovery</h3>
    <p>System health check, Verified boot sequence, Degraded mode, State validation, Hierarchical indexing</p>
  </div>

  <div class="version-block">
    <h3>v0.5.0 - Core System Components</h3>
    <p>Register architecture (21 registers), Operating principles, Buses, I/O system, RAM Performance Zones (SAFE/CAUTION/DANGER)</p>
  </div>

  <div class="version-block">
    <h3>v0.4.0 - Early Development</h3>
    <p>CPU identity, Memory architecture, BIOS (CLAUDE.md), Session continuity, HAL-session-end command</p>
    <p><strong>Decisions:</strong> Modified von Neumann, Append-only RAM, Session boundaries as garbage collection</p>
  </div>

  <div class="version-block">
    <h3>v0.1.0 - Genesis (October 2025)</h3>
    <p>Research: von Neumann architecture, Unix philosophy, Assembly principles. Initial repository structure.</p>
  </div>
</section>
            <!-- Appendix E: Index -->
<section id="index" class="doc-section">
  <h2>Appendix E: Index</h2>
  
  <div class="index-intro">
    <p>Complete navigation: Table of Contents (hierarchical) and Topical Index (alphabetical).</p>
  </div>

  <h3>Table of Contents</h3>
  <div class="toc-detailed">
    <p><strong>Frontmatter:</strong> Title, Abstract, How to Use, Conventions</p>
    <p><strong>Part I - Introduction:</strong></p>
    <ul>
      <li>1. What is HAL8000-Assistant?</li>
      <li>2. Why Was It Built?</li>
      <li>3. Design Philosophy</li>
      <li>4. System Metaphor</li>
    </ul>
    <p><strong>Part II - Architecture:</strong></p>
    <ul>
      <li>5. Architecture Overview</li>
      <li>6. Memory Architecture</li>
      <li>7. Component Specifications</li>
      <li>8. Register Architecture</li>
      <li>9. Operating Principles</li>
    </ul>
    <p><strong>Part III - User Guide:</strong></p>
    <ul>
      <li>10. Quick Start</li>
      <li>11. Daily Operations</li>
      <li>12. Session Management</li>
      <li>13. Common Workflows</li>
      <li>14. RAM Management</li>
    </ul>
    <p><strong>Part IV - Reference:</strong></p>
    <ul>
      <li>15. Command Reference</li>
      <li>16. Agent Reference</li>
      <li>17. File System Structure</li>
      <li>18. MCP Integration</li>
      <li>19. External Tools</li>
    </ul>
    <p><strong>Part V - Development:</strong></p>
    <ul>
      <li>20. Creating Commands</li>
      <li>21. Building Agents</li>
      <li>22. Library System</li>
      <li>23. Contributing</li>
    </ul>
    <p><strong>Appendices:</strong> A. Glossary | B. Troubleshooting | C. Design Decisions | D. Version History | E. Index</p>
  </div>

  <h3>Topical Index (Quick Reference)</h3>
  <div class="topical-index">
    <p><strong>A-C:</strong> Agent, ALU, Append-Only RAM, BIOS, Boot Sequence, Checkpoint, CLAUDE.md, Commands, CPU, Context Awareness</p>
    <p><strong>D-F:</strong> Degraded Mode, Fetch-Decode-Execute, File System</p>
    <p><strong>G-M:</strong> Glossary, HAL-session-end, HAL-register-dump, HAL-context-find, Index, Library, MCP, Memory Architecture, Modified von Neumann</p>
    <p><strong>P-R:</strong> PC Register, RAM, RAM Zones (SAFE/CAUTION/DANGER), Registers, Resource Management</p>
    <p><strong>S-Z:</strong> Selective Loading, Session Continuity, state.json, Sub-Agent Protocol, Troubleshooting, Unix Philosophy, Version History, Virtual Memory</p>
  </div>

  <p><em>For detailed cross-references and section links, see the glossary and individual sections.</em></p>
</section>




        </main>
    </div>
</body>
</html>
